<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> | By1way</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '23548c5ffb96043176d784e058b0ea36';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">By1way</h1><a id="logo" href="/.">By1way</a><p class="description">用心记录每一份成长、每一滴收获、每一个新奇</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-content"><p>容器用途<br>1、标准化打包（集装箱）<br>2、隔离（集装箱）<br>3、标准化部署</p>
<p>虚拟机<br>hypervisor<br>强隔离机制（隔离性好）</p>
<p>容器更轻量级</p>
<p>docker窗口核心技术<br>cgroups (cpu cpuset memory device)<br>namespace(pid mnt ipc uts net)<br>networking (veth bridge iptables)<br>storage(device-mapper btfrs aufs)</p>
<p>容器镜像<br>固化的操作系统，不是完整的操作系统</p>
<p>共享宿主机内核<br>分层组织方式，方便镜像层复用</p>
<p>docker架构<br>client(docker build /pull/run)<br>docker host(docker deamon)<br>registry(docker hub )</p>
<p>docker compose<br>多容器部署，一键部署<br>docker compose up<br>适用于本地测试环境<br>生产环境，kubernetes云平台 </p>
<h2 id="容器镜像构建dockerfile解析"><a href="#容器镜像构建dockerfile解析" class="headerlink" title="容器镜像构建dockerfile解析"></a>容器镜像构建dockerfile解析</h2><h3 id="springboot如何做容器化"><a href="#springboot如何做容器化" class="headerlink" title="springboot如何做容器化"></a>springboot如何做容器化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//dockerfile</span><br><span class="line">from java:8-jdk-alpine</span><br><span class="line">copy ./target/xxx.jar /usr/app</span><br><span class="line">workdir /usr/app</span><br><span class="line">entrypoint [<span class="string">"java"</span>,<span class="string">"- jar "</span>,<span class="string">" xxxx.jar"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="单页应用如何容器化"><a href="#单页应用如何容器化" class="headerlink" title="单页应用如何容器化"></a>单页应用如何容器化</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![单页应用Dockerfile](docker_files/1.jpg)</span><br></pre></td></tr></table></figure>
<p> 到底什么是云原生架构？<br> 基于微服服原理而开发的应用，以容器方式打包。在运行时，<br> 容器由运行于云基础设施之上的平台进行高度。应用开采用持续交付和devops实践。</p>
<p> kubenetes解决什么问题<br> 本质上简化微服务的开发和部署</p>
<p> 把微服务的关注点都以组件的形式提供出来</p>
<h2 id="kubernetes架构"><a href="#kubernetes架构" class="headerlink" title="kubernetes架构"></a>kubernetes架构</h2><p> 典型的master -slave架构，master多节点部署，真正做调度的只有一个master节点，这里头有一个选主的动作。 如一个主master节点挂，其他的节点就会再选一个主master顶上去，这个动作也是由etcd来完成的。</p>
<h3 id="master节点组件"><a href="#master节点组件" class="headerlink" title="master节点组件"></a>master节点组件</h3><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p> 基于key-value分布式存储机制，底层采用raft协议, 状态数据：配置、节点pod，最终都存储在etcd中。etcd集群单独部署</p>
<h4 id="api-server"><a href="#api-server" class="headerlink" title="api server"></a>api server</h4><p>对外提供操作或获取Kubernetes集群资源的api, 唯一操作etcd的组件，其他组件 ，管理员操作都能是通过apiserver进行操作， 进行交互，可以理解 为etcd的代理proxy</p>
<h4 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h4><p>Kubernetes集群的大脑，做调度决策，比如 对于新的应用发布请求，scheduler负责决策相应的pods应该分布在哪些worker节点上</p>
<h4 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller manager"></a>controller manager</h4><p>相当于是集群状态的协调者，观察目前集群的实际状态，和etcd当中的预期状态两者进行比对 ，不一致就对资源进行协调操作。 让两个状态达到最终一致，Kubernetes采用最终一致调度机制，这种机制支持自愈(self-healing)。不管是后续节点挂还是容器挂，都能最终恢复， 即使在严重故障的情况，只要etcd中的预期数据还在，Kubernetes都能最终恢复到最终预期状态。</p>
<h3 id="worker节点组件"><a href="#worker节点组件" class="headerlink" title="worker节点组件"></a>worker节点组件</h3><h4 id="container-runtime"><a href="#container-runtime" class="headerlink" title="container runtime"></a>container runtime</h4><p>下载镜像和运行容器的组件，如果采用docker，每个节点都运行一个docker deamon,运行容器的时候，如果本地没有镜像，deamon会从docker registry上抓取镜像。</p>
<h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><p>Kubernetes中特有的概念，可以理解为对容器的一个包装，是Kubernetes的基本调度单位。实际容器是跑在pod中，一个节点可以启动一个或多个pod，一个应用的pods的可以分布一个或多个节点上。</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>管理worker节点的组件 ，相当于一个agent角色 ，和master节点的api server进行交互，接收指令执行操作。如启动pod、关闭pod， 也返回状态数据，或者事件返回到mster。 如scheduler-Kubernetes集群的大脑，kubelet是每个worker节点的小脑</p>
<h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>负责对pod进行寻址和负载均衡的组件，是实现service 和服务发现抽象的关键，底层操作iptable规则。</p>
<p>用户操作Kubernetes集群，一般是通过kubectl,命令行工具，或者dashboard，如果有需要，可以通过api sdk，直接开发工具来访问Kubernetes集群， 背后这些工具都通过api esrver和Kubernetes集群进行交互。</p>
<p>Kubernetes和pod之间进行通讯，走的都是overlay覆盖网络，外部流量进入Kubernetes访问pod,一般是通过lb（负载均衡）设备。此外集群的外围一般还有存储、监控、日志、分析等配套的服务。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>架构比较复杂重量，自己搭建和运维一套生产级的Kubernetes集群 ，中小企业不建议自建或运维Kubernetes集群，建议采用公用云Kubernetes。比如阿里云的Kubernetes集群服务</p>
<h2 id="Kubernetes基本概念"><a href="#Kubernetes基本概念" class="headerlink" title="Kubernetes基本概念"></a>Kubernetes基本概念</h2><h3 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h3><p><img src="/cloudnative/docker_files/2.jpg" alt><br>有很多节点组成，可以按照增加节点，节点可以物理机，也可以虚拟机<br>整个集群可以抽象 看作是一个越大计算机，cpu 和内存容量是所有节点的总和。可以按需给超大计算增加更多的cpu和内存</p>
<h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 Container"></a>容器 Container</h3><p><img src="/cloudnative/docker_files/3.jpg" alt><br>Kubernetes是容器调度平台 ，容器是基本概念。容器轻量级虚拟化技术 ，宿主机操作系统的角度来看，容器是一个又一个的进程。<br>从容器内部视角，感觉就是一个完整的操作系统 ，有自己的文件系统、cpu、网络、内存等</p>
<h3 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h3><p><img src="/cloudnative/docker_files/1.jpg" alt><br>Kubernetes并没有直接调度容器，而是在外面重新封装了一个叫pod的概念<br>pod是Kubernetes的基本调度单位 ，一个pod里面可以有一个或多个容器，共享pod的文件系统和网络。每个pod有独立的ip,pod里面的容器共享ip和端口空间，并且 同一个pod里面的容器，通过 localhost相互访问。大部分情况下，一个pod只有一个应用容器。</p>
<p>封装Pod概念的原因是，<br>1、考虑一些需要辅助容器的场景 ，比如 一个需要sidecar的场景<br>2、考虑替换使用不同的容器技术 </p>
<h3 id="副本集-ReplicaSet"><a href="#副本集-ReplicaSet" class="headerlink" title="副本集 ReplicaSet"></a>副本集 ReplicaSet</h3><p><img src="/cloudnative/docker_files/4.jpg" alt></p>
<p>一个应用在发布的时候一般不是只发布一个pod实例，为了实现HA也会发布多个pod实例。<br>就是和一个应用的一组pod相对应的概念，可以通过模板（yaml,json）来规范某个应用的容器、镜像、端口副本数量、volume、健康检查机制等，都可以通过模板来规范。<br>运行时，replicaset会监控和维护pod数量，少了会增加，多了会减少。replication controller替代品 了</p>
<h3 id="服务-Service"><a href="#服务-Service" class="headerlink" title="服务 Service"></a>服务 Service</h3><p><img src="/cloudnative/docker_files/5.jpg" alt><br>pod是Kubernetes中是一个ifumurable(不固定的)，有可能会随时挂，重启（预期的，非预期的）。这样就会导致服务ip会不断变化，如果服务实例ip不固定，会随时变化，那么服务的消费者如何才能寻址呢？Kubernetes通过引入service这样一个抽象概念来解决这个问题，service屏蔽了应用的ip寻址和负载均衡这些细节，消费方可以直接通过服务名来访问目标服务，Kubernetes中的service的底层机制会做寻址和负载均衡，即使应用的podip发生变更 ，service也会屏蔽这种变更，让消费方无感知。是Kubernetes的重要概念</p>
<h3 id="发布-Deployment"><a href="#发布-Deployment" class="headerlink" title="发布 Deployment"></a>发布 Deployment</h3><p><img src="/cloudnative/docker_files/6.jpg" alt></p>
<p>副本集可以认为是一种基本的发布机制，也可以实现高级的发布功能，比如（金丝雀、蓝绿、滚动发布）也可以通过replicaset来实现，但是这个操作起来比较麻烦。为了简化这些高级的发布，Kubernetes在replicaset的基本上，又引入了deployment的概念。<br>就是用来管理replicatset的，实现高级发布机制。<br> <img src="/cloudnative/docker_files/7.jpg" alt="滚动发布案例Rolling Update"></p>
<p> 即使发布失败了也可以通过deployment来回退版本，是一种更灵活的发布机制。<br> 特别强调一下，deployment和replicaset是个微服务 发布相关的两个最重要概念，也是发布过程中经常要使用的两个概念，我们的发布时候，所书写定义的发布描述文件，主要是yaml,json,里面主要就是deployment和replicaset的规范，所以这两个概念<br>必须完全理解。deployment是基于replicaset之上的概念，发布应用的时候 deployment会创建replicaset,replicaset会根据规范会创建应用pod实例，并且维护和保障pod的数量，升级的时候deployment会创建新的replicaset，调度实现滚动发布，也实现发布回退这些功能。<br> <img src="/cloudnative/docker_files/8.jpg" alt="发布和服务总结"><br> 上图中，两个应用的A和B 的发布，分别有两组deployment和replicaset,来控制和管理。service是服务间相互路由和寻址的概念，首先，Kubernetes集群内部的client通过service可以间接的访问目标应用的pod，其次Kubernetes集群外部的client如果要访问内部 的pdo也是通过 service间接访问。</p>
<h3 id="ConfigMap-Secret"><a href="#ConfigMap-Secret" class="headerlink" title="ConfigMap/Secret"></a>ConfigMap/Secret</h3><p> <img src="/cloudnative/docker_files/9.jpg" alt><br> Kubernetes中另一个核心概念，微服务在上线的时候常常需要设置一些可变配置，这些配置针对不同环境，对应的配置值不同，这些配置有些是在启动期一次性配置好，比如连接串，还有一些配置是在运行期动态调整的，比如ttl值、缓存时间，限购数量等，所以微服务需要配置中心的支持，实现针对不同环境的灵活的配置。<br> Kubernetes平台内置支持微服务的配置，对应概念就叫configmap，是平台<br> configmap是Kubernetes的一种资源，开发人员将配置填写在configmap中，支持将这些配置 以环境变量的形式注入到pod当中，pod中的应用以环境变量的形式去访问到这些配置，也支持以持久卷volume mnt到pod中，这样pod的中应用以本地配置文件的形式来访问这些配置，有些配置是涉及敏感数据的，比如用户名密码，案例证书等，Kubernetes通过secrect这种概念支持敏感数据的配置，<br> Secret是一种特殊的configmap，提供更安全存储和访问配置的机制。也是经常用到的</p>
<h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p> <img src="/cloudnative/docker_files/10.jpg" alt><br> 还有一种场景 ，经常碰到 的，在每个节点上常驻一个守护进程（daemon），比如监控场景，需要在每个机器上部署一个日志采集进程，针对这种场景，Kubernetes支持一个叫daemontset的发布概念，<br> 在每个woker节点上部署一个守护进程pod，并且保证每个节点有且仅有一个这样的pod。</p>
<h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><p> volume-磁盘文件存储，本地存储，远程 存储<br> persistentvolume-超大磁盘存储抽象和分配机制<br> persistentvolumeClaims-应用申请pv是要遵守的规范<br> statefulset-有状态应用的发布机制，（replicaset是无状态应用发布）mysql,redis缓存<br> job-跑一次的任务<br> cronjob-周期的任务</p>
<h3 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h3><p> Lable/Selector 对Kubernetes上的pod打标签 ，标识pod是属于前端还是后端，生产的还是测试的，Selector是通过标签查询label的机制<br> namespace-逻辑隔离机制，<br> readiness probe(就绪探针)-用于判定pod是否可以接入流量<br> liveness probe(活跃探针)-用于判定pod是否存活</p>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><p><img src="/cloudnative/docker_files/11.jpg" alt></p>
<h2 id="kubernetes网络"><a href="#kubernetes网络" class="headerlink" title="kubernetes网络"></a>kubernetes网络</h2><p> <img src="/cloudnative/docker_files/12.jpg" alt=" kubernetes的网络"></p>
<h3 id="kubernetes节点网络"><a href="#kubernetes节点网络" class="headerlink" title="kubernetes节点网络"></a>kubernetes节点网络</h3><p>保证worker与worker节点之间的通讯，</p>
<h3 id="pod网络"><a href="#pod网络" class="headerlink" title="pod网络"></a>pod网络</h3><p> pod内的容器共享pod的网络栈，pod网络栈是由pod中的pause创建的，<br> 不同的容器共享pod的ip和端口，pod内的网络同节点之间的网络是通过虚拟的网桥来做关联的，并通过节点之间的路由规则访问到其他节点上的pod内的具体容器</p>
<h3 id="service网络"><a href="#service网络" class="headerlink" title="service网络"></a>service网络</h3><h4 id="服务发现原理service-discovery"><a href="#服务发现原理service-discovery" class="headerlink" title="服务发现原理service discovery"></a>服务发现原理service discovery</h4><p> 一般在微服务中，服务发现是通过服务注册表和服务代理proxy，这些机制来配合实现。比如说spring cloud，当中通过 eureka和rebbion来可以实现服务发现，eureka是服务注册表，服务启动时会将实例地址注册到eureka，rebbion是相当于客户端代理，获取e上的服务实例地址列表，调用目标服务实例，调用时可以采用某种负载均衡策略，这是eureka和rebbion中的微服务服务发现机制。</p>
<p> 服务注册表master节点的apiserver<br> 代理，kubeprxy+netfilter（linux内核的代理机制，可以通过iptable规则来实现包过滤和转发）配合</p>
<p> 微服务与微服务之间是如果通讯的<br> 前后端分离如果验证权限</p>
</div></div><div id="lv-container" data-id="city" data-uid="MTAyMC80MzczNi8yMDI3NQ=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NoSQL数据/">NoSQL数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/attendance/">attendance</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/专业英语/">专业英语</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/专栏学习/">专栏学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/宝库/">宝库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文档服务器/">文档服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构师视角/">架构师视角</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构师训练营/">架构师训练营</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构探索/">架构探索</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/重启/">重启</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/原始分布式时代/" style="font-size: 15px;">原始分布式时代</a> <a href="/tags/重启/" style="font-size: 15px;">重启</a> <a href="/tags/单体系统/" style="font-size: 15px;">单体系统</a> <a href="/tags/SOA时代/" style="font-size: 15px;">SOA时代</a> <a href="/tags/后微服务时代/" style="font-size: 15px;">后微服务时代</a> <a href="/tags/无服务时代/" style="font-size: 15px;">无服务时代</a> <a href="/tags/微服务时代/" style="font-size: 15px;">微服务时代</a> <a href="/tags/远程服务调用/" style="font-size: 15px;">远程服务调用</a> <a href="/tags/ARTS/" style="font-size: 15px;">ARTS</a> <a href="/tags/Link/" style="font-size: 15px;">Link</a> <a href="/tags/资源/" style="font-size: 15px;">资源</a> <a href="/tags/课堂笔记/" style="font-size: 15px;">课堂笔记</a> <a href="/tags/分享/" style="font-size: 15px;">分享</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/Echarts/" style="font-size: 15px;">Echarts</a> <a href="/tags/阅读/" style="font-size: 15px;">阅读</a> <a href="/tags/FastDFS/" style="font-size: 15px;">FastDFS</a> <a href="/tags/分布式文档服务器/" style="font-size: 15px;">分布式文档服务器</a> <a href="/tags/存储系统/" style="font-size: 15px;">存储系统</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/07-远程服务调用/">07.远程服务调用</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/06-无服务时代的探索/">06.无服务时代：不分布式云端系统的起点</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/05-后微服务时代的探索/">05.后微服务时代：跨越软件与硬件之间的界限</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/04-微服务时代的探索/">04.微服务时代：SOA的革命者</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/03-SOA时代的探索/">03.SOA时代：成功理论与失败实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/02-单体系统时代的探索/">02.单体系统时代</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/01-原始分布式时代的探索/">01.原始分布式时代</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/07/00-日走一卒，重启航/">00.慢慢的我来了</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/transaction1/">事务处理一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/07/transaction3/">事务处理三</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://wild2pro.com/" title="写程序的厨子" target="_blank">写程序的厨子</a><ul></ul><a href="https://lilyssh.cn/" title="lilyssh(新认识的一个技术牛人)" target="_blank">lilyssh(新认识的一个技术牛人)</a><ul></ul><a href="https://www.byway.xyz/" title="我自己" target="_blank">我自己</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">By1way.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Carol.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>