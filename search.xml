<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[07.远程服务调用]]></title>
    <url>%2F2021%2F02%2F07%2F07-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[说实话，可能是因为我的理解能力有点小问题，这篇文章读了好几遍才大概明白了点其中的道道。为了防止大家跟我一样学习的时候会晕菜。所以我决定先把作者的行文思路给大家画出来。 介绍了下架构师的职责 RPC在众眼里是什么样的呢？为什么一直这么火呢 借用本地调用过程的例子来引入，同时做出假设调用者和被调用者不在同一个进程之内 解决上面步骤2问题的方法，有六种。尤其是最后一种本地套接字接口，它的设计理念简直直RPC最初的目的不谋而合 但在那个时候对于透明的分布式系统而言，别说存在着大量的问题需要解决的，就连认识上都存在大量误解。 最终，施乐公司的Palo Alto研究中心，发布了第一个基于RPC的应用，并正式提出了RPC的概念。 ​ 在这篇文章中有几个提法比较有意思：比如RPC作为分布式前置的基础条件，再比如RPC应该是一种高层次的，或者说语言层次的特征，而不是像IPC那样，是低层次的，或者说系统层次的特征；还有RPC以模拟进程间方法调用为起点，许多思想和概念都借鉴的是IPC，都能给人耳目一新的感觉。 好了下面咱们开始正式的内容： 0. 架构师的职责12345678什么架构师呢？有做企业战略设计的架构师，有做业务流程分析的架构师……在这里呢？特指软件系统中技术模型的设计者。架构师工作的三个问题？* 做架构设计的时候，架构师都应该思考哪些问题呢？* 都可以选择哪些主流的解决方案和行业标准做法呢？* 以及这些方案都有什么优缺点，都会给架构设计带来什么影响呢？ 1.大众眼中的RPC（远程服务调用）？关于RPC三个小问题： 1. RPC本身可以解决什么问题呢 2. 这些问题又是怎么被解决的呢？ 3. 为什么要这样解决呀 RPC为什么这么火热的原因： 可能是微服务风潮带来的热度 作为开发者，我们很多人对RPC本身可以解决什么问题、如何解决这些问题、为什么要这样解决，都或多或少存在些认知模糊的情况 2. 本地方法调用​ 本地方法调用几个概念 12345678// 调用者（Caller） ： main()// 被调用者（Callee） ： println()// 调用点（Call Site） ： 发生方法调用的指令流位置// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即“hello world”// 返回值（Retval） ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常public static void main(String[] args) &#123; System.out.println("hello world");&#125; 做一个假设：如果在调用println()的时候，发现它并不在当前内存地址空间中，又会出现什么问题呢？ 前面的传递参数、传回结果都依赖于栈内存的帮助，如果Caller与Callee分属不同的进程，就不会拥有相同的栈内存，那么在Caller进程的内存中将参数压栈，对于Callee进程的执行毫无意义。 println()方法版本选择依赖于语言规则的定义，而如果Caller与Callee不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。 如何解决两个进程间通讯的问题问题： 1. 管道（Pipe）或具名管道（Named Pipe）: 管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。 2. 信号（Signal）: 信号是用来通知目标进程有某种事件发生的。除了用于进程间通信外，信号还可以被进程发送给进程自身。信号的典型应用是kill命令，比如“kill -9 pid”，意思就是由Shell进程向指定PID的进程发送SIGKILL信号。 3. 信号量（Semaphore）:信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行wait()和notify()操作。 4. 消息队列（Message Queue）:进程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点 ，但实时性相对受限。 5. 共享内存（Shared Memory）: 允许多个进程可以访问同一块内存空间，这是效率最高的进程间通讯形式。进程的内存地址空间是独立隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的接口。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。 6. &lt;font color=&quot;red&quot;&gt;本地套接字接口（IPC Socket）: 消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。&lt;/font&gt; 3.竟然不谋而合​ RPC可以作为IPC的一种特例来看待。 ​ IPC Socket是操作系统提供的标准接口，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到远程调用与本地方法调用几乎完全一致。 ​ 还记得远程服务调用最初的目的吗？与调用本地方法一致。 4.透明RPC调用存在的问题 两个进程通讯，谁作为服务端，谁作为客户端？ 怎样进行异常处理？异常该如何让调用者获知？ 服务端出现多线程竞争之后怎么办？ 如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？是否支持多播？ 参数、返回值如何表示？应该有怎样的字节序？ 如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？ 服务端发送请求后，收不到回复该怎么办？ ​ 分布式运算的八宗罪： 网络是可靠的（The network is reliable） 延迟是不存在的（Latency is zero ） 带宽是无限的（Bandwidth is infinite） 网络是安全的（The network is secure） 拓扑结构是一成不变的（Topology doesn’t change） 总会有一个管理员（There is one administrator） 不考虑传输成本（Transport cost is zero） 网络是同质化的（The network is homogeneous） 5.RPC的概念​ 传奇的施乐Palo Alto研究中心，发布了基于Cedar语言的RPC框架Lupine，并实现了世界上第一个基于RPC的商业应用Courier。并提出了RPC的概念，也就我们今天看到： 1RPC是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机） 思考题1“远程方法不应该无视通讯成本”这个观点，从性能的角度来看是有益的，但从简单的角度看则是有害的。在现代的软件系统开发中，你用过什么RPC框架吗？它们有没有把“像本地方法一样调用远程方法”作为卖点？]]></content>
      <categories>
        <category>架构师视角</category>
      </categories>
      <tags>
        <tag>远程服务调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.无服务时代：不分布式云端系统的起点]]></title>
    <url>%2F2021%2F02%2F07%2F06-%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。分布式架构也会引入一些新问题（比如服务的安全、容错，分布式事务的一致性），因此对软件开发这件事儿来说，不去做分布式无疑是最简单的。 云计算的成功其实已经实现了相对意义上无限性能。 对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，AWS、阿里云等云服务提供商都能在算力上满足系统对性能的需求，只要你能为这种无限的性能支付得起对应的代价。这样”无服务“概念也就产生了。 无服务架构特点 后端设施，指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“后端即服务” 函数，指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划，也就是无服务中的“函数即服务” 无服务的愿景 不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼 不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成 不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的 也不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任 虽然无服务架构的远期前景也许很美好，但无服务中短期内的发展，并没有那么乐观。为什么这么说呢？ 与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式。所以除非是有重大变革，否则它也很难具备普适性。 无服务架构的局限性​ 无服务天生“无限算力”的假设，就决定了它必须要按使用量（函数运算的时间和内存）来计费，以控制消耗算力的规模，所以函数不会一直以活动状态常驻服务器，只有请求到了才会开始运行。这导致了函数不便于依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能会太好。 前面第一节讲到，在首次对分布式的探索失败之后，大型软件的发展出现了两个方向，一个是以分布式为基础的探索，另一个以不分布式为目的的探索。如果说服务网格是在分布式道路上的探索的最新方向，那无服务架构就是在不分布式这条道路上的努力 。但这两条路线的边界也是越来越模糊，最终将会在云端的数据中心处交汇。 需要注意的是：无服务和微服务、云原生并没有继承替代的关系，因此也不能有无服务比微服务更加先进的想法 思考题是否了解、接触过无服务架构？无服务目前在中国处于起步的发展阶段，阿里云、腾讯云的无服务计算框架，都给了普通用户相当大的免费额度，你愿意去试一下吗？]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>无服务时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05.后微服务时代：跨越软件与硬件之间的界限]]></title>
    <url>%2F2021%2F02%2F07%2F05-%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[抛开微服务架构，先看看下面几个问题的解决思路： 如果某个系统需要伸缩扩容，我们通常会购买新的服务器，多部署几套副本实例来分担压力； 如果某个系统需要解决负载均衡的问题，我们通常会布置负载均衡服务器，并选择恰当的均衡算法来分流； 如果需要解决安全传输的问题，我们通常会布置TLS传输链路，配置好CA证书，以保证通讯不被窃听篡改； 如果需要解决服务发现的问题，我们通常会设置DNS服务器，让服务访问依赖稳定的记录名而不是易改变的IP地址等等 从上面的几个问题，我们就可以发现这些问题已经大多都有了专职的基础设施来帮助解决了，那为什么微服务还必须在应用层面上去解决这问题呢？ 原因就在于：因为硬件构成的基础设施，跟不上软件构成应用服务的灵活性。 既然软件可以通过命令就可以拆分出不同的服务，那么硬件不可以吗？这就到云原生的时代，微服务时代所取得的成就，本身就离不开以Docker为代表的早期容器化技术的巨大贡献。 近些年蓬勃发展的Kubernetes，可以说是开启了下一个软件架构发展的新纪元。对比下Spring Cloud中提供的应用层面的解决方案，Kubernetes也从基础设施层面给出它的解决方案，而且还是一条全新的、前途更加广阔的解题思路。虽然这一切看起来都很美好，但是从功能灵活性的特点上来，Kubernetes还不如Spring Cloud方案。因为从基础设施层面上很精细化解决一些边缘化的问题（比如做服务熔断）。因为基础设施针对的是整个容器做整体的管理，它的粒度相对来说比较粗犷。 所以微服务的基础设施再次进化，就引出了叫做服务网格的”边车代理模式“。 边车代理模式微服务基础设施会由系统自动地在服务的资源容器（指Kubernetes的Pod）中注入一个通讯代理服务器（相当于那个挎斗），用类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄悄接管掉应用的所有对外通讯。 这个代理除了会实现正常的服务调用以外（称为数据平面通讯），同时还接受来自控制器的指令（称为控制平面通讯），根据控制平面中的配置，分析数据平面通讯的内容，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。 这样，就实现了既不需要在应用层面附带额外的代码，也提供了几乎不亚于应用代码的精细管理能力的目的。 代表性技术：Istio、Envoy 新技术发展时间比较短，还没有完全成熟起来。但未来可期 思考题分布式架构发展到服务网格后，真的是到达“最好的时代”了吗？软件架构的发展不太可能真的就此止步，你认为今天的云原生还有哪些主要矛盾，下一次软件架构的进化将会主要解决什么问题？]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>后微服务时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.微服务时代：SOA的革命者]]></title>
    <url>%2F2021%2F02%2F07%2F04-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[微服务最早被提出是作为SOA的一种轻量化的补救方案而被提出来的 微服务的概念微服务是一种通过多个小型服务的组合，来构建的单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的存储技术、运行在不同的进程之中。服务会采用轻量级的通讯机制和自动化的部署机制来实现通讯与运维。 九个核心业务与技术特征1. 围绕业务能力构建​ 有怎样的结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。 2.分散治理​ 微服务开发团队有着直接对服务运行质量负责的责任，也应该有不受外界干预，掌控服务各方面能力的权力，能选择与其他服务异构的技术来实现自己的服务。 3.通过服务来实现独立自治的组件​ 通过远程服务而非类库来提供功能，从而得到组件的隔离与自治能力。 4.产品化思维​ 避免把软件开发看作是要去完成某种功能，而是要把它当作是一种持续改进、提升的过程 5.数据去中心化​ 数据应该按领域来分散管理、更新、维护和存储。有时候一致性问题也可能是必须要付出的代价 6.轻量级通讯机制​ 如果服务需要上面的某一种功能或能力，那就应该在服务自己的Endpoint上解决，而不是在通讯管道上一揽子处理。RESTful风格的通讯方式，在微服务中就是比较适合的。 7.容错性设计​ 承认服务会出错，接收服务总会出错的现实。有了这个认识的前提，在设计微服务的时候就要求有自动的机制能对其依赖的服务进行快速的故障检测，持续出错的时候可以进行自动的隔离，在服务恢复好之后重新联通。 ​ 可靠的系统由不会出错的服务来组成，这就是微服务最大的价值所在 8.演进式设计​ 承认服务会被淘汰。一个良好的设计，应该是能够报废的，而不是指望着它长久。 9.基础设施自动化​ 服务一多，靠人工来运维这根本就是不可能的事情。所以会要依赖大量的基础设施来自动化完成 注意：以上9个是一个合理的微服务系统展示出来的内、外在表现，它能够指导你该如何应用微服务架构，而不能作为一种强加于系统中的束缚来看待。 这么自由的微服务理念咋不上天呢？以前提到的那个分布式问题就不存在了吗？还是得一个个的解决。于是各种技术框架纷纷出现。比如像Eureka、Consul、Nacos、Zookeeper、Etcd用来解决服务发现的技术、像Dubbo、Thrift、gRPC用来解决服务通讯的技术，真的是层出不穷。更甚至还有springcloud之类的全家桶，真的是给开发人员带来巨大的便利。 便对架构的要求也越来越高了。架构者如何在各种决策之间权衡能力也变得至关重要起来！ 那有没有一种即可以得到微服务自由的权力、还能专注于自己的业务，同时又不用费力去解决分布式带来的问题的解决方案呢？ 思考题你所负责的产品是不是基于微服务的？如果是，它符合微服务的9个特征吗？如果不是，你的产品适合微服务架构吗？你所在的企业、团队适合引入微服务吗？]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>微服务时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.SOA时代：成功理论与失败实践]]></title>
    <url>%2F2021%2F02%2F07%2F03-SOA%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[SOA架构是第一次被广泛使用过、通过分布式服务来构建信息系统的工程实践。它有完善的理论和工具，可以说，它解决了分布式系统中，几乎所有主要的技术问题 所以本节就系统的讨论一下SOA的设计思想与原则，找找他为什么没有成功的原因？ 三种服务拆分架构模式1.烟囱式架构​ 前提：假设完全不会跟其他相关的信息系统之间进行协作 ​ 互不交互的系统，各自使用独立的数据库、服务器，即可以完成拆分。 ​ 问题就在于：不交互的系统（组织）真的存在吗？ 2.微内核架构​ 把一些公共的主数据：人员、组织 、权限等公用的服务、数据、资源，都集中到一块儿，成为被所有业务系统共同依赖的核心系统。 ​ 这种模式很适合桌面应用程序的开发，如果想实现一个能够支持二次开发的软件系统，微内核架构也是一种良好的架构模式。 ​ 问题在于：各业务系统不直接交互，（比如：支付系统和用户系统是独立的，但彼此会有业务的调用），这时需要找到一个办法，即能拆分出独立的系统，也能让拆分后的子系统之间可以顺畅的互相调用 3.事件驱动架构为了能让子系统之间相互通讯，事件驱动架构就产生了 它是这样的一张种模式：在子系统之间建立一套事件队列管道，来自系统外部的消息将以事件的形式发送管道中，各子系统可以从管道中获取自己感兴趣、可以处理的事件消息，也可以为事件新增或修改其中的附加信息，甚至还可以自己发布一些新的事件到管道队列中去。 同时SOAP协议的诞生，事件驱动架构+SOAP协议==催生出=&gt;面向服务架构 SOA架构时代的探索探索1：更具体SOA本身还是属于一种抽象概念，而不是特指某一种具体的技术，但它比单体架构和烟囱式架构、微内核架构、事件驱动架构，都要更具可操作性，细节也充实了很多。所以，我们已经不能简单地把SOA看作是一种架构风格了，而是可以称之为一套软件架构的基础平台。 探索2：更系统SOA最根本的目标，就是希望能够总结出一套自上而下的软件研发方法论，让企业只需要跟着它的思路，就能够一揽子解决掉软件开发过程中的全套问题。比如，如何挖掘需求、如何将需求分解为业务能力、如何编排已有服务、如何开发测试部署新的功能，等等 过于严格的规范定义，给架构带来了过度的复杂性，这也是Web Service衰落最本质的原因。 思考题：你是否使用过SOA的方法论来开发软件系统呢？无论有还是没有，作为一个软件开发者，你是否愿意软件开发向着工业化方向发展，让软件类似工业产品制造那样，可以在规范、理论、工具、技术的支持下，以流水线的方式生产出来？ 思考：还真的是使用过某国产的ESB开发一个项目，但是受限于项目的规模只是做了课题性质的研究。虽然配套设施都很齐全，但是用起却不并不那么的流畅，再加上当时思路受制于服务编排的困扰。好不容易把思路给理顺了，同时又被微服务给冲击了。如果软件开发朝着工业化的方向发展，听起来像是很美妙的事情，那样的话，软件的质量应该会有很大的提高。但是自己会不会被淘汰，软件的定制化（灵活性）怎么体现，软件开发的工作会不会朝着工具化的思路去发展，到处去写补丁。还有一个问题，工业化产出的东西都是一样的，就算再扩展一点可以满足可以提供各种参数来配置。那这个基础工具该有多复杂呀。]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>SOA时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.单体系统时代]]></title>
    <url>%2F2021%2F02%2F07%2F02-%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[应用最广泛的架构风格 123456错误的认知： 架构无好坏，只能是根据场景来选择。典型的思维误区： 单体架构是落后的系统架构风格，最终会被微服务所替代。观念的转变： 不追求尽量不出错，而是应当正视出错是必然的，其实，这才是导致微服务开始逐步代替单体架构根本的驱动力。 1.大型单体系统也被称为巨石系统，把单体看作成是一种架构，确切的说是在微服务流行之后，才被追加的。 对于一个小型的系统来说，使用单体架构，易于开发，易于测试，易于部署，而且是进程内方法调用。 所以要想讨论单体系统的缺陷，必须要有一个前提：软件的性能需求超过了单机 所能处理的最大能力 题外话:当前市面上所有主流的IDE，也都是对单体架构支持最友好。 2.可拆分的单体系统 分层架构（纵向角度） 水平扩展（横向角度）多副本机制 3.非独立的单体​ 在拆分 方面，单体系统真正的缺陷，实际上并不在于如何 拆分 ，而是在于拆分 之后它会存在隔离与自治能力上的欠缺。 以微服务去代替单体系统的原因： * 无法做故障隔离 * 无法做到动态可维护 * 无法做到技术异构 * 不兼容phoenix特性（不死--&gt;能自治--&gt;可靠） 总结]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>单体系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.原始分布式时代]]></title>
    <url>%2F2021%2F02%2F07%2F01-%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[12UNIX设计哲学：保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性都来得更加重要。 在这个阶段提出的分布式架构的目标：使用多个独立的分布式服务来共同构建出一个更大型的系统。而这个目标，从历史的局限性就决定了他不可能 是一蹴而就的解决分布式系统中的难题。其中面临的最大问题就是：由于调用本地方法与调用远程方法的差别，如何像调用本地方法一样去调用远程方法 那“远程”二字代表了什么呢？ 首先不可能 用内联等传统编译原理中的优化算法，来提升运行速度 远程所带来的网络环境问题，包括： 远程服务在哪里–&gt;服务发现 有多少个–&gt;负载均衡 网络出现分区，超时出错怎么办–&gt;熔断，隔离降级 方法参与返回结果如何表示 –&gt;序列化协议 如何传输–&gt;传输协议 服务权限怎么管理–&gt;认证授权 如何 保证通信安全–&gt;网络安全层 如何 令调用不同机器服务返回相同的结果–&gt;分布式数据一致性 针对大部分问题，DCE从0开始从无到有回答了其中大部分的问题。 总结在这个阶段采用分布式架构，为了解决上述各种问题，所付出的代价远远超过了所取得的收益。那接下来该如何发展呢？ 尽快提升单机处理能力，以避免分布式的种种问题 寻找更完美的解决方案，来应对上述在构筑分布式系统的问题 1某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作只会自食其果 行文思路： 思考题1今天以微服务为代表的分布式系统，是如何看待简单的？ 思考： 微服务所谓的简单，不管是从开发工具、开发形式亦或是运维上来看，都是在趋于看上去的简单。把复杂 留给 自己，简单留给别人。易开发、易部署、易扩展、易运维等等的说法。都在宣誓着把简单作为主要的原则 ，但背后所面临着诸如本节课所有的讨论的问题，都是需要一一关注，一一解决的。所以我觉得这里的简单并不是真正的简单。]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>原始分布式时代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00.慢慢的我来了]]></title>
    <url>%2F2021%2F02%2F07%2F00-%E6%97%A5%E8%B5%B0%E4%B8%80%E5%8D%92%EF%BC%8C%E9%87%8D%E5%90%AF%E8%88%AA%2F</url>
    <content type="text"><![CDATA[关于认识渐渐地认识到了自身很多不的足，做什么事情都没有长性。去年做了一件关于坚持的事情，参加了百日跑的活动。连续两届200天，每天跑步5公里。]]></content>
      <categories>
        <category>重启</category>
      </categories>
      <tags>
        <tag>重启</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务处理一]]></title>
    <url>%2F2020%2F12%2F07%2Ftransaction1%2F</url>
    <content type="text"><![CDATA[事务的意义保证数据的正确性，不同的数据之间不会产生矛盾。也就是保证数据状态的一致性。 讨论的范围数据库事务状态的一致性123456789### 实现数据库事务状态一致性目标的前提* 原子性：在同一项业务处理中，事务保证对多个数据的修改要么都成功，要么都被撤销* 隔离性：在不同的业务处理过程中，事务保证各自读、写的数据互相独立，不会彼此影响* 持久性：事务应当保证所有被成功提交的数据修改，都能正确的持久化到数据库当中去，不会丢失数据。```原子性、隔离性、持久性是手段，一致性是目标 关于事务处理的不场景 单个服务使用单个数据源 单个服务使用多个数据源 多个服务使用单个数据源 多个服务使用多个数据源 单个服务使用单个数据源单个服务使用单个数据源，也就是本地事务场景，也可以叫作局部事务 本地事务说明指仅操作特定单一事务资源的、不需要“全局事务管理器”参与协调的事务。 本地事务，依赖于数据源本身的事务能力来工作，我们常见的在程序代码中的事务也最多就是对事务接口进行的一层标准化包装。事务的开启、终止、提交、回滚、嵌套、设置隔离级别乃至与应用代码贴近的传播方式都需要依赖底层数据库的支持。 ARIES理论Algorithms for Recovery and Isolation Exploiting Semantics ，基于语义的恢复与隔离算法 当前主流关系性数据在事务实现上都受到该理论的影响。 如何实现原子性和持久性实现原子性和持久性最大的困难是什么？ 写入磁盘这个操作不会是原子性，不仅存在写入、未写入，还存在“正在写”的中间状态。 这可咋办呀，怎么记录这个中间状态呢?日志？ Commit Logging把日志顺序追加写入文件方式，记录到磁盘中。见到代表事务提交成功的Commit Record之后 ，数据库才根据日志上的信息对真实数据进行修改，修改完之后，在日志中再加入一条End Record,表示数据库已完成持久化。这种事务实现方法就是Commit Logging Commit Logging，有几个切入的判断点： 日志成功写了Commit Record表示事务成功了 如果发生了崩溃，看到Commit Record不完整，那就需要将已经提交Commit Record的记录回滚掉。 Commit Logging的缺陷：Record提交之后进行的。才不管你的磁盘I/O是否有空闲。别管有什么理由不能在事务提交之前就开始修改磁盘上的数据。```1234567891011121314151617181920212223242526272829303132333435363738为了解决Commit Logging的缺陷，基于ARIES理论的&quot;Write Ahead Logging&quot;的日志改进方案就出现了##### Write Ahead Logging就是允许事务在提交之前，提前写入变动数据的意思。* FORCE:当事务提交后，要求变动数据必须同时完成写入则称为FORCE，如果不强制变动数据必须同时完成写入则称为NO-FORCE。现实中绝大多数数据库采用的都是NO-FORCE策略，只要有了日志，变动数据随时可以持久化，从优化磁盘I/O性能考虑，没有必要强制数据写入立即进行。* STEAL:在事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO-STEAL。从优化磁盘I/O性能考虑，允许数据提前写入，有利于利用空闲I/O资源，也有利于节省数据库缓存区的内存。Commit Logging允许NO-FORCE，但不允许STEAL。Write-Ahead Logging允许NO-FORCE，也允许STEAL。（性能最高，复杂性最高）实现方式：增加UnDo log日志，在变动数据写入磁盘之前，必须先记录UnDo log。这个log中明确记录修改了哪个位置的数据，从什么值改成了什么值。在需要回滚的时候，再根据这个日志来进行处理。##### 使用UnDo log，Write Ahead Logging在崩溃恢复时的三个步骤* 分析阶段：把没有End Record的事务组成一个待恢复集合* 重做阶段：从上述的集合中找到包含Commit Record的日志，把它们持久化到磁盘当中* 回滚阶段：经过上述两个步骤之后，把这个待恢复的集中的剩余事务全部圆润#### 如何实现隔离性隔离性保证了每个事务在各自读、写的数据都互相独立，彼此不受影响##### 数据库提供的三种锁* 写锁（排他锁） 只有持有写锁的事务才能对数据进行写入操作，数据被加上写锁时，其他事务不能写入数据，也不能加读锁。 写锁禁止其他事务施加读锁，而不是禁止事务读取数据* 读锁（共享锁） 多个事务可以对一行数据添加多个读锁，数据被加上读锁之后就不能再加写锁了，所有数据都不能对该数据进行写入，但仍然可以读取。* 范围锁 对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入```sql select * from books where price&lt;100 for update;##范围锁 四种隔离级别(从高到低)可串行化：强度最高的隔离性对事务所有读、写的数据全部加上读锁、写锁和范围锁 可重复读对事务所涉及到的数据加读锁、写锁，但不加范围锁 可重复读比可串行化弱化的地方在于幻读问题，它是指在事务执行的过程中，两个完全相同的范围查询得到了不同的结果集 特例：MySQL/InnoDB默认隔离级别是可重复读，但是在只读事务中避免了幻读问题。但是在读写事务中幻读问题依然存在 读已提交对事务所涉及到的数据加的写锁，会一直持续到事务结束。而加的读锁在查询完成之后就会马上释放。读已提交比可重复读弱化的地方在于不可重复读问题，它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。 在这个隔离级别下，两次重复执行的查询结果不一样的原因：读是在查询完成就直接释放了。并没有贯穿整个事务的生命周期，也没有办法禁止读取过的数据发生修改。 读未提交对事务涉及到数据只加写锁，一直持续到事务结束，但完全不加读锁。 读未提交比读已提交弱化的地方在于脏读问题，它是指在事务执行的过程中，一个事务读取到了另一个事务未提交的数据。 MVCC基础原理针对一个事务读、另一个事务写的场景而提出的无锁优化方案，是一种读取优化策略。注意只是针对读+写的事务场景（写+写，就令当别论了） 基本思路：对数据的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本同时存在。借用这种手段来达到读取时不加锁的目的。 从全局的角度来看，可以理解为给每一行数据都增加两个默认为空的字段：CREATE_VERSION和DELETE_VERSION。当有数据发生变化时，通过控制这两个字段来进行处理： 数据被插入时：CREATE_VERSION记录插入数据的事务ID，DELETE_VERSION为空。 数据被删除时：DELETE_VERSION记录删除数据的事务ID，CREATE_VERSION为空。 数据被修改时：将修改视为“删除旧数据，插入新数据”，即先将原有数据复制一份，原有数据的DELETE_VERSION记录修改数据的事务ID，CREATE_VERSION为空。复制出来的新数据的CREATE_VERSION记录修改数据的事务ID，DELETE_VERSION为空。 数据是记录好了，怎么用呢？ 会根据隔离级别来决定到底应该读取哪个版本的数据： 隔离级别是可重复读：总是读取CREATE_VERSION小于或等于当前事务ID的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务ID最大）的。 隔离级别是读已提交：总是取最新的版本即可，即最近被Commit的那个版本的数据记录。]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>事务处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务处理三]]></title>
    <url>%2F2020%2F12%2F07%2Ftransaction3%2F</url>
    <content type="text"><![CDATA[讨论范围分布式事务:多个服务同时访问多个数据源的事务处理机制 CAP（以下特性只能2选1） 一致性 可用性 分区容错性 CA，放弃P主流RDBMS集群通常是采用放弃分区容错性的工作模式，例如RAC集群采用共享磁盘的方式来避免网络分区的出现。每个节点都有SGA,UNDO LOG 和REDO LOG，但各节点共享同一份数据文件和控制文件 CP，放弃A先假设一旦出现网络分区，节点之间信息的同步可以无限的延长。从而采用2PC/3PC手段来，同时获取分区容错性和一致性。 AP，放弃C目前大多数分布式系统设计的主流选择，大多数的NoSQL库和支持分布式的缓存都是AP系统。 1234ACID CAP中讨论的一致性为强一致性，或线性一致性牺牲了C的AP,又想尽可能获取正确结果的行为，称为弱一致性，它的特例：最终一致性。 分布式事务实现方式最终一致性的实现方式：可靠消息队列、TCC、SAGA 可靠消息队列通过持续重试的机制，来保证可靠性。最大努力交付具体实现如下：系统把最有可能出错的业务，以本地事务的方式完成后，通过不断重试的方式，来促使同个事务的其他关联业务来完成。 缺点：没有任务隔离性，在电商场景中可能导致的问题就是超售 TCCTCC天生适合用于需要强隔离性的分布式事务中。他需要先把资源给冻住，然后执行后续的操作。 Try，尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好事务需要用到的所有业务资源（保障隔离性） Confirm，确认执行阶段，确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理 Cancel，取消执行阶段，释放Try阶段预留的业务资源 一般通过事务中间件（阿里seata)来完成 缺点： 业务侵入性较强 如果出现不合作（不可控）的第三方，往往在第一步Try就无法施行了。 SAGA引入事务补偿的机制来代替回滚的操作。 实现原理：将大事务拆解为N个小事务，并且为每个事务设计一个对应的补偿机制]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>事务处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务处理二]]></title>
    <url>%2F2020%2F12%2F07%2Ftransaction2%2F</url>
    <content type="text"><![CDATA[全局事务和共享事务全局事务和共享事务，是分布式事务的一种中间形式，起到的是承上启下的作用 全局事务12345678910回忆应用场景：单服务多数据源实现方式：2PC 3PC弱一致性、最终一致性，解决不了一致性问题共享事务：通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作问题既然已经出现，又该如何应对。各种解决方案又有什么样的处理方式呢？ 全局事务是一种适用于单个服务使用多个数据源场景的事务解决方案。 XA协议XA协议：定义了全局事务管理器和局部的资源管理器之间的通讯接口。常见的现象有：XADataSource/XAResource Java对于XA的实现：JTA，定义了事务管理器接口、满足XA规范的资源定义接口。 两段式提交、三段式提交也是基于XA协议的实现 两段式提交 准备阶段： 由协调者询问，事务的所有参与者是否准备好，如果准备好就回复Prepared,否则回复Non-Prepared 准备，把所有要提交的操作都写到重做日志记录中。只是不写Commit Record 提交阶段: 在收到所有参与者回复的Perpared消息后，将本地持久化事务状态改为Commit,然后向所有参与者发送Commit指令，所有参与者立即执行提交操作。 如果任意一个参与者回复了Non-Prepared消息，或任意一个参与者超时未回复，协调者都会将自己的事务状态持久化为“Abort”之后， 向所有参与者发送Abort指令，参与者立即执行回滚操作 123456两阶段提交保证成功的前提: 1. 必须假设网络在提交阶段这个短时间内是可靠的，即提交阶段不会丢失消息。 2. 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。 出现问题的场景： 当协调者将本地的状态持久为commit后，并提交了本地的事务，这个时候出现的网络中断，再也无法通过网络向参与者发送commit指令，就会导致协调者提交事务，参与者既没法提交也法回滚的情况。从而导致数据不一致。 两段式提交存在的问题 单点问题:协调者宕机 性能问题:整个过程要持续到所有参与者中最慢的那个处理完成之后 一致性风险：当网络稳定性和宕机恢复能力的假设不成立时，会出现严重的一致性问题。 三段式提交解决两段式提供存在的三个问题中的前两个，也就是单点问题和性能问题，但并没有解决一致性风险。 如何解决的呢 单点问题： CanCommit：准备阶段，询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。也意味着因某个参与者 提交时发生崩溃而导致全部回滚的风险相对变小了。如果有一个参与者无法完成，这个时候也没有涉及资源被锁住的风险。从这种角度上来看也提升了一些性能。但是也仅仅是在需要回滚的场景中，但是正常提交的情况，性能却多了一个限制 。 PreCommit：准备阶段， DoCommit：提交阶段 共享事务多个服务共同一个数据源，共享数据库连接，通过数据库中间件的形式，通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作]]></content>
      <categories>
        <category>架构探索</category>
      </categories>
      <tags>
        <tag>事务处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习之旅]]></title>
    <url>%2F2020%2F12%2F01%2Fmongodb%2Findex0%2F</url>
    <content type="text"><![CDATA[MongoDB 什么MongoDb一个以JSON为数据模型的文档数据库 为什么叫文档数据库文档来自于“JSON Document”,并非我们理解 的pdf word文档 主要用途应用数据库，类似于Oracle/MYSQL,海量数据处理，数据平台 主要特点建模为可选，JSON数据模型比较适合开发者，横向扩展可以支撑很大数据量和并发 ACID事务支持在4.0已经支持 MongoDB VS. 关系型数据库 MongoDB的特色及优势优势1：面向开发者的易用+高效数据库 无模式设计 123456多形性：同一个集合中可以包含不同字段的文档对象动态性：线上修改数据模式，修改是应用与数据库均无须下线数据治理 ：支持使用JSON Schema来规范数据模式，在保证模式灵活动态的前提下，提供数据治理 能力JSON模型之快速特性：```技术优势 数据库引擎只需要在一个存储区读写 反范式、无关联的组织 极大优化查询速度 程序 API自然，开发快速 优势2：原生的高可用和横向扩展能力（分布式方面的优势） 默认3个节点的复制部署（最少2最多50个）奇数 Application –&gt;Driver–&gt;Primary/Secondary/Secondary(Replication) 横向能力：需要的时候无缝扩展/应用全透明/多种数据分布策略/轻松支持TB/PB数量级 123456789101112131415161718192021222324252627282930313233343536373839404142show dbsshow collectionsuse xxdb.xx.findOne()db.fruit.insertOne(&#123;name:"orangle"&#125;)db.fruit.insertMany([&#123;name:"orangle"&#125;,&#123;name:"pear"&#125;,&#123;name:"banana"&#125;])db.fruit.find()db.fruit.find(&#123;"name":"apple"&#125;)db.fruit.find(&#123;$and:[&#123;name:"apple"&#125;,&#123;name:"pear"&#125;]&#125;)db.fruit.find(&#123;$or:[&#123;name:"apple"&#125;,&#123;name:"pear"&#125;]&#125;)db.fruit.find(&#123;name:/^p/&#125;)//以字母p开头的/** &#123;a:1&#125;===&gt;a=1 &#123;a:&#123;$ne:1&#125;&#125;===&gt; a&lt;&gt;1 &#123;a:&#123;$gt:1&#125;&#125;===&gt; a&gt;1 &#123;a:&#123;$gte:1&#125;&#125;===&gt; a&gt;=1 &#123;a:&#123;$lt:1&#125;&#125;===&gt; a&lt;1 &#123;a:&#123;$lte:1&#125;&#125;===&gt; a&lt;=1 更复杂的条件 &#123;a:1,b:1&#125;或者&#123;$and:[&#123;a,1&#125;,&#123;b,1&#125;]&#125;===&gt; a=1 and b=1 &#123;$or:[&#123;a,1&#125;,&#123;b,1&#125;]&#125;===&gt; a=1 or b=1 &#123;a:&#123;$exists:false&#125;&#125;===&gt; a is NULL &#123;a:&#123;$in:[1,2,3]&#125;&#125;===&gt; a IN(1,2,3) $lt $lte $gt $gte */ MongoDB分片集群架构三种常见部署架构 单机版（20%）：开发测试，不推荐线上环境使用复制集（70%）：高可用，一个二从或更多从节点分片集群（10%）：横向扩展，最小分片集群9~10个实例，适用大型应用场景]]></content>
      <categories>
        <category>NoSQL数据</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储系统实战-2]]></title>
    <url>%2F2020%2F10%2F27%2Fmemory-system-02%2F</url>
    <content type="text"><![CDATA[基于ES的商品搜索系统倒排索引机制]]></content>
      <categories>
        <category>专栏学习</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>存储系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储系统实战-1]]></title>
    <url>%2F2020%2F10%2F23%2Fmemory-system-01%2F</url>
    <content type="text"><![CDATA[购物车如何设计购物车存储时需要考虑清楚的问题 1.用户没登录，在浏览器中加购，关闭浏览器再打开，刚才回购的商品还在吗？(存在) 2.用户没登录，在浏览器中回购，然后登录，刚才回购的商品还在不在？(存在) 3.关闭浏览器再打开，上一步回购的商品还在不在？(不存在) 4.再打开手机，用相同的用户登录 ，第二步回购的商品还在不在？(存在) 暂存购物车、用户购物车 购物车设计原则 如果未登录，需要临时暂存购物车的商品； 用户登录时，把暂存购物车的商品合并到用户购物车中，并且清除暂存购物车； 用户登陆后，购物车中的商品，需要在浏览器、手机 APP 和微信等等这些终端中都保持同步。 暂存购物车设计一般的设计都会将这批数据存储在客户端，采用Session、Cookie、LocalStorge,APP的本地存储原理也是类似 Session的缺陷：保留时间短 Cookie：每次交互都需要把数据给带上，存储上限4K LocalStorage:只能由客户端来访问, 用户购物车设计使用关系型数据库来存储购物车数据，如果追求性能或者高开发，也可以选择Redis 账户系统的设计对不上账，最本质的原因就是，冗余数据的一致性问题 账户流水：每一笔交易记录，只能新增 如何保证账户系统中流水和余额的一致 使用数据库事务来保证数据一致性 原子性 一致性 隔离性 持久性 事务隔离级别 脏读：每个进行中事务的中间状态，对其他事务都是可见的 不可重复读：在同一个事务内两次读取同一条数据，读到的结果可能会不一样 如何解决跨系统、跨数据库的数据一致性问题？我们在使用分布式事务时，更多的情况都是使用分布式事务的理论来指导设计和开发。 分布式事务的实现原理 2PC 2PC引入了一个事务协调者的角色，来协调多个系统，协调者对客户端提供一个完整的服务，在这个服务内部，协调者再分别调用不同系统间的相应服务 二阶段指的是准备阶段和提交阶段。 在准备阶段，协调者对各系统发送【准备】指令，各系统在接收准备命令之后，开始执行准备操作。准备操作包括，除提交数据库事务之外的所有工作。等各个系统都准备完成后，就进入到了提交阶段。 在提交阶段，协调者再给各系统发送【提交】指令，系统在接收到指令后，都提交自己的数据库事务，然后返回给协调者提交成功的响应。 协调在接收到所提交成功的响应后，再给客户端返回成功的响应，这样整个分布式事务就完成了。 以上都不是重点！！！！ 异常了怎么处理才是重点： 在准备阶段：如果任何一步出现错误或者超时，协调者会马上给各系统发送回滚的请求 提交阶段：分布式事务只能成功不能失败！如果是超时那就一直重试，直到提交成功为止。 2PC适用于对数据一致性要求比较高的场景。要求强一致、并发量不大的情况下 缺点：整个事务的执行过程需要阻塞服务端的线程和数据库的会话，所以，2PC 在并发场景下的性能不会很高。并且，协调者是一个单点，一旦过程中协调者宕机，就会导致订单库或者促销库的事务会话一直卡在等待提交阶段，直到事务超时自动回滚。 本地消息表 本地消息表适合解决分布式最终一致性的问题 实现思路：某一个系统在接收到请求后，正常的使用本地的数据库事务去更新数据库，同时在执行这个事务的过程中，在本地记录一条消息。然后再用一个异步的服务去读取刚刚记录的本地消息，调用自己的服务，这样的话如果是失败了也可以通过重试来解决。最终保证各系统的数据都是一致的。 本地消息表实现手段：消息队列、数据库、本地磁盘文件 本地消息表缺点：必须要有一个前提条件，那就是异步执行的那部分操作，不能有依赖的资源。]]></content>
      <categories>
        <category>专栏学习</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>存储系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储系统实战-0]]></title>
    <url>%2F2020%2F10%2F22%2Fmemory-system-00%2F</url>
    <content type="text"><![CDATA[基础的认识凡是那些特别难解决的、让你付出巨大代价的，或者损失惨重的技术问题，几乎都可以归结为存储系统的问题 存储是系统中最核心、最重要、最关键的组成部分，没有之一 MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，这也是需要学习和掌握的 如何保证数据准确无误合格的订单系统，最基本的要求是数据不能出错 如何避免重复下单 让订单服务具备幂等性 任意多次执行所产生的影响均与一次执行的影响相同 利用数据库主键的唯一性约束来解决创建订单服务的幂等性问题（自定义一个订单号生成的服务） 如何解决ABA问题对数据的更新也要注意ABA问题 什么是ABA问题 一个简单的例子，假如有两次请求，第一次要求把数据修改为666，当数据库修改成功，在返回响应的时候失败了，而此时第二个请求到了，要把数据修改为888，并且响应成功了。由于第一次申请没有收到正确的响应，所以进行了重试，这时数据又修改成了666。 怎么解决呢？ 给数据库表增加一列version,也就是版本号的意思，每次查询version都随着数据返回，再更新的时候把version作为更新请求的参数，发送给更新服务 更新服务在接收到请求后，对比当前数据的version，是否与请求中的一致，如果不一致就拒绝更新。如果一致，就更新数据的同时把version+1。当前这个更新的过程必须在同一事务里面 商品详情页如何设计商品都包括哪些信息 基本信息 商品参数 商品介绍 图片视频 促销信息 推荐商品 评价信息 评论信息 配送信息 店铺信息 商品基本信息如何存储 商品基本信息的主副标题、价格、颜色等基本、主要属性，都是固定的。数据量不大，建议在数据库中建一张表来保存商品基本信息。然后在数据库前面加一道缓存，基于内存的KV存储。 前置缓存缓存商品数据，读取请求流程： 2.1. 先去缓存查找，如果找到就直接返回数据 2.2. 如果没有找到就去数据库查询，把返回结果返回，并缓存一份到缓存 更新时，在更新数据库的同时也要把缓存给删除，来保证数据一致性(Cache Aside缓存更新策略) 设计商品信息表时，一定要记得保留商品数据的每一个历史版本 缓存更新策略 Cache Aside Read/Write Through Write Behind 商品参数如何存储使用MongoDB保存商品参数，和商品的基本属性一样，都是结构化数据，不同类型的商品，它的参数也完全不一样。 MongoDBMongoDB是一个面向文档存储的NoSQL数据库，在MongoDB中，表、行、列对应概念：Collection、document、field。表结构是不需要事先定义，MongoDB没有表结构。支持把任意数据放在同一张表中。 MongoDB中的每一行数据，在存储层就是简单地转化成BSON格式。这是一种更紧凑的JSON，MongoDB 不支持 SQL，多表联查和复杂事务比较孱弱，不太适合存储一般的数据。对于商品参数信息，数据量大、数据结构不统一，这些 MongoDB 都可以很好的满足。我们也不需要事务和多表联查，MongoDB 简直就是为了保存商品参数量身定制的一样。 图片和视频如何存储保存在对象存储中 对象存储对象存储可以简单理解为一个无限容量的大文件 KV 存储，它的存储单位是对象，其实就是文件，可以是一张图片，一个视频，也可以是其他任何文件。每个对象都有一个唯一的 key，利用这个 key 就可以随时访问对应的对象。基本的功能就是写入、访问和删除对象。 商品介绍如何存储商品介绍的文本，一般都是随着商详页一起静态化，保存在 HTML 文件中 Tomcat 能能抗的并发量和 Nginx 完全不是一个数量级的 商详页静态化之后，不仅仅是可以节省服务器资源，还可以利用 CDN 加速，把商详页放到离用户最近的 CDN 服务器上，让商详页访问更快。 商品系统的存储需要提供商品的基本信息、商品参数、图片和视频以及商品介绍等等这些数据。商品的基本信息和商品参数分别保存在 MySQL 和 MongoDB 中，用 Redis 作为前置缓存，图片和视频存放在对象存储中，商品介绍随着商详页一起静态化到商详静态页中。]]></content>
      <categories>
        <category>专栏学习</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>存储系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构师训练营课堂笔记01周]]></title>
    <url>%2F2020%2F09%2F28%2FSATR-01%2F</url>
    <content type="text"><![CDATA[写在前面的话训练营已经结束一周了，虽然也做了课程总结以及整个课程的思维导图，脑子里也有了一些东西，但感觉还不是很清晰，所以我想再学习梳理一下。既然有这样的决心，那也一定要相应的计划。说到计划，又开始有点犯愁了，我怕我完不成呀，真的是有点犹豫。因为我还有别的课程要去学。好吧，在这儿经过一番挣扎之后，我还觉得好好计划一下这15周课的总结了。 9.28-29，第一周 9.30-10.1，第二周 10.2-10.3，第三周 10.4-10.5，第四周 10.6-10.7，第五周 10.8-10.9，第六周 10.10-10.11，第七周 10.12-10.13，第八周 10.14-10.15，第九周 10.16-10.17，第十周 10.18-10.19，第十一周 10.20-10.21，第十二周 10.22-10.23，第十三周 10.24-10.25，第十四周 10.26-10.27，第十五周 第一周本节重点 课程学什么 课程是怎么设计的 如何学习这门课程 通过课程可以收获到什么 希望训练营能带来一些收获：关于架构的思维方式，解决问题的一些方式，知识体系能够串起来能够领悟它，所以悟性很重要，明白为什么要这样。问题是什么，比如何做对架构而言都更重要一点 训练营不讲技术的应用，技术的应用不应该是架构所关注的点，用什么样的思维方式去面对问题，能够领悟到问题的本质是什么。 训练营想训练的是面对问题，思考问题的一种方式，解决问题的思路以及思路背后的关系，然后把这些再统统的整合在一起 悟性，悟性、悟性。 ppt是知识的架子。悟到是一层窗户纸 架构方法（架构师如何做架构）架构师输出的是什么？ppt? 如何成为架构师做架构是需要，架构方案、架构设计大家按这个设计进行分工开发 做架构的途径：1、要有任命（跳槽、内部晋升） 架构师面试 大厂offer该如何获取]]></content>
      <categories>
        <category>架构师训练营</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习计划]]></title>
    <url>%2F2020%2F09%2F28%2Fplan%2F</url>
    <content type="text"><![CDATA[到底应该先学哪一个呢？幸福来的太突然每天三篇的话，最多也就一个月能完成一个专栏。是不是也挺实际的呀。哈哈 左耳听风 DDD实战课（一定要把这个给啃下来） 许式伟架构课 消息队列高手课 Java性能调优实战 架构实战案例解析 Java业务开发觉错误100例：这个特配合代码来，没有那么多实践经验的话，也学不太深入，最多也只是走马观花，有个大概的印象，目前不太适合速读 JVM实战高手 MySQL实战优化高手 趣谈网络协议 重学前端 设计模式之美 Spring Cloud 微服务核心技术与实战]]></content>
      <categories>
        <category>专栏学习</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F09%2F15%2Freadingmethod%2F</url>
    <content type="text"><![CDATA[7S阅读法S1 提问，阅读一篇文章或一本书之前自问四个问题 我为什么想要读它 它对我来说有多重要 我要获得哪些信息 我打算把阅读获得的知识有在哪些方面 S2 速览​ 通过快速扫视全文，发现关键词和关键句子，在大脑中进行整合，简单理解作者传达的信息。 S1和S2就是快速阅读法，适用于休闲读书或深度阅读之前的准备 S3 融合，用摘录法记录关键词和标记不易理解的段落S4 重构，用自己的语言，重述内容S5 回忆，通过提问回忆习得的知识1. 作者是在文中讲了什么 2. 作者是如何讲述认证的 3. 内容和我有什么关系 4. 读完后对我来说有什么用 S3、S4、S5是深度阅读阶段，回忆与重构正是我所用的阅读笔记的做法 S6 延伸，寻找相关材料，扩展知识的深度和广度S7 交流，包括书面、口头、行动等沟通形式1. 提出疑问，解决作者未能回答的问题 2. 结合自身情况，把知识变成行动指南 3. 分享观点，在与他人的碰撞中得到新思路 读书若是缺少思考和行动，还真不如闭目养神]]></content>
  </entry>
  <entry>
    <title><![CDATA[第二周作业]]></title>
    <url>%2F2020%2F06%2F16%2Farchitect02%2F</url>
    <content type="text"><![CDATA[作业一 请描述什么是依赖倒置原则，为什么有时候依赖倒置原则又被称为好莱坞原则？ 在理解什么依赖倒置原则之前，先思考一个问题，诸如Tomcat/Jetty等容器，是如何做到不依赖其代码却能复用它的功能呢？依赖倒置原则规定如下： 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖具体实现，具体实现应该依赖于抽象 来细细的品读一下这两条规则： 如果要是高层模块依赖了低层模块会出现什么情况呢？维护起来困难，低层只要发生变化高层势必跟着变；复用困难，这里的复用主要是指对高层模块的应用，也就是业务层面的应用。怎么解决这个问题呢？最直观的一种就是再提出一抽象层出来，双方都依赖于抽象的接口，大家只需实现接口和使用接口即可。还是先前的那个问题，Tomcat这些容器是如何做到它的功能被利用的呢，也就是说web应用在部署到tomcat之后怎么能保证，同样的程序部署到jetty中也同样能运行呢？道理其实很简单，这些web容器都实现了J2EE的规范，web应用都实现了j2EE的Servlet接口。类似的还有JDBC,程序访问数据库都不依赖于数据库驱动包，而是直接调用JDBC提供好的接口，这些接口呢被各种驱动所实现。MVC，ORM框架从这个角度上来看也都是一样的套路。 在咱们的日常开发中也常常需要依赖抽象接口，而不是具体的实现。比如Web 开发中，Service 层依赖 DAO 层，并不是直接依赖 DAO 的具体实现，而是依赖 DAO 提供的抽象接口。那么这种依赖是否是依赖倒置呢？其实并不是，依赖倒置原则中，除了具体实现要依赖抽象，最重要的是，抽象是属于谁的抽象。 要理解依赖倒置原则的关键是要理清接口所有权的问题，即这些接口是被谁定义的，又被谁实现的？接口被高层定义，高层模块拥有接口，低层模块实现接口。而不是高层模块依赖底层模块的接口，而是低层模块依赖高层的模块的接口，从而实现依赖关系的倒置。至于倒置，只是一个叫法。 好莱坞原则：Don’t call me，I will call you。对应到软件里面就是，应用程序不需要调用 Tomcat 或者 Spring 这样的框架，而是框架调用应用程序。而实现这一特性的前提就是应用程序必须实现框架的接口规范，比如实现 Servlet 接口。 作业二 请描述一个你熟悉的框架，是如何实现依赖倒置原则的。 分析shiro安全框架如何实现依赖倒置原则：我觉得最契合依赖倒置原则的应该是Realm这一块。首先来发解一下Realm。Realm,就是域,shiro可以从Realm获取安全数据（如用户、角色、权限）,就是说SecurityManager要验证用户身份,那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。所以可以把Realm看成是一个安全数据源。简单了解了一下Realm,都知道在我们的应用是可以定义多个Realm的，在运行期securityManager会按照Realm的顺序，进行身份认证。对于依赖倒置的实现，我的理解是类似于Tomcat，shiro实现了Realm的规范，在应用中自定义的Realm只需实现Realm的接口，在运行期架构会自行调用自定义的Realm。这也就印证了，如何不依赖代码却可以复用它的功能。 作业三 请用接口隔离原则优化 Cache 类的设计，画出优化后的类图。 cache 实现类中有四个方法，其中 put get delete 方法是需要暴露给应用程序的，rebuild 方法是需要暴露给系统进行远程调用的。如果将 rebuild 暴露给应用程序，应用程序可能会错误调用 rebuild 方法，导致 cache 服务失效。按照接口隔离原则：不应该强迫客户程序依赖它们不需要的方法。也就是说，应该使 cache 类实现两个接口，一个接口包含 get put delete 暴露给应用程序，一个接口包含 rebuild 暴露给系统远程调用。从而实现接口隔离，使应用程序看不到 rebuild 方法。]]></content>
      <categories>
        <category>架构师训练营</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的未来在哪儿]]></title>
    <url>%2F2019%2F12%2F17%2FARTS-week21%2F</url>
    <content type="text"><![CDATA[今天是普通的一天，我早早的起来为亲爱的老婆大人买了份早餐（两根油条，一碗豆腐脑），本来还想给她买份小笼包的，但是一想到小笼包已经八块钱一笼了还是放弃吧，哦咸菜不要钱，那就多夹两筷子吧，反正也不要钱。六点五十的时候看到老板在公司运营群里面发图片，这个点他已经在公司旁边的包子店吃三块钱一个的包子了，老板又来公司这边了，那就不能去公司太晚吧。所以就跟老婆大人请了假说，不能去送闺女大人上班了，只能辛苦她去送了（其实一直都她自己送的，只是最近我会跟着一块儿去）。看到她同意了，我就赶紧背上昨天刚收到的拼多多上拼到的30多块钱的双肩包，来上班了。 97年天材架构师可能是早上醒的有点早，所以地铁上一篇文章都没有看完就开始眼睛涩了，想睡觉。好吧，既然不想学习了，那就刷一会儿网页吧。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY06]]></title>
    <url>%2F2019%2F11%2F12%2FARTS-week20%2F</url>
    <content type="text"><![CDATA[DAY06 rated a. 额定的 activity n. 活力，功率 odometer n. 里程表，计程仪 phoenix n. 凤凰，绝世珍品 obtain v. 获得，得到 easel n. 框，(画)架 latter a. 后面的，最近的 decrease v. 减少，降低，缩短 mainframe n. 主机，大型机 debugger n. 调试程序 diacritical a. 区分的，辩别的 confidential a. 机密的 trace v. 跟踪，追踪 division n. 除，除法，(程序)部分 regular a. 正则的，正规的 implicit a. 隐式的 mention vt. &amp; n. 叙述，说到 near ad. &amp; prep. 领近，接近 fifth n. &amp; a. 第五，五分之一 seven n. &amp; a. 七(个) whereas conj. 面，其实，既然 review v. &amp; n. (再)检查 whatever pron. &amp; a. 无论什么 transform v. &amp; n. 变换，变换式 align v. &amp; n. 定位，对准 yellow a. &amp; n. 黄色(的) assist v. &amp; n. 加速，帮助 finish v. &amp; n. 完成，结束 micro a. &amp; n. 微的，百万分之一 beyond prep. 超过，那边 against prep. 反对，阻止 upon prep. 依据，遵照 service n. &amp; vt. 服务，业务 little a. 小的，少量的 exhaust v. 取尽，用完 choice n. 选择，精品 sounding a. 发声的 develop v. 发展，研制，显影 holding n. 保持，固定，存储 alpha n. 希腊字母α，未知数 constant n. 常数 warranty n. 保证(书)，授权 stay v. 停止，停留 industry n. 工业 trigger n. &amp; v. 触发器；触发 lesson n. 功课，教训 handling n. 处理，操纵 treat v. 处理，加工 busy a. 忙碌的，占线的 usage n. 应用，使用，用法 difficult a. 困难的，不容易的 failure n. 失效，故障，失败 communication n. 通信 building n. 建造，建筑，房屋 ally v. 联合，与…关联 exclamation n. 惊叹(号) turning a. 转弯的，旋转的 whole a. 全部的，整个的 parent n. 双亲，父代 connection n. 连接(法) connectivity n. 连通性，联络性 translation n. 翻译，变换，平移 dynamic a. 动态的，动力的 foreground n. 前台 preserve vt. 保存，维持 vice n. 缺点，毛病，错误 necessarily ad. 必定，当然 circle n. 圆，圈，循环，周期 differ vi. 不同，不一致 stationary a. 静止的，平稳的 extract vt. 抽取，摘录，开方 unrecognized a. 未被认出的 thereafter ad. 此后，据此 inverse a. 反向的，逆的 spell v. 拼写 limiting n. (电路参数)限制处理 restructure vt. 调整，重新组织 delimit vt. 定界，定义 pay v. 付款，支付 separately ad. 分别地 classify vt. 分类，分级 interfere vi. 干涉，干扰，冲突 mind n. 愿望，想法，智力 individually ad. 个别地，单独地 vertical a. 垂直的，立(式)的 undesirable a. 不合乎需要的 lot n. 一块(批，组，套) piece n. 一块，部分，段 unavailable a. 不能利用的 unlike a. 不象的，不同的 sit v. 位于，安装 insufficient a. 不足的，不适当的 map n. &amp; vt. 图；映射，变址 figure n. 数字；图，图形，形状 prepare v. 准备 consider v. 考虑，认为，设想 detect vt. 检测 convenience n. 方便，便利 method n. 方法，方案 mean n. &amp; vt. 平均；意味着 salary n. &amp; vt. 薪水；发工资 pacific a. 平稳的，太平(洋)的 strong a. 强的 emphasize v. 强调，着重，增强 department n. 部门，门类，系 forced a. 强制的，压力的 ansi n. 美国国家标准协会 permanent a. 永久的 remark n. 评注，备注 away ad. 离开，(去)掉 concatenate vt. 连接，串联，并置 lightning n. 闪电 additionally ad. 另外，又 emulate v. 仿真，模仿；赶上或超过 tape n. 磁带，纸带 accidentally ad. 偶然地 concept n. 概念 optimize v. 优选，优化 counter n. 计数器，计算器 expect vt. 期望，期待，盼望 subsequently ad. 其后，其次，按着 registration n. 登记，挂号，读数 city n. 城市，市区 designate vt. 任命，标志 visible a. 可见的，明显的 consult v. 咨询，顾问 completely ad. 十分，完全，彻底 virtually ad. 实际上 substantially ad. 实质上，本质上 specialize v. (使)专门化 fail n. 故障，失效 primarily ad. 首先，起初，原来 sequentially ad. 顺序地 client n. 顾客，买主 runtime n. 运行时间 fix v. 固定，定影 author n. 程序设计者，作者 programmer n. 程序设计人员 commercial a. 商业的，经济的 particularly ad. 特别，格外，尤其 low a. 低的，浅的，弱的 sheet n. (图)表，纸，片 employee n. 雇员 legal a. 合法的，法律的 qualified a. 合格的，受限制的 context n. 上下文，来龙去脉 involved a. 有关的 conditional a. 有条件的 halfway a. 中途的，不彻底的 oriented a. 有向的，定向的 pair n. (一)对，一双 week n. (一)星期，(一)周 suppressed vt. 抑制，取消 subroutine n. 子程序 bracketed a. 加括号的 manually ad. 用手，手动地 preset vt. 预置 autoindex n. 自动变址(数) restrict vt. 约束，限制 performance n. 性能，实绩 showing n. 显示，表现 ever ad. 在任何时候，曾经 distribution n. 分布，分配 denote vt. 指示，意味着，代表 cash n. 现金 repeatedly ad. 重复地 replicate vt. 重复，复制 mega n. 兆，百万 conform vi. 遵从，符合 rebuild v. 重建，修复，改造 certainty n. 必然，确实 controller n. 控制器 pseudo a. 假的，伪的，冒充的 manage v. 管理，经营，使用 administrator n. 管理人，行政人员 ensemble n. 总体，集合体 bus n. 总线，信息通路 allowable a. 容许的，承认的 limitations n. 限制，边界 restriction n. 限制，约束，节流 height n. 高度 remainder n. 余数，余项，剩余 traverse v. 横渡，横过，横断 organization n. 结构，机构，公司 resulting a. 结果的，合成的 solution n. 解，解法，解答 external a. 外部的 adequate a. 足够的，充分的 interpretability n. 配合动作性 vary v. 变化，变换 gap n. 间隙，间隔，缝隙 indexing n. 变址，标引，加下标 board n. 板，插件板 package n. 插件，(软件)包 insertion n. 插入，嵌入，插页 intervene vi插入，干涉 conflict v. 冲突，碰头 really a. 真正地，确实地 overflow v. 溢出，上溢 charge n. 电荷，充电，负荷 phone n. 电话，电话机，音素 virtual a. 虚(拟)的，虚拟 compose v. 组成，构成，构图 snapshot n. 抽点打印 sensitivity n. 灵敏度 familiar a. 熟悉的，惯用的 mach n. 马赫(速度单位) incorrect a. 错误的，不正确的 cut v. 割，切 lowest a. 最低的，最小的 simple a. 简单的 subsequent a. 后来的，其次的 capitalized a. 大写的 compact a. 紧致的，压缩的 plain n. 明码 noted a. 著名的 desirable a. 所希望的，称心的 substitution n. 代替，替换，置换 consume v. 消耗，使用 forget v. 忘记 keyed a. 键控的 overstrike n. 过打印 tornado n. 旋风，龙卷风 quotation n. 引证，引用(句) ones n. 二进制反码 parse vt. (语法)分析 experience vt. &amp; n. 试验 manufacture vt. &amp; n. 制造(业)，工业 hundred n. &amp; a. (一)百，百个 thousand n. &amp; a. (一)千，无数的 twentieth n. &amp; a. 第二十(的) understanding n. &amp; a. 了解的，聪明的 hand n. &amp; a. 手，手工(动)的 restricting n. &amp; a. 限制(的) fancy n. &amp; a. 想象(的)，精制的 wide a. &amp; ad. 宽的，广阔的 fine a. &amp; ad. 微小的，细的 worry v. &amp; n. (使)烦恼 somewhat pron. &amp; ad. 稍微，有点 quiet a. &amp; n. 静态，静止的 purge v. &amp; n. 清除 mod a. &amp; n. 时髦的 numeral n. &amp; n. 数字的，数码 whichever a. &amp; pron. 无论哪个 purchase n. &amp; v. 购买 care n. &amp; v. 关心，注意 watch n. &amp; v. 监视，观测 endeavor n. &amp; v. 尽力，力图 mismatch n. &amp; vt. 失配，不匹配 printout n. 印出 ellipsis n. 省略符号，省略(法) ship n. 舰，船 british a. &amp; n. 英国的；英国人 parallel a. 并行 custom a. &amp; n. 常规的，惯例；用户 congratulation n. 祝贺 protection n. 保护 glass n. 玻璃 pattern n. 模式 insure v. 保证，保障 stopping n. 停止，制动(状态) factory n. 工厂，制造厂 implement n. &amp; vt. 工具；执行，实现 effort n. 工作，研究计划 worker n. 工作人员 ampersand n. &amp;号(and) deal v. 处理，分配，交易 power n. 功率，电源，幂 difficulty n. 困难，难点 lose n. 失去，损失 magic n. 魔术，幻术 proprietary a. 专有的 aware a. 知道的，察觉到的 numerous a. 为数众多的，无数的 vowel n. 元音，母音 closely a. 精密地，仔细地 accuracy n. 精确度，准确度 traditional a. 传统的，惯例的 synchronization n. 同步 fragment n. 片段，段，分段 primary a. 原始的，主要的 safely ad. 安全地，确实地 habit n. 习惯 comprise vt. 包括，由…组成 landler n. 兰德勒舞曲 absence n. 缺少，没有 revolutionize vt. 变革，彻底改革 constantly ad. 不变地，经常地 seldom ad. 不常，很少，难得 unfortunately ad. 不幸，遗憾地 expunge vt. 擦除，删掉 security n. 安全性，保密性 touch v. &amp; n. 按，揿，触；触力 contrast n. 反差，对比，对比度 invent vt. 创造，想象 reflect v. 反射 undone a. 未完成的 unshift v. 未移动，不移档 complex a. &amp; n. 复杂的；复数 complexity n. 复杂性，复杂度 creation n. 创造，创作 unknown a. 未知的，无名的 greatly ad. 大大地，非常 cost n. 值，价值，成本 degrade v. 降低，减少，递降 suggestion n. 暗示，提醒 real n. 实数，实的，实型 experimentation n. 实验(工作，法) experiment n. 实验，试验(研究) substantial a. 实质的，真正的 solely ad. 独自，单独，只 announce vt. 发表，宣布 squeeze v. 挤压 distribute vt. 分布，配线，配给 negate vt. 否定，求反，”非” capture vt. 俘获，捕捉 father n. 父，上层(树节点的) reinstate vt. 复原，恢复 tutorial a. 指导的 nicety n. 细节，精细 roll n. &amp; v. 案卷；卷动，滚动 exponent n. 指数，阶，幂 exponential a. 指数的，幂的，阶的 prefer vt. 更喜欢，宁愿 complicated v. 使复杂化，使混乱 reactivate v. 使恢复活动 spread v. 展开，传播 synchronize v. 使同步 formation n. 构造，结构，形成 widely ad. 广泛，很远 comma n. 逗号”,”，逗点 very ad. 很，非常，最 unnecessary a. 不必要的，多余的 unchanged a. 不变的 cross n. 交叉，十字准线 yet ad. 还，仍然，至今 slowly ad. 缓慢地 inexperienced a. 不熟练的，外行的 noninteractive a. 不相关的，非交互的 unwanted a. 不需要的，多余的 unused a. 不用的，空着的 unmarked a. 没有标记的 nothing n. 没有任何东西 chart n. 图(表) dearly ad. 极，非常，昂贵地 extremely ad. 极端地，非常 hardly ad. 几乎不，未必 placement n. 布局 think v. 考虑，以为，判断 technical a. 技术的，专业的 idea n. 思想，观念 stamp n. 图章 indirectly ad. 间接地 equation n. 方程，方程式 smooth v. &amp; a. 平滑；平滑的 attached a. 附加的 average n. 平均，平均数 quietly ad. 静静地 discard v. 删除，废除，放弃 never ad. 决不，从来不 initiate vt. 开创，起始 powerful a. 强大的，大功率的 purpose n. &amp; vt. 目的，用途；打算 regard vt. 考虑，注意，关系 daily a. 每日的，日常的 possibly ad. 可能地，合理地 potentially ad. 可能地，大概地 moreover ad. 况且，并且，此外 american a. 美国的 guard v. &amp; n. 防护；防护装置 world n. 世界，全球 independent a. 独立的 independently a. 独立地 continuously ad. 连续不断地 shield v. 屏蔽，罩，防护 glance n. 闪烁 happening n. 事件，偶然发生的事 transaction n. 事项，事务，学报 emulation n. 仿真，仿效 strike v. 敲，击 dump v. (内存信息)转储 occasionally ad. 偶尔(地)，不时 tension n. 张力 probable a. 概率的，可能的 talent n. 才能，技能，人才 financial a. 财务的，金融的 meter n. 仪表，米 logged a. 记录的，浸透的 ware n. 仪器，商品 disregard vt. 轻视，把…忽略不计 waiting a. 等待的 preceding a. 先的，以前的 comparison n. 比较，对照 advanced a. 先进的，预先的 rate n. 比率，速率，费率 fly v. 飞，跳过 programmable a. 可编程的 definable a. 可定义的，可确定的 readable a. 可读的 recoverable a. 可恢复的，可回收的 possibility n. 可能性 finisher n. 成品机 applicable a. 可适用的，合适的 printable a. 可印刷的 executable a. 可执行的 essentially ad. 实质上，本来 confuse vt. 使混乱，干扰 familiarize vt. 使熟悉，使通俗化 employe vt. 使用，花费 suitable a. 适合的，相适宜的 generation n. (世)代，(发展)阶段 quality n. 质量，性质，属性 defective a. 故障的，有毛病的 interpretable a. 彼此协作的 interest n. 兴趣，注意，影响 fourscore n. 八十 teach v. 教，讲授 procedural a. 程序上的 phrase n. 短语，成语 specifically ad. 特别地，逐一地 penalty n. 惩罚，罚款，负担 violate vt. 违犯，妨碍，破坏 indefinitely ad. 无限地，无穷地 major a. 较大的，主要的 higher a. 较高的 wise a. 聪明的 becoming a. 合适的，相称的 equally ad. 相等地，相同地 enjoy vt. 享受，欣赏，喜爱 forth ad. 向前 disappear vi. 消失 crop v. 切，剪切 diagonally ad. 斜(对) labeled a. 有标号的 decision n. 判定，决定，决策 effective a. 有效的 significant a. 有效的，有意义的 avail v. &amp; n. 有益于；利益 hang v. 中止，暂停，挂起 craze n. &amp; v. 裂纹开裂 consequently ad. 因此，从而 introduce vt. 引进，引导 team n. 队，小组 visual a. 视觉的，直观的 acknowledgment n. 接收(收妥)，承认 efficiently ad. 有效地 predict vt. 预测，预言 anticipate vt. 预先考虑，抢…先 bypass n. 旁路 nature n. 自然，天然 natural a. 自然的 grant vt. 允许，授权 logarithm n. 对数 reappears vi. 再现，重现 reload vt. 再装入 occupy vt. 占有，充满 photograph n. 照片；v.照相 terminating n. 终止，终结，收信 resolve v. 分辨，解像 unsafe v. 恢复 separator n. 分隔符 hierarchical a. 分级的，分层的 assortment n. 种类，花色品种 growing n. 分类，分组，成群 discussion n. 讨论，商议，论述 alphabet n. 字母，字母表 scattered a. 分散的 eventually ad. 终于，最后 finally ad. 终于，最后 subgroup n. 分组，子群 superimpose vt. 重叠，叠加 reorganization vt. 重排，改组 rewrite vt. 重写，再生 university n. (综合性)大学 deter vt. 阻止，拦住，妨碍 pool n. &amp; v. 池，坑；共享 moment n. 矩，力矩，磁矩 shut v. 关闭 closed a. 关闭的，闭迹 respond v. 回答，响应 repeating n. 重复，循环 repetitive a. 重复的 reenter v. 重新进入 rearrange v. 重新整理，重新排序 rectangular a. 矩形的，成直角的 tag n. 特征，标记，标识符 suppose v. 假定，推测 supposed a. 假定的，推测的 manipulating v. 操纵，操作 operator n. 操作员，运算符 masking n. 掩蔽，屏蔽 price n. 价格 demonstrate v. 论证，证明，证实 importance n. 价值，重要 pipe n. 管，导管 overall a. 总共的，全部的 turnkey n. 总控钥匙 restricted a. 受限制的，受约束的 suspension n. 暂停，中止，挂起 seamless a. 无缝的 clipper n. 限幅器，钳位器 unsigned a. 无符号的 unformatted a. 无格式的 infinite a. 无限的，无穷的 useless a. 无用的 limiter n. 限制(幅)器 mountain n. 高山，山脉 redundant a. 冗余的 dependent a. 相关的 contiguous a. 相连的，邻接的 consistent a. 相容的，一致的 multiprocessing n. 多重处理，多道处理 architecture n. 结构，构造 structural a. 结构的，结构上的 outcome n. 结果，成果，输出 association n. 结合，协会，联想 opinion n. 意见，见解，判断 interpret v. 解释 explanatory a. 解释(性)的 assemble v. 汇编，装配 assembler n. 汇编程序 cad 计算机辅助设计 arithmetic n. 算术，运算 varying a. 变化的，可变的 representative a. 典型的，表示的 typical a. 典型的，标准的 sufficient a. 充足的，足够的 blast v. &amp; n. 清除；爆炸 clean a. 清洁的，干净的 caret n. 插入符号 socket n. 插座，插孔，插口 stated a. 规定的 protocol n. 规约，协议，规程 presence n. 存在，有 telephone n. 电话 social a. 社会的 equipment n. 设备，装备，仪器 lending n. &amp; a. 借给，出租；借出的 book n. 书，手册，源程序块 circumstances n. 情况，环境，细节 situation n. 情况，状况，势态 desk n. 书桌，控制台，面板 please v. 请 mixture n. 混合物 representation n. 表示 esoteric a. 深奥的，奥秘的 depth n. 深度，浓度(颜色的) final a. 最终的 physically a. 物理上，实际上 aid n. 帮助，辅助程序 successive a. 逐次的，相继的 succession n. 逐次性，连续性 unpack v. 拆开，卸，分开 chunk n. 厚块，大部分 alignment n. 序列，成直线 typewriter n. 打字机 big a. 大的，重要的 tone n. 音调，音色，色调 sensitive a. 敏感的，灵敏的 reduction n. 减化，还原，减少 indentation n. 缩进，缩排 terminology n. 术语 ascending a. 增长的，向上的 augment v. 增加，添加，扩充 increment n. 增量，加１，递增 gain n. 增益(系数) stream n. 流 obsolete a. 作废的，过时的 accommodate v. 调节，适应 motif n. 主题，要点，特色 subject n. 主题，源 job n. 作业 differentiate v. 区别，分辨 distinction n. 区别，相异，特性 distinguish v. 区别，辨识 locking n. 锁定，加锁 progress n. 进度，进展 fundamental a. 基本的，根本的 basis n. 基础，座 underlying a. 基础的，根本的 sound n. 声音，音响 vital a. 生动的，不可缺少的 national a. 国家的 sale n. 销售，销路 agree v. 符合，相同 iterative a. 迭代的 inclusive a. 包括的，内含的 charm n. 吸引力 hit v. 命中，瞬时干扰 course n. 过程，航向，课程 exceeded a. 过度的，非常的 numerical a. 数量的，数字的 digital a. 数字的 combo n. 二进位组合码 cord n. 绳子，电线]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY05]]></title>
    <url>%2F2019%2F11%2F11%2FARTS-week19%2F</url>
    <content type="text"><![CDATA[DAY04 series n. 序列，系列，串联 individual a. 个别的，单个的 explain v. 阐明，解释 paste n. 湖，胶，膏 welcome vt. &amp; n. 欢迎 six n. &amp; a. 六(个)(的) early a. &amp; ad. 早期，初期 wrap v. &amp; n. 包装，缠绕 blue a. &amp; n. 蓝(色)，青色 queue v. &amp; n. 排队，队列 interrupt v. &amp; n. 中断 respect n. &amp; vt. 遵守，关系 converted a. 转换的，变换的 common a. 公用的 hyphen n. 连字符，短线 serial a. 串行的，串联的 loading n. 装入，加载，存放 retain vt. 保持，维持 setup n. 安排，准备，配置 freeze v. 冻结，结冰 intend vt. 打算，设计 explanation n. 说明，注解，注释 certain a. 确实的，确定的 zap v. 迅速离去，击溃 archive vt. 归档 negative a. 负的，否定的 image n. 图像，影像，映像 platform n. 平台，台架 often ad. 经常，往往，屡次 signal n. &amp; v. 信号；发信号 cpu 控制处理部件 bit n. 比特；(二进制)位 fully ad. 十分，完全 deactivate vt. 释放，去活化 especially ad. 特别(是)，尤其 usually ad. 通常，平常，一般 recommend vt. 推荐，建议 maintain vt. 维护，保养，保留 important a. 严重的，显著的 central a. 中央的，中心的 addition n. 加法，增加 anytime ad. 在任何时候 analyst n. 分析员 false a. 假(布尔值)，错误 black a. &amp; n. 黑色的，黑色 gather n. 聚集，集合 cycle n. &amp; v. 周，周期；循环 relative a. 相对的 offer v. 提供，给予，呈现 ending n. 结束 rent v. &amp; n. 租用；裂缝 sentence n. 句(子) remember v. 存储，记忆，记住 proper a. 真的，固有的 design v. 设计 examine v. 检验，考试，审查 initial a. 最初的，初始的 corrupt v. &amp; a. 恶化；有毛病的 buy v. 买，购买，赢得 increase v. 增加，增大 host n. 主机 sample n. &amp; v. 样品，样本；抽样 pending a. 悬而未决的，未定的 divide v. 除 boot n. 引导，靴 hide v. 隐藏，隐蔽 half n. &amp; a. &amp; ad. 一半，半个 magenta n. &amp; a. 深红色(的) leading n. &amp; a. 引导(的) wrong a. &amp; ad. n. 错误(的) today n. &amp; ad. 今天 least a. &amp; ad. 最小(的) opposite a. &amp; n. &amp; ad. 相反的 white a. &amp; n. 白色(的) override v. &amp; n. 超越，克服 brown a. &amp; n. 褐色(的)，棕色 hex a. &amp; n. 六角形的 rest n. &amp; v. 剩余，休息 damage n. &amp; vt. 损伤，故障 instant a. 立刻的，直接的 reserved a. 保留的，预订的 technology n. 工艺，技术，制造学 handle n. 处理，句柄 apply v. 应用，适用于，作用 stand v. 处于(状态)，保持 payment n. 支付，付款 kilobyte n. 千字节(kb) parenthesis n. 括弧，圆括号 scan v. 扫描，扫视，搜索 locating n. 定位，查找 developer n. 开发者，显影剂 murder n. 弄坏，毁掉 flush v. 弄平，使齐平 unlock v. 开锁，打开 movement n. 传送，移动 consecutive a. 连续的，连贯的 collection n. 集合，聚集，画卷 front a. 前面的，正面的 addressing n. 寻址 prefix n. 前缀 carousel n. 圆盘传送带 safety n. 安全，保险 static a. 静态的，不变的 background n. 背景，底色，基础 product n. (乘)积，产品 assignment n. 赋值，分配 bad a. 坏的，不良的 declare v. 说明 adjust vt. 调整，调节，控制 recognize v. 识别 route n. 路线，路由 respectively ad. 分别地 unsuccessful a. 不成功的，失败的 received a. 被接收的，公认的 navigate v. 导航，驾驶 considered a. 考虑过的，被尊重的 due a. 到期的，应付(给)的 recently ad. 近来 room n. 房间，空间 descend v. 下降，落下 fact n. 事实 alter v. 改变，修改 track n. 磁道，轨道 precedence n. 优先权 skeleton n. 骨架，框架 log n. &amp; v. 记录，存入 star n. 星形，星号 hot a. 热的 replaceable a. 可替换的 accessible a. 可以使用的 involve vt. 涉及，卷入，占用 configure vt. 使成形 question n. 问题 green n. &amp; a. 绿色绿色的 entirely ad. 完全地，彻底地 helpful a. 有帮助的，有用的 middle a. 中间的 declared a. 承认的，申报的 compress vt. 压缩，精减 graphically ad. 用图表表示 auto a. 自动的 automatic a. 自动的 aligned a. 对准的，均衡的 anywhere ad. 在任何地方 terminal n. 终端，端子 door n. 舱门，入口，孔 expire v. 终止，期满 resolution n. 分辨率 local a. 局部的，本地的 semicolon n. 分号(；) reread vt. 重读 overwrite v. 重写 critical a. &amp; n. 临界的；临界值 manager n. 管理程序 capability n. 能力，效力，权力 affected a. 受了影响的 allowed a. 容许的 border n. 边界，框，界限 cache n. 高速缓存 bell n. 铃，钟 play v. 玩，奏，放音，放象 quickly a. 快，迅速地 fastback n. 快速返回 answer n. &amp; v. 响应，回答；答复 represent v. 表示，表现，代表 difference n. 差分，差 highest a. 最高的 project n. 项目，计划，设计 physical a. 物理的，实际的 matter n. 物质，内容，事情 hercules n. 大力神，大力士 reduce v. 减少，降低，简化 publisher n. 出版者，发行人 trim n. 区标，微调 substitute v. 代替，替换，代入 disabled a. 禁止的，报废的 recent a. 近来的 positive a. 正的，阳的，正片 upgrade v. 升级，提高质量 instance n. &amp; vt. 例子，情况；举例 happen vi. (偶然)发生，碰巧 elapsed vi. &amp; n. 经过 future n. &amp; a. 将来，未来的 midnight n. &amp; a. 午夜 though conj. 虽然，尽管 nor conj. 也不 mono a. &amp; n. 单音的 slide v. &amp; n. 滑动，滑动触头 abort v. &amp; n. 中断，故障 jump v. &amp; n. 转移 toward prep. 朝(着…方向) throughout prep. 贯穿，整，遍 via prep. 经过，经由 among prep. 在…之中，中间 neither a. &amp; pron. (两者)都不 layer n. &amp; v. 层，涂层 scatter v. 散射，分散，散布 attention n. 注意(信号) convention n. 常规，约定，协定 conventional a. 常规的，习惯的 tool n. 工具，刀 handler n. 处理程序 processor n. 处理机，处理程序 desktop a. 台式的 build v. 建造，建立，组合 windowing n. 开窗口 development n. 开发，研制，显影 exceed v. 超过，大于 understand v. 懂，明白(了)，理解 horizontal a. 水平的，横向的 alphabetically ad. 按字母表顺序 meet v. “与”，符合，满足 protect vt. 保护 reserve vt. 保留，预定，预约 clock n. 时钟，计时器，同步 manifest vt. 表明，显示，显现 safe a. 安全的，可靠的 disconnect vt. 拆接，断开，拆线 clockwise a. 顺时针的 eliminate vt. 除去，消除，切断 actual a. 实际的，现实的 declaration n. 说明，申报 probably ad. 多半，很可能 ring n. &amp; v. 环，圈；按铃 cover vt. 盖，罩，套 indicator n. 指示器，指示灯 apple n. 苹果 icon n. 图符，象征 consideration n. 考虑，研究，讨论 skill n. 技巧 picture n. 图象，画面 layout n. 布置，布局，安排 suggest vt. 建议，提议，暗示 convenient a. 方便的，便利的 instruct vt. 讲授，命令 appendix n. 附录 medium n. &amp; a. 媒体；中等的 truncate vt. 截尾，截断 inhibit vt. 禁止 nearly ad. 近乎，差不多，几乎 warn vt. 警告，警戒，预告 underline n. 下划线 register n. 寄存器 stuff n. &amp; vt. 材料；装入 exclude vt. 排除，除去 destroy vt. 破坏，毁坏，打破 calculation n. 计算，统计，估计 angle n. 角，角度 lexical a. 辞典的，词法的 decide v. (使)判定，判断 trouble n. 故障 processing n. (数据)处理，加工 customer n. 顾客，客户 port n. 端口，进出口 discuss vt. 讨论，论述 segment n. 段，片段，图块 filing n. (文件的)整理汇集 identically ad. 相等，恒等 market n. 市场，行情，销路 valuable a. 有价值的，贵重的 limited a. 有限的，(受)限制的 trying a. 费劲的，困难的 heap n. 堆阵 grey n. &amp; a. 灰色；灰色的 permanently ad. 永久地，持久地 accelerator n. 加速装置，加速剂 originally ad. 原来，最初 ability n. 性能，能力，效率 internally ad. 在内(部) derelict vt. 中途淘汰 redirect vt. 重定向 reside vi. 驻留 header n. 首部，标题，报头 extra a. 特别的，额外的 repeated a. 重复的 death n. 毁灭，消灭 observe v. 观察，探测 density n. 密度 management n. 管理 environmental a. 周围的，环境的 surrounding a. 周围的，环绕的 master a. 总要的，总的 recursive a. 递归的，循环的 trap n. &amp; vt. 陷阱；俘获 dimensional n. 尺寸的，…维的 logic n. 逻辑(线路) conjunction n. 逻辑乘，”与” identical a. 相等的，相同的 advice n. 意见，参考说明 meaning n. 意义，含义 fall n. 落下，降落 interval n. 间歇，区间 compatibility n. 兼容性，适应性 rule n. 规则，法则，尺 flag n. 标志(记)，特征(位) criterion n. 标准，判据，准则 office n. 办公室，局，站 express a. 快速的 volume n. 卷，册，体积，容量 soft a. 软的]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY04]]></title>
    <url>%2F2019%2F11%2F10%2FARTS-week18%2F</url>
    <content type="text"><![CDATA[DAY04 light n. &amp; a. 光(波，源)；轻的 zero n. 零，零位，零点 storage n. 存储，存储器 width n. 宽度 language n. 语言 startup n. 启动 much a. &amp; n. 很多，许多，大量 per prep. 每，按 over prep. 在…上方 mirror n. &amp; v. 镜，反射，反映 request n. &amp; vt. 请求 keypad n. 小键盘 keep v. 保持，保存 resident a. 驻留的 learning n. 学问，知识 talk v. 通话，谈话 summary n. 摘要，汇总，提要 well n. &amp; a. 井；好，良好 link n. &amp; v. 链接；连接，联络 according to a. 按照，根据 identify v. 识别，辨认 designated a. 指定的，特指的 pertain vi. 附属，属于，关于 expansion n. 展开，展开式 incompatible a. 不兼容的 blinking n. 闪烁 month n. 月份 precede v. 先于 readily ad. 容易地，不勉强 transportable a. 可移动的 appropriately ad. 适当地 routine n. 程序，例行程序 ready a. 就绪，准备好的 listing n. 列表，编目 newly ad. 新近，重新 year n. (一)年，年度，年龄 contact n. 接触，触点 session n. 对话，通话 own a. &amp; v. 自己的；拥有 redraw vt. 再拉 here ad. 在这里 manual a. 手工的，手动的 particular a. 特定的，特别的 rectangle n. 矩形 additive a. &amp; n. 相加的；附加物 similar a. 相似的 assembly n. 汇编，安装，装配 copyright n. 版权 description n. 描述 retrieve v. 检索 mistake n. 错误 produce v. 生产，制造 ram 随机存取存储器 exception n. 例外，异常，异议 digit n. 数字，位数，位 reverse v. &amp; a. 反向的，逆 minimum n. &amp; a. 最小(的)，最低 enough a. &amp; ad. 足够的，充足的 although conj. 虽然，即使 reindex v. &amp; n. 变换(改变)符号 third a. &amp; n. 第三，三分之一 red a. &amp; n. 红色(的) along prep. &amp; ad. 沿着 test n. &amp; v. 测试 small a. 小的，小型的 feed v. 馈给，(打印机)进纸 company n. &amp; v. 公司；交际，交往 movie n. 影片，电影(院) compile vt. 编译 frequently ad. 常常，频繁地 undefined a. 未定义的 state n. &amp; vt. 状态；确定 tick v；n. 滴答(响)；勾号(√) accept vt. 接受，认可，同意 intense a. 强烈的，高度的 documentation n. 文件编制，文本 asterisk n. 星号(*) easily ad. 容易地，轻易地 become v. 成为，变成，适宜 address vt. &amp; n. 寻址；地址 interface n. 接口 pause vi. 暂停 repeat v. 重复 restart v. 重新启动，再启动 assumed a. 假定的 speed n. 速度 entry n. 输入，项(目)，入口 combine v. 组合，联合 organize v. 组织，创办，成立 finished a. 完成的 mixed a. 混合的 permit v. 许可，容许 formatting n. 格式化 root n. 根 symbol n. 符号，记号 binary n. &amp; a. 二进制；双态的 whenever ad. &amp; conj. 随时 reach v. &amp; n. 范围，达到范围 caution n. &amp; v. 警告，注意 subtotal n. &amp; v. 小计，求部分和 card n. 卡片，插件(板) general a. 通用的 associated a. 联合的，相联的 transfer v. 传送，转换，转移 connect v. 连接 partition v. 划分，分区，部分 hexadecimal a. 十六进制的 generate vt. 产生，发生，生成 specification n. 说明书，规则说明书 customize vt. 定制，定做 far a. 远的，遥远的 nest v. 嵌套，后进先出 duplicate vt. 复制，转录，加倍 compression n. 压缩，浓缩 unable a. 不能的 means n. 方法，手段 alternately ad. 交替地，轮流地 intensity n. 强度，亮度 reading n. 读，读数 let v. 让，允许 explicitly ad. 明显地，显然地 compare v. 比较，对照，比喻 sector n. &amp; v. 扇区，段；分段 problem n. 问题，难题 vertically ad. 竖直地，直立地 horizontally ad. 水平地 backspace v. 退格，回退 terminate v. 端接，终止 people n. 人们 short a. &amp; n. 短的；短路 drag vt. 拖，拉，牵，曳 formatted a. 有格式的 preview n. &amp; vt. 预映 underscore vt. 在…下面划线 correctly ad. 正确地 initially ad. 最初，开头 reformat v. 重定格式 inside n. &amp; a. 内部，内容；内部的 integrate v. 综合，集成 controlled a. 受控制的，受操纵的 period n. 周期 huge a. 巨大的，非常的 determined a. 坚决的，毅然的 trailing n. &amp; a. 结尾；尾随的 seek v. 查找，寻找，探求 introduction n. 入门，介绍，引进 indent v. 缩排 base n. 基，底，基地址 integer n. 整数 attempt vt. &amp; n. 尝试，试验 twice n. &amp; ad. 两次，两倍于 formed a. &amp; n. 成形 subscript n. 注脚，下标 tiny a. 微小的，微量的 model n. 模型，样机，型号 correction n. 校正，修正 rating n. 定额，标称值 secondary a. 辅助的，第二的 opened a. 开路的，断开的 limit n. 极限，限界 sun n. 太阳，日 translate v. 翻译，转换，平移 reason n. 原因，理由 colon n. 冒号”:” avoid vt. 避免，取消，无效 range n. 范围，域，区域 allocate vt. 分配 wordperfect a. 一字不错地熟记的 simply ad. 简单地，单纯地 verify vt. 鉴定，检验，核对 manner n. 方法，样式，惯例 direction n. 方向，定向，指向 portion n. &amp; vt. 部分；分配 emulator n. 仿真器，仿真程序 successful a. 成功的 applied a. 适用的，外加的 sum n. 和，合计，总额 achieve vt. 完成，实现 together ad. 一同，共同，相互 affect vt. 影响，改变，感动 delay v. 延迟 free a. 自由的，空闲的 properly ad. 真正地，适当地 kind n. 种类，属，级，等 splitting n. 分区(裂) feature n. 特征，特点 console n. 控制台，操作台 operate v. 操作，运算 kernel n. 内核(核心)程序 easy a. &amp; ad. 容易的；容易地 modifier n. 修改量，变址数 invalid a. 无效的 compiler n. 编译程序(器) dot n. 点 beep n. 蜂鸣声，嘀嘀声 face n. 面，表面 random a. 随机的 facility n. 设施，装备，便利 heading n. 标题 asynchronous a. 异步的，非同步的]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY03]]></title>
    <url>%2F2019%2F11%2F09%2FARTS-week17%2F</url>
    <content type="text"><![CDATA[DAY03 序号 词汇 词性 释义 301 however conj 然而，可是 302 extend v 扩充 303 look v 看，查看 304 starting a 起始的 305 now ad &amp; n 此刻，现在 306 original n &amp; a 原文；原(初)始的 307 correspond vi 通信(联系) 308 property n 性(质)，特征 309 several a &amp; n 若干个，几个 310 learn v 学习，训练 311 cause n 原因，理由 312 bracket n (方)括号，等级 313 omit vt 省略，删去，遗漏 314 running a 运行着的，游动的 315 sub-directory n 子目录 316 edge n 棱，边，边缘，界限 317 form n 格式，表格，方式 318 instruction n 指令，指导 319 ascii n 美国信息交换标准码 320 below a &amp; prep 下列的；低于 321 standard n 标准 322 occurrence n 出现，发生 323 lock n &amp; v 锁，封闭；自动跟踪 324 append vt 附加，增补 325 destination n 目的地，接收站 326 password n 口令，保密字 327 point n 点，小数点，句号 328 variety n 变化，种类，品种 329 many a &amp; n 许多，多数 330 buffer n 缓冲器 331 useful a 有用的 332 object n 对象，目标，物体 333 again ad 再，又，重新，也 334 operating a 操作的，控制的 335 carry v 进位，带 336 update v 更新，修改，校正 337 moving n &amp; a 活动的，自动的 338 coprocessor n 协同处理器 339 overlay v 覆盖，重叠 340 practice n 实习，实践 341 navigation n 导航 342 automatically ad 自动地，机械地 343 total n &amp; v 总数；总计 344 previous a 早先的，上述的 345 software n 软件 346 shortcut n 近路，捷径 347 long a 长的，远的 348 unique a 唯一的，独特的 349 part n 部分，零件 350 updated a 适时的，更新的 351 internal a 内部的 352 fill v 填充 353 basic n &amp; a 基本；基本的 354 math n 数学 355 since prep 自从…以来 356 determine v 确定 357 making n 制造，构造 358 center n 中心，中央 359 already ad 已经，早已 360 keyword n 关键字(词) 361 action n 操作，运算 362 condition n &amp;vt 条件，情况； 调节 363 quick a&amp; ad 快速的，灵敏的 364 assigned a 指定的，赋值的 365 give vt 给出，赋予，发生 366 large a (巨)大的，大量的 367 chapter n 章，段 368 computer n 计算机 369 complete v &amp; a 完成；完整的 370 past a 过去的，结束的 371 match v 比较，匹配，符合 372 recover v 恢复，回收 373 always ad 总是，一直，始终 374 require v 需要，要求 375 opening n 打开，断路，孔 376 network n &amp; vt 网络；联网 377 sign n 符号，信号，记号 378 release vt &amp; n 释放，核发，版 379 three a &amp; n 三(的) 380 recall vt 撤消，复活，检索 381 deletion n 删去(部分)，删除 382 fixed a 固定的，不变的 383 amount vt &amp; n 总计；合计 384 alias n 别名，代号，标记 385 quote n &amp; v 引号；加引号 386 correct a &amp; vt 正确的；改正 387 else ad&amp; conj 否则，此外 388 maximum n &amp; a 最大(的)，最高 389 under prep 在…下面(之下) 390 take v 取，拿 391 switching n 开关，转接，交换 392 element n 元件，元素，码元 393 modification n 改变，修改 394 modified a 修改的，变更的 395 input n 输入，输入设备 396 uppercase n 大写字母 397 plus prep 加，加上，外加 398 found v 建立，创办 399 debug vt 调试 400 force v &amp; n 强制；压力，强度 401 lowercase n 下档，小写体 402 just ad 恰好 403 undo vt 取消，废除 404 environ vt 围绕，包围 405 why ad 为什么 406 temporary a 暂时的，临时的 407 put v 存放(记录)，放置 408 instead ad (来)代替，当作 409 encounter v &amp; n 遇到，碰到 410 across prep 交叉，越过 411 matching n 匹配，调整 412 wildcard n 通配符 413 spill v 漏出，溢出，漏失 414 level n 水平，级，层次 415 browse v 浏览 416 speech n 说话，言语，语音 417 occur vi 发生，出现，存在 418 memo n 备忘录 419 prior a 先验的，优先的 420 loaded a 有负载的 421 length n (字，记录，块)长度 422 round v 舍入，四舍五入 423 variant n &amp; a 变体，易变的 424 floppy n 软磁盘 425 machine n 机器，计算机 426 square n &amp; a 正方形；方形的 427 supply vt &amp; n 电源，供给 428 home n &amp; a 家，出发点 429 normal a &amp; n 正常，标准 430 onto prep 向…，到…上 431 during prep 在…期间 432 module n 模块(程序设计) 433 monochrome n 单色 434 assistance n 辅助设备，帮助 435 tell n 讲，说，教，计算 436 library n (程序…)库，图书馆 437 demonstration n (公开)表演，示范 438 stack n 栈，堆栈，存储栈 439 even a&amp; ad 偶数的；甚至 440 evaluate v 估计，估算，求值 441 times n 次数 442 previously ad 以前，预先 443 directly ad 直接地，立即 444 logical a 逻辑的，逻辑”或” 445 template n 标准框，样板，模板 446 calling n 呼叫，调用，调入 447 later a 更后的，后面的 448 driver n 驱动器，驱动程序 449 therefore ad &amp; conj 因此，所以 450 saving a 保存的 451 detail n 元件，零件，细节 452 linker n 连接程序 453 loop n 圈，环；(程序)循环，回路 454 process vt 处理，进程，加工 455 scheme n 方案，计划，图 456 every a 每个，全体，所有的 457 refer v 访问，引用，涉及 458 possible a 可能的，潜在的 459 above a 在…之上，大于 460 overview n 综述，概要 461 result n 结果 462 syntax n 语法，文法，句法 463 abbreviation n 缩短，省略，简称 464 bios n 基本输入/输出系统 465 hidden a 隐藏的，秘密的 466 null n &amp; a 空(的)，零(的) 467 send v 发送 468 private a 专用的，私人的 469 hard a 硬的 470 hardware n 硬件 471 say v 说，显示，假定 472 equal vt &amp; n 等于，相等；等号 473 pack n 压缩，包裹 474 minus a &amp; n 负的；负数，减 475 alternate a 交替的，备用的 476 collapse v 崩溃，破裂 477 corner n 角，角落，转换 478 present a &amp; v 现行的；提供 479 interpreter n 解释程序，翻译机 480 advance v &amp; n 进步，提高；进展 481 forward a 正向的 482 fast a &amp; ad 快速的 483 special a 专用的，特殊的 484 slash n 斜线 485 utility n &amp; a 实用程序；实用性 486 regardless a 不注意的，不考虑的 487 disable vt 禁止，停用 488 compatible a 可兼容的，可共存的 489 depend vi 随…而定，取决于 490 empty a 空，零，未占用 491 alphabetical a 字母(表)的，abc的 492 branch n 分支，支线； v 转换 493 resume v 重(新)开(始) 494 multiple a 多次的，复杂的 495 monitor n 监视器，监督程序 496 configuration n 配置 497 replacement n 替换，置换，更新 498 required a 需要的 499 macros n 宏命令(指令) 500 table n 表 501 loss n 损耗，损失 502 batch n 批，批量，成批 503 exact a 正确的 504 aboveboard ad &amp; a 照直，公开的 505 activate vt &amp; n 使激活，驱动 506 around ad &amp; prep 周围，围绕 507 slow a &amp; ad 慢速的 508 floating a 浮动的，浮点的 509 refresh v 刷新，更新，再生 510 stop v 停止，停机 511 pass v 传送，传递，遍(数) 512 public a 公用的，公共的 513 eject n 弹出 514 ignore vt 不管，忽略不计 515 share v 共享，共用 516 sequence n 顺序，时序，序列 517 consist vi 符合，包括 518 step n 步，步骤，步长，档 519 double a 两倍的，成双的 520 come vi 来，到，出现 521 lower a 下部的，低级的 522 describe vt 描述，沿…运行 523 count v 计数，计算 524 pop v 上托，弹出(栈) 525 valid a 有效的 526 suspend v 中止，暂停，挂起 527 enhance vt 增强，放大，夸张 528 separate v &amp; a 分隔，分离，各自的 529 echo n 回波，反射波 530 necessary a 必要的，必然的 531 greater than 大于 532 able a 能…的，有能力的 533 marking n 标记，记号，传号 534 ask v 请求，需要 535 term n 项，条款，术语 536 bring v 引起，产生，拿来 537 warning n &amp; a 报警，预告 538 less a &amp; ad 更小，更少 539 whose pron 谁的 540 comment n &amp; vi 注解，注释 541 effect n 效率，作用，效能 542 expanding a 扩展的，扩充的 543 on-line a 联机的 544 reorder v (按序)排列，排序 545 direct a 直接的 546 enclose vt 封闭，密封，围住，包装 547 reset vt 复位，置”0” 548 various a 不同的，各种各样的 549 paper n 纸，文件，论文 550 prevent v 防止，预防 551 side n (旁)边，面，侧(面) 552 push v 推，按，压，进(栈) 553 programming n 程序设计，编程序 554 upper a 上的，上部的 555 row n 行 556 pressed a 加压的，压缩的 557 temporarily ad 暂时 558 day n 日，天，白天，时代 559 repaint vt 重画 560 redefine vt 重新规定(定义) 561 relation n 关系，关系式 562 dimension n 尺寸，维，因次 563 boundary n 边界，界限，约束 564 zoom v 变焦距 565 initialize v 初始化 566 personal a 个人的，自身的 567 hello int &amp; v 喂！；呼叫 568 true a &amp; n 真，实，选中 569 wish v &amp; n 祝愿，希望 570 font n 铅字，字形 571 know v 知道，了解，认识 572 convert v 转换，变换 573 global n 全局，全程，全局符 574 still a &amp; n &amp; v 静止的；静；平静 575 installation n 安装，装配 576 invoke vt 调用，请求 577 interactive a 交互式，交互的 578 described a 被看到的，被发现的 579 century n 世纪 580 literal a 文字的 581 rather ad 宁可，有点 582 exclusive a 排斥，排它性 583 marker n 记号，标记，标志 584 wait v 等待 585 appropriate a 适当的，合适的 586 fit v &amp; n 适合，装配；非特 587 adapter n 适配器，转换器 588 filter n 滤波器，滤光材料 589 break v 断开，撕开，中断 590 backward ad 向后，逆，倒 591 searching n 搜索 592 receive v 接收 593 dual a 对偶的，双的 594 retry vt 再试，复算 595 normally ad 正常地，通常 596 exactly ad 正好，完全，精确地 597 immediately ad 直接地 598 separated a 分开的 599 high a 高 600 equivalent a 相等的，等效的]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY02]]></title>
    <url>%2F2019%2F11%2F08%2FARTS-week16%2F</url>
    <content type="text"><![CDATA[DAY02 序号 词汇 词性 释义 101 system n 系统 102 contain vt 包含，包括 103 time n；vt 时间； 计时 104 letter n 字母，信 105 data n 数据 106 setting n 设置，调整 107 desire v &amp; n 期望 108 position n 位置；vt 定位 109 down ad 落下，降低，减少 110 task n 任务；v 派给…任务 111 view n &amp; v 视图，景象 112 switch n &amp; v 开关，转换，切换 113 include vt 包括，包含 114 get v 得到，获得，取 115 default v 缺省，预置，约定 116 structure n 结构，构造，构件 117 into prep 向内，进入 118 path n 路径，通路，轨道 119 blank n 空白，间隔 120 open v 打开，开启，断开 121 add v &amp; n 加，增加，添 122 enable vt 启动，恢复正常操作 123 operation n 操作，运算，动作 124 erase v 擦除，取消，删除 125 filename n 文件名 126 search v 检索，查询，搜索 127 another a 另一个，别的 128 last a &amp; n 最后(的) 129 column n 列，柱，栏 130 after prep &amp; ad 以后，后面 131 prompt n &amp; v 提示 132 two n &amp; a 二，两，双 133 execute v 实行，实施 134 about ad 关于，大约，附近 135 escape v 逃避，逸出，换码 136 error n 错误，误差，差错 137 currently ad 目前，现在 138 extension n 扩充，延伸 139 same a 同样的，相同的 140 status n 状态，态，状况 141 run v 运行，运转，操作 142 argument n 变元，自变量 143 statement n 语句，陈述，命题 144 shift v 转义，换档，移位 145 store n &amp; vt 存储，存储器 146 scroll vt 上滚(卷)；n 纸卷 147 replace vt 替换，置换，代换 148 macro n 宏，宏功能，宏指令 149 page n 页面，页，版面 150 quit v 退出，结束 151 define vt 定义，规定，分辨 152 reference n &amp; a 参考；参考的 153 other a 别的，另外的 154 while conj 当…的时候 155 pressing n &amp; a 压制；紧急的 156 restore vt 恢复，复原 157 top n 顶，尖端 158 how ad 如何，怎样，多么 159 color n 颜色，色彩，(彩)色 160 allow v 允许，容许 161 block n (字，信息，数据)块 162 decimal n &amp; a 十进制；十进制的 163 main a 主要的 164 definition n 定义，确实，清晰度 165 between prep 在…之间，中间 166 optional a 任选的，可选的 167 date n 日期 168 remove v 除去，移动 169 arrow n 箭头，指针 170 label n 标签，标号，标识符 171 within prep 在…以内 172 issue v 发行，出版，流出 173 different a 不同的，各种各样的 174 available a 可用的 175 returned a 退回的 176 associate v 相联，联想，关联 177 attribute n 属性，标志，表征 178 dos 磁盘操作系统 179 before prep 以前，前，先 180 order n &amp; vt 指令，次序；排序 181 modify vt 修改，改变，变址 182 array n 数组，阵列 183 mouse n 鼠标器 184 note n 注解，注释 185 locate vt 定位 186 video n 视频，电视 187 printer n 打印机，印刷机 188 bar n 条，杆，棒 189 bottom n &amp; a 底，基础；底下的 190 carriage n 滑架，托架 191 content n 含量，容量，内容 192 either a &amp; pron 任何一个，各 193 ok ad &amp; a 对，好；全对 194 space n 空格键，空间 195 editor n 编辑程序 196 exist vi 存在，生存，有 197 scope n 范围，显示器 198 paragraph n 段(落)，节，短讯 199 multi (词头)多 200 clear v 清除，弄干净 201 exit n &amp; vi 出口；退出 202 report vt &amp; n 报告，报表 203 execution n 执行 204 backup n 备份，后备，后援 205 version n 版本 206 find v 寻找，发现 207 pointer n 指针，指示字 208 subset n 子集，子设备 209 keyboard n 键盘 210 full a &amp; ad &amp; n 全(的)，满 211 check v 校对，栓查，核算 212 should v &amp; aux 应当，该 213 single a &amp; n 单个的；一个，单 214 positioning n 定位 215 provide v 提供 216 title n 题目，标题 217 expression n 表达式 218 through prep &amp; ad 通过，直通 219 toggle n &amp; v 触发器；系紧 220 code n 码，代码，编码 221 such a &amp; pron 这样的，如此 222 beginning n 起点，初 223 guide n 向导，指南，入门 224 tree n 树，语法树 225 environment n 环境 226 but 但是，可是，除非，不过 227 device n 设备，器件，装置 228 highlight n 增强亮度，提示区 229 call v 调用，访问，呼叫 230 continue v 连续，继续 231 indicate vt 指示，表示 232 until prep 到…为止，直到 233 begin v 开始，着手，开端 234 place vt 放，位，地点 235 rename vt 更名，改名 236 swap v 交换，调动 237 work n 工作 238 remain vi 剩下，留下，仍然 239 close v &amp; a 关闭，闭合；紧密的 240 combination n 结合，组合 241 profile n 简要，剖面，概貌 242 unless conj 除非 243 so pron &amp; conj 如此，这样 244 except prep 除…之外，除非 245 turn v &amp; n 转，转动；圈，匝 246 back n 背面，反向，底座 247 sure a &amp; ad 确实的；的确 248 section n 节，段，区域 249 follow v 跟随，跟踪 250 split v 分开，分离 251 need v 必须，需要 252 access n 存取，选取，接近 253 additional a 附加的，辅助的 254 cancel v 删除，取消，作废 255 document n 文献，资料，文件 256 case n 情况，场合 257 numeric n &amp; a 数字的，分数 258 go vi 运行，达到 259 load n &amp; v 装入，负载，寄存 260 try n (尝)试，试验 261 size n 尺寸，大小，容量 262 entire a &amp; n 完全的；总体 263 leave v 离开，留下 264 history n 历史 265 second n &amp; a 秒，第二(的) 266 reflow v &amp; n 回流，逆流 267 output n 输出，输出设备 268 out n &amp; a 输入，在外 269 both a &amp; ad 两，双，都 270 install vt 安装 271 source n 源，电源，源点 272 way n 路线，途径，状态 273 assign vt 赋值，指定，分派 274 support vt 支援，支持，配套 275 specific a 特殊的，具体的 276 join v &amp; n 连接，并(运算) 277 expand v 扩充，扩展，展开 278 like a 类似的，同样的 279 diskette n 软磁盘，软盘片 280 skip v 跳跃(定位)，跳过 281 application n 应用 282 confirmation n 认可 283 whether conj 无论，不管 284 hold v 保持 285 click n “卡搭”声，插销 286 write v 写，存入 287 byte n (二进制的)字节 288 abbreviate vt 缩写，省略 289 show v 显示，呈现，出示 290 otherwise ad&amp; a 另外 291 working n 工作，操作，作业 292 delimiter n 定界符，分界符 293 location n 定位，(存储器)单元 294 perform v 执行，完成 295 graphic n &amp; a 图形；图形的 296 read v 读，读阅 297 confirm vt 证实，确认 298 sort v 分类，排序 299 clause n 条款，项目，子句 300 once ad &amp; n 只一次，一旦]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专用英语-DAY01]]></title>
    <url>%2F2019%2F11%2F07%2FARTS-week15%2F</url>
    <content type="text"><![CDATA[DAY01 序号 词汇 词性 释义 1 file n 文件； 2 command n 命令，指令 3 use v 使用，用途 4 program n 程序 5 line n (数据，程序)行，线路 6 if conj 如果 7 display vt 显示，显示器 8 set v &amp; n 设置，集合 9 key n 键，关键字，关键码 10 list n 列表，显示 11 by prep 凭，靠，沿 12 press v 按，压 13 with prep 用，与，随着 14 format n 格式 15 change v 更换，改变，变动 16 cursor n 光标，游标 17 directory n 目录，索引簿 18 from prep 从，来自，以来 19 menu n 菜单，目录 20 option n 任选，选择，可选项 21 character n 字符，符号，特性 22 current n 电流，当前 23 type n 型，类型； 24 screen n 屏幕，屏； 25 specify v 指定，规定，确定 26 move v 移动 27 disk n 盘，磁盘 28 text n 正文，文本 29 drive v 驱动； 30 see v 看，看出，查看 31 name n 名，名称； 命名 32 record n 记录 33 box n 箱，匣，(逻辑)框 34 database n 数据库 35 help v &amp; n 帮助 36 memory n 记忆存储，存储器 37 which pron 哪个，a 那一个 38 all a 全，全部；ad 完全 39 on ad 接通，导电，开 40 copy n&amp;v 复制， 拷贝 41 shell n 脚本 42 delete vt 删除，删去，作废 43 enter v 键入，送入 44 margin n 边缘，边际 45 mark n &amp; vt 标记； 加标记 46 also ad &amp; conj 也，亦，还 47 do v &amp; n 做，干；循环 48 information n 信息，情报 49 choose v 挑选，选择，选定 50 select vt 选择 51 group n 组，群 52 first a &amp; ad &amp; n 第一，首先 53 field n 字段，域，栏，场 54 procedure n 过程，程序，工序 55 print v 打印，印刷 56 return v 返回，回送 57 number n &amp; vt 数字，号码； 编号 58 selected a 精选的 59 want v 需要，应该，缺少 60 window n 窗口 61 message n 信息，消息，电文 62 dialog n &amp; vt 对话框，对话 63 example n 例子，实例 64 create vt 创立，建立 65 insert vt 插入 66 related a 相关的 67 item n 项，项目，条款 68 edit vt 编辑，编排，编篡 69 marked a 有记号的 70 area n (区)域，面积，方面 71 parameter n 参数，参变量 72 then ad &amp; conj 那时，则 73 variable a &amp; n 可变的； 变量 74 tab n 制表键 75 up ad &amp; a 上，向上， 高的 76 string n 行，字符串 77 each a &amp; ad 各(自)，每个 78 active a 激活的，活动的 79 topic n 话题，题目，论题 80 start v 起动，开始，启动 81 mode n 态，方式，模 82 selection n 选择 83 function n 函数，功能，操作 84 word n 字(词)，单词 85 make vt 制造，形成，接通 86 right a 右边的，正确的 87 value n 值 88 button n 按钮 89 index n 索引，变址，指数 90 without prep 没有，在…以外 91 appear vi 出现，显现，好像 92 left a &amp; n 左边(的) 93 save v 保存 94 next n &amp; a 下一次 其次 95 off ad (设备)关着，脱离 96 following a 下列的，以下的 97 control v 控制，支配，管理 98 only a &amp; ad 唯一的 仅仅 99 user n 用户 100 end n 结束，终点，端点]]></content>
      <categories>
        <category>专业英语</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一个公众号给你吧]]></title>
    <url>%2F2019%2F11%2F06%2Fwechat%2F</url>
    <content type="text"><![CDATA[这不是一篇软文事先声明哈，这肯定不是一篇软文。大家都知道，咱老李是一个热心的人，看到好的东西就一定要分享给大家。这次也不例外。最看不得的就是那种拿着开源的东西去到处忽悠的，好东西就大家一块儿用呗。 这里是图片切到正题：]]></content>
      <categories>
        <category>宝库</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源]]></title>
    <url>%2F2019%2F08%2F23%2Fsources%2F</url>
    <content type="text"><![CDATA[手写RPC简单rpc代码实现 &radic;]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书清单]]></title>
    <url>%2F2019%2F08%2F21%2Fbooklist%2F</url>
    <content type="text"><![CDATA[万万没想到：用理工科思维理解世界从哪儿知道的这本书：从每天晒白牙的朋友圈中看他在微信读书已经看完了这本书别人是如何推荐的：这是他在微信读书中看完的第73本书这本书的作者是：万维钢打算什么时候读这一本书：从昨天开始每天读15页你想从这本书中学到什么：想用更加理性的思维去看，去听，去体验这个世界最终的总结：读书笔记：01.最简单概率论的五个智慧 潜意识：控制你行为的秘密从哪儿知道的这本书：《万万没想到：用理工科思维理解世界》这本书“别想说服我”一节别人是如何推荐的：《时间简史》、《大设计》两本书的第二作者，他是一个非常会写书的人这本书的作者是：列纳德.蒙洛迪诺你想从这本书中学到什么：如何知道读者想看什么？打算什么时候读这一本书：下一本最终的总结：]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一个宝库给你]]></title>
    <url>%2F2019%2F08%2F14%2Frecomm%2F</url>
    <content type="text"><![CDATA[这不是一篇软文事先声明哈，这肯定不是一篇软文。大家都知道，咱老李是一个热心的人，看到好的东西就一定要分享给大家。这次也不例外。最看不得的就是那种拿着开源的东西去到处忽悠的，好东西就大家一块儿用呗。 这里是地址切到正题：我说的宝库在这儿猜你就不信，来来来，咱们看图说话(ps:还可以点更多哟！)]]></content>
      <categories>
        <category>宝库</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.分布式文档服务]]></title>
    <url>%2F2019%2F08%2F09%2Ffastdfs%2F</url>
    <content type="text"><![CDATA[写在前面的打算用三篇文章来写fastDFS，但是作为程序员的我，在还没有做好理论研究的基础上就贸然做了一单机版的测试环境，让自己好尝鲜。这倒是有点符合自己的性格，先不说这些没用的了。表表自己的打算： 01.分布式文档服务搭建，只有自己亲自动手试验了才能有较为深入的理解，才能更好的跟其他同类产品进行比较，这也算是郑晔老师“以终为始”指导思想的一个实践吧； 02.分布式文档服务理论基础，这篇想写的内容包含基础的架构，设计思路（为何这么设计？这么设计有什么优势？）以及跟其他同类型产品的多维度比较。最终给出选择的原因 03.分布式文档服务的高级篇，如何跟开发语言进行集成，如何提高文档服务的可用性。 fastDFS文档服务搭建同事给推荐了一个教程写的很详细，但是真正在实践的时候却没有一个明确的指导，而且里面涉及到的版本也都很早了。所在一开始我是按着人家的教程但是所有版本都用的最新的，前面几部还挺顺利，但真正到了最后挂载nginx服务的时候，各种各样的问题就都来了。百思不得解，弄着弄着我都想放弃了。但没有搞定的这种说法在我的脑海中不停的乱跳，于是就从github上人家开发的wiki找到了，我认为最正宗的解法。 先附上地址：[fastdfs文档服务搭建教程](https://github.com/happyfish100/fastdfs/wiki) 从开始到完成一共用了不到10分钟，这使得我对这款产品的好感真是由然而生呀。后来想了想，估计之前最大的错误就是把它认为成任何版本都是可以相互兼容的，导致一个坑一个坑的去填。这从侧面也给我了一个启示，要学就要学最正宗的技术，当然这需要自己的亲身实践才能得到最后的结论，那么问题是最正宗的技术在哪儿的呢？从开源软件产品的角度来看，一般都会在人家的官网上，什么csdn、博客园、简书之类的技术博客，写个故事还行，对学习没有好处，可能真正觉得有好处的就是写作者了吧，可看到自己写的系列文章被传的哪儿都是，或者有一篇文章被访问了几百万次。]]></content>
      <categories>
        <category>文档服务器</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>分布式文档服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts全国地图分享]]></title>
    <url>%2F2019%2F07%2F01%2Fechart%2F</url>
    <content type="text"><![CDATA[先看看效果图,这个效果还是挺好的，做个免费可视化的大屏还真是可以的。在这儿我也做资源的搬运工吧，把地图的数据以及使用地图能做的效果展示给大家看，相信可以帮助到你！ 附上两个文件的下载链接（别客气，可以直接下载的无毒）：echartsMap，全国各省、市、县的地图数据iDataV-master，这个是有好几个大屏显示效果的demo,绝对的干货]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts全国地图分享]]></title>
    <url>%2F2019%2F07%2F01%2Fecharts-map%2F</url>
    <content type="text"><![CDATA[先看看效果图,这个效果还是挺好的，做个免费可视化的大屏还真是可以的。 附上两个文件的下载链接：echartsMap，全国各省、市、县的地图数据iDataV-master，这个是有好几个大屏显示效果的demo,绝对的干货]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week14]]></title>
    <url>%2F2019%2F06%2F23%2FARTS-week14%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-9. Valid Parentheses &radic; 2、Review分布式系统原理 &radic; 3、Tips到底该不该坚持下去 &radic; 4、Share推荐一款数据库建模工具PDMan &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week13]]></title>
    <url>%2F2019%2F06%2F20%2FARTS-week13%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-20. Valid Parentheses &radic; 2、Review分布式系统原理 &radic; 3、Tips思考框架 &radic; 4、ShareES6入门教育 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week12]]></title>
    <url>%2F2019%2F06%2F09%2FARTS-week12%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-232. Implement Queue using Stacks &radic; 2、Review分布式系统原理 &radic; 3、TipsopenSSH升级 &radic; 4、Share技术管理星空图 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week11]]></title>
    <url>%2F2019%2F06%2F02%2FARTS-week11%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-232. Implement Queue using Stacks &radic; 2、Review分布式系统原理 &radic; 3、Tips一个人是他所有读过的书的总和 &radic; 4、Share关于领域驱动设计的分享 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week10]]></title>
    <url>%2F2019%2F05%2F26%2FARTS-week10%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-155. 最小栈 &radic; 2、Review看看你能做对几个，全对有奖！ &radic; 3、Tipstomcat多host配置 &radic; 4、Share如果你真的牛逼，考一个系统分析师来看看？ &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week09]]></title>
    <url>%2F2019%2F05%2F19%2FARTS-week09%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-202.快乐数 &radic; 2、Review分布式系统原理 &radic; 3、Tipshttp协议为什么是无状态的 &radic; 4、ShareGraphQL &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week08]]></title>
    <url>%2F2019%2F05%2F12%2FARTS-week08%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-887.鸡蛋掉落 &radic; 2、Review分布式系统原理 &radic; 3、Tipsshiro设置自定义Token &radic; 4、Share白话中台战略 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week07]]></title>
    <url>%2F2019%2F05%2F05%2FARTS-week07%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-997.找到小镇的法官 2、Review分布式系统原理 3、TipsSQL Server数据库sa账户解锁 4、Share消息实时推送]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week06]]></title>
    <url>%2F2019%2F04%2F27%2FARTS-week06%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-4:Median of Two Sorted Arrays 2、Reviewjava archive 分布式系统原理 3、Tipsjar和war的区别 4、Share服务器推送]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week05]]></title>
    <url>%2F2019%2F04%2F21%2FARTS-week05%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-455:Assign Cookies &radic; 2、Review分布式系统原理 &radic; 3、TipsemailJS使用 &radic; 4、ShareRust粗浅理解 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week04]]></title>
    <url>%2F2019%2F04%2F13%2FARTS-week04%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-234:回文链表 &radic; 2、Review分布式系统原理 &radic; 3、Tips用数组、链表实现栈 &radic; 4、Share阅读分享 &radic;数组总结 &radic;链表总结 &radic;堆总结 &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week03]]></title>
    <url>%2F2019%2F04%2F02%2FARTS-week03%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-141:给定一个链表，检测是否有环 &radic;Algorithm-19:移除链表中倒数第n个元素 &radic;Algorithm-21:合并有序链表 &radic;Algorithm-61:旋转链表 &radic;Algorithm-876:链表的中间结点 &radic; 2、ReviewCAP定理 &radic; 3、Tipsmysql Isolation &radic; 4、Sharejava lambda &radic;]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week02]]></title>
    <url>%2F2019%2F04%2F02%2FARTS-week02%2F</url>
    <content type="text"><![CDATA[1、AlgorithmAlgorithm-86. Partition List1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode part=null;//保存头指针 ListNode tail=null; ListNode part1= null; ListNode tail1=null; while(head!=null)&#123; ListNode dataNode=new ListNode(head.val); if(head.val&lt;x)&#123; if(part==null) part=tail=dataNode; else&#123; tail.next=dataNode;//将新节点连接到链表的尾部 tail=dataNode;////tail永远存储最后一个节点的地址 &#125; &#125;else&#123; if(part1==null) part1=tail1=dataNode; else&#123; tail1.next=dataNode;//将新节点连接到链表的尾部 tail1=dataNode;////tail永远存储最后一个节点的地址 &#125; &#125; head=head.next; &#125; if(tail==null) return part1; tail.next=part1; return part; &#125;&#125;//执行用时 : 1 ms, 在Partition List的Java提交中击败了84.18% 的用户//内存消耗 : 34.8 MB, 在Partition List的Java提交中击败了0.94% 的用户 2、ReviewBitcoin :A Peer to Peer Electronic Cash System比特币：点对点的电子现金系统Abstract:A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to annother without going through a financial institution .Digital Signatures provide part of the solution,but the main benefits are lost if a trusted third party is still required to prevent double-spending.We propose a solution to the double-spending problem using a peer-to-peer network.The network timestamps transactions by hashing them into an ongoing chainof hash-based proof of work , forming a record that cannot be changed without redoing the proof-of-work.The longest chain not only serves as proof of the sequence of events witnessed ,but proof that it came from the largest pool of CPU power.As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network , they’ll generate the longest chain and outpace attackers.The network itself requires minimal structure.Messages are broadcast on the best effort basis, and nodes can leave and rejoin the network at will,accepting the longest proof-of-work chain as proof of what happened while they were gone.组词：纯粹 点对点 版本 电子现金 允许 直接发送在线支付 从一方到另一方 无需通过金融机构造句：1、一个纯粹的点对点电子现金系统是允许不通过金融机构，来完成从一方到另一方的直接在线支付。组词：数字签名 提供 部分解决方案 但是 最大的收益 丢掉 是否需要一个可信的第三方 阻止“双花”造句：2、数据签名为其提供了部分的解决方案，但是最大的收益是一个可信的、能阻止“双花”的第三方可以丢掉了组词：我们的目的 解决方案 双花问题 通过点对点的网络造句：3、我们的目标就是通过这样一个点对点的网络来解决“双花”问题 组词：网络时间戳 交易 做哈希 基于哈希工作量证明r 不间断的链 形成不可篡改的记录造句：4、对网络时间戳交易做哈希，并把他们链接到基于哈希工作量证明的不间断链上，以此来形成不可篡改的记录。组词：最长的链 不仅 作用于 事件的顺序证明，而且证明了 CPU算力的最大资源池。造句：5、最长的链不仅可以证明交易事件的先后顺序，还可以证明它是来自于最大CPU算力的资源池组词：只要 主要的 CPU算力 被控制 节点（不合作 去攻击网络），他们会形成最长的链并超过攻击者造句：6、只要大部分的CPU算力被这些攻击网络的节点所控制，他们就会形成最长的链并成为超级攻击者组词：网络本身 需要 最小结构造句：7、网络本身需要最小的结构组词：消息 广播 尽力而为 节点 离开 重新加入 网络 随意 接收 最长工作量证明链 证据 在他们离开期间发生了什么造句：8、消息被全网尽最大可能的传播，网络中的节点也可以随意的离开和重新加入，但这些节点得下载他们离开期间所产生的最长的链Introduction:Commerce on the Internet has come to rely almost exclusively on financial institutions serving astrusted third parties to process electronic payments.While the system works well enough formost transactions, it still suffers from the inherent weaknesses of the trust based model.Completely non-reversible transactions are not really possible, since financial institutions cannotavoid mediating disputes.The cost of mediation increases transaction costs, limiting theminimum practical transaction size and cutting off the possibility for small casual transactions,and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services.With the possibility of reversal, the need for trust spreads.Merchants must be wary of their customers, hassling them for more information than they would otherwise need.A certain percentage of fraud is accepted as unavoidable.These costs and payment uncertaintiescan be avoided in person by using physical currency, but no mechanism exists to make paymentsover a communications channel without a trusted party.What is needed is an electronic payment system based on cryptographic proof instead of trust,allowing any two willing parties to transact directly with each other without the need for a trustedthird party. Transactions that are computationally impractical to reverse would protect sellersfrom fraud, and routine escrow mechanisms could easily be implemented to protect buyers. Inthis paper, we propose a solution to the double-spending problem using a peer-to-peer distributedtimestamp server to generate computational proof of the chronological order of transactions. Thesystem is secure as long as honest nodes collectively control more CPU power than anycooperating group of attacker nodes. 组词：商业 互联网（电商？） 依赖 几乎完全 金融机构 服务 可信任的第三方 进行电子支付造句：1、电商几乎完全依赖于可信的第三方金融机构服务来完成电子支付。组词：虽然 系统 正常工作 对大部分交易来说就足够了 但仍然 受制于 基础信用模型固有缺陷造句：2、只要系统能够正常运转，对于大部分交易来说足够了，但这种模式仍然受制于基础信用模型的固有缺陷组词：完全不可逆的交易是不可能出现的 金融机构不可能避免调节纠纷造句：3、完全不可逆的交易是真的不可能，就像金融机构不可能避免需要调节纠纷一样。组词：调节的花费 增长 交易花费 限制 最小实现交易大小 消失小型临时交易的可能性 较大的花费 制造不可逆支付能力的丢失 不可逆服务造句：4、调节纠纷的费用甚至超过了交易本身的花费，限制实际交易的最小大小，并切断小型临时交易的可能性。还有一个花费较大的点就是在实现对不可逆服务的不可逆支付能力的丢失上。组词：可逆的可能性 对于信任的需要 传播开来造句：5、对于可逆的可能性，对于信任的需要被广泛传播开来组词：商人必须警惕他们的客户，跟他们为需要更多信息而争论造句：6、商人必须警惕他们的客户，并跟他们为需要更多信息而进行争论 3、Tipscrsctl stop res -all oracle 集群的停机顺序为，先停监听-&gt;实例-&gt;服务-&gt;cluster 软件或者直接用上面的命令，可以用-t 查看是否全是offline 在linux 环境下 su user、su - user、su -user 有什么区别呢？使用su userx 切换到userx用户之后，不可以再使用service命令了，使用su - userx就可以使用service命令。这两者的区别是su只是切换了用户的身份，但shell环境没有改变（还是su之前的用户），而su -则连同用户以及shell环境一起切换成了新用户的环境，只有切换了shell环境才会出现path变量错误，报command not found 可以能过pwd命令来区别。 周末部里要断电，被要求关机。一大堆的东西该怎么关呢？1、先把业务系统给停止，再停止中间件及其他应用软件，停止数据库（12c 做的rac，就是上面那个命令的，不过需要grid用户，在使用该用户的时候发生了su user 与su - user的区别问题），所有服务都停止了之后就是关机断电了，最后一部关存储了。存储这块用的是杭州xx，竟然没有控制端，还需要用网线直连才能使用，最终竟然还需要让我把本机上的jdk都卸载了再去装他们那个7.0，完全都处理好了最后还是不行，被告知是因为机器问题。what the fuck,停是停了，不知道断电之后再重启是个什么球样子，希望周一一切都ok,验证过了的确是Ok 4、Sharebitcoin]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-week01]]></title>
    <url>%2F2019%2F04%2F02%2FARTS-week01%2F</url>
    <content type="text"><![CDATA[1、Algorithm/**Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.还有这么奇葩的题？正常的解法执行用时 : 8 ms, 在Remove Element的Java提交中击败了71.39% 的用户内存消耗 : 37.6 MB, 在Remove Element的Java提交中击败了0.97% 的用户 */ Algorithm-27. Remove Element1234567891011121314class Solution &#123; public int removeElement(int[] nums, int val) &#123; int k=0; for(int i=0;i&lt;nums.length;i++)&#123; if(val!=nums[i])&#123; nums[k]=nums[i]; k++; &#125; &#125; return k; &#125;&#125; Algorithm-206. Reverse Linked List12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode reverse=null;//最终返回 ListNode nodeData=null;//临时节点 while(head!=null)&#123; nodeData=new ListNode(head.val); if(reverse==null)&#123; reverse=nodeData; &#125;else&#123; nodeData.next=reverse; reverse=nodeData; &#125; head=head.next; &#125; return reverse; &#125; public ListNode reverseList01(ListNode head) &#123; ListNode reverse=null;//最终返回 ListNode nodeData=null;//临时节点 while(head!=null)&#123; nodeData=head.next; head.next=reverse; reverse=head; head=nodeData; &#125; return reverse; &#125; //说实话递归这个还是没搞太懂，一周以后再看看 public ListNode reverseList02(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode reverse=reverseList02(head.next); head.next.next=head; head.next=null; return reverse; &#125;&#125; 2、ReviewFrom Dapper, a Large Scale Distributed Systems Tracing Infrastructure three design goals of Dapper: a.low overhead:a sample of just one out of thousands of requests provides sufficient information for many common uses of the tracing data. b.Application_level transparency: Dapper is restricted to a low enough level in the software stack that even largescale distributed systems like Google web search could be traced without additional annotations. c.Scalability: handle the size of Google’s services and clusters for at least the next few years other similiar tracing systems: a.Magpie b.X-Trace c.Pinpoint a tree of nested RPCs model traces using trees,spans annotation. span id parent span id 3、Tips关于MySql的版本问题 查看Mysql当前的版本 已登录: 12a.select @@versionb.select version() 未登录: 12a.mysql -V(大写字母)b.mysql --version(两个横线) 各自版本 5.0:2005年添加了存储过程，服务端游标，触发器，查询优化以及分布式事务功能 5.1:2008年发布，增加一个崩溃恢复功能的MyISAM,使用表级锁，可以做到读写不冲突 5.5:2010年发布，默认存储引擎改为InnoDB,有多个回滚段 5.6:2013年发布，InnoDB可以限制大体量表打开的时候占用内存过多的问题，InnoDB性能加强 5.7:2015年发布，查询性能大幅提升，比5.6提升1倍降低了建立数据库连接的时间 8.0:对Mysql源码进行了重构，对Mysql Optimizer优化器进行改进，支持隐藏索引，基本上和MyISAM说再见了 其他：这个tips也太水了吧，就在挖个坑吧。这块儿内容我会以专栏的形式补齐。 补丁 Oracle Mysql被扫描出来的安全漏洞也是花样繁多，主要原因还是不同的版本问题。今天就打算修复一下测试服务器上的Mysql漏洞。官网上找了半天还是没有找到对应的补丁在哪儿下载（这估计能成为我想学习英文的主要原因），不过笨人有笨的办法，那就找不用打该补丁的版本喽 MySQL Client, versions 5.5.60 and prior, 5.6.40 and prior, 5.7.22 and prior, 8.0.11 and prior 于是就重新下了一个5.5.62。 安装Mysql，Start Service未响应 这个问题真的是太有意思了，一开始还以为是服务器的问题，好几次重试之后发现，这就是已经卸载没有清理干净的问题了。以Windows为例，默认会在C盘下隐藏目录ProgramData中存在已经安装的版本，直接干掉他，再来一遍over!! 4、Sharedapper]]></content>
      <categories>
        <category>attendance</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
        <tag>Link</tag>
      </tags>
  </entry>
</search>
