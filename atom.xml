<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>By1way</title>
  
  <subtitle>用心记录每一份成长、每一滴收获、每一个新奇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://by1way.github.io/"/>
  <updated>2021-04-25T01:14:24.097Z</updated>
  <id>https://by1way.github.io/</id>
  
  <author>
    <name>carol</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>15.事务处理</title>
    <link href="https://by1way.github.io/2021/04/30/15-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://by1way.github.io/2021/04/30/15-事务处理/</id>
    <published>2021-04-30T04:44:51.000Z</published>
    <updated>2021-04-25T01:14:24.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="15-事务处理：分布式事务之TCC与SAGA"><a href="#15-事务处理：分布式事务之TCC与SAGA" class="headerlink" title="15.事务处理：分布式事务之TCC与SAGA"></a>15.事务处理：分布式事务之TCC与SAGA</h3>]]></content>
    
    <summary type="html">
    
      来了解一下事务处理的本质
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>14.事务处理</title>
    <link href="https://by1way.github.io/2021/04/29/14-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://by1way.github.io/2021/04/29/14-事务处理/</id>
    <published>2021-04-29T04:44:51.000Z</published>
    <updated>2021-04-25T01:14:37.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="14-事务处理：分布式事务之可靠消息队列"><a href="#14-事务处理：分布式事务之可靠消息队列" class="headerlink" title="14.事务处理：分布式事务之可靠消息队列"></a>14.事务处理：分布式事务之可靠消息队列</h3>]]></content>
    
    <summary type="html">
    
      来了解一下事务处理的本质
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>13.事务处理</title>
    <link href="https://by1way.github.io/2021/04/28/13-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://by1way.github.io/2021/04/28/13-事务处理/</id>
    <published>2021-04-28T04:44:51.000Z</published>
    <updated>2021-04-25T01:12:57.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="13-事务处理：全局事务和共享事务是如实现的"><a href="#13-事务处理：全局事务和共享事务是如实现的" class="headerlink" title="13.事务处理：全局事务和共享事务是如实现的"></a>13.事务处理：全局事务和共享事务是如实现的</h3>]]></content>
    
    <summary type="html">
    
      来了解一下事务的本质
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>12.事务处理</title>
    <link href="https://by1way.github.io/2021/04/27/12-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://by1way.github.io/2021/04/27/12-事务处理/</id>
    <published>2021-04-27T04:44:51.000Z</published>
    <updated>2021-04-25T01:11:45.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="12-事务处理：本地事务如何实现隔离性"><a href="#12-事务处理：本地事务如何实现隔离性" class="headerlink" title="12.事务处理：本地事务如何实现隔离性"></a>12.事务处理：本地事务如何实现隔离性</h3>]]></content>
    
    <summary type="html">
    
      来了解一下事务的本质
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>11.事务处理</title>
    <link href="https://by1way.github.io/2021/04/26/11-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://by1way.github.io/2021/04/26/11-事务处理/</id>
    <published>2021-04-26T04:44:51.000Z</published>
    <updated>2021-04-25T01:14:47.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="11-事务处理：本地事务如何实现原子性和持久性"><a href="#11-事务处理：本地事务如何实现原子性和持久性" class="headerlink" title="11.事务处理：本地事务如何实现原子性和持久性"></a>11.事务处理：本地事务如何实现原子性和持久性</h3>]]></content>
    
    <summary type="html">
    
      来了解一下事务的本质
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>10.RESTful服务</title>
    <link href="https://by1way.github.io/2021/04/25/10-RESTful%E6%9C%8D%E5%8A%A1/"/>
    <id>https://by1way.github.io/2021/04/25/10-RESTful服务/</id>
    <published>2021-04-25T04:44:51.000Z</published>
    <updated>2021-04-26T07:01:23.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="10-RESTful服务：如何评价服务是否RESTful"><a href="#10-RESTful服务：如何评价服务是否RESTful" class="headerlink" title="10.RESTful服务：如何评价服务是否RESTful"></a>10.RESTful服务：如何评价服务是否RESTful</h3><p><img src="/2021/04/25/10-RESTful服务/10-RESTful服务_files/2.jpg" alt="view"></p><h4 id="Richardson成熟度模型"><a href="#Richardson成熟度模型" class="headerlink" title="Richardson成熟度模型"></a>Richardson成熟度模型</h4><ol><li>第０级 The Swamp of Plain Old XML,完成不REST</li><li>Resource,开始引入资源的概念</li><li>HTTP Verbs,引入统一接口，映射到HTTP协议方法上</li><li>Hypermedia Controls,超文本驱动</li></ol><p>场景是这样的：<br>    以开发一个医生预约系统为例，让病人可以通过这个系统，知道自己想要预约的医生在指定日期是否有空闲时间，以方便就诊</p><h5 id="第0级成熟度：-The-Swamp-of-Plain-Old-XML"><a href="#第0级成熟度：-The-Swamp-of-Plain-Old-XML" class="headerlink" title="第0级成熟度： The Swamp of Plain Old XML"></a>第0级成熟度： The Swamp of Plain Old XML</h5><pre><code>医院开放一个/appointmentService的web api。传入日期、医生姓名作为参数，就可以得到该时间段内，该医生的空闲时间</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求</span></span><br><span class="line">POST /appointmentService?action=query HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">&#123;date: <span class="string">"2020-03-04"</span>, doctor: <span class="string">"mjones"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;start:<span class="string">"14:00"</span>, end: <span class="string">"14:50"</span>, doctor: <span class="string">"mjones"</span>&#125;,</span><br><span class="line">    &#123;start:<span class="string">"16:00"</span>, end: <span class="string">"16:50"</span>, doctor: <span class="string">"mjones"</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line">POST /appointmentService?action=comfirm HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    appointment: &#123;date: <span class="string">"2020-03-04"</span>, start:<span class="string">"14:00"</span>, doctor: <span class="string">"mjones"</span>&#125;,</span><br><span class="line">    patient: &#123;name: xx, age: <span class="number">30</span>, ……&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    message: <span class="string">"Successful confirmation of appointment"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是基于RPC风格的服务设计，很好的解决了这个问题</p><h5 id="第1级成熟度：Resources"><a href="#第1级成熟度：Resources" class="headerlink" title="第1级成熟度：Resources"></a>第1级成熟度：Resources</h5><pre><code>围绕资源而非过程来设计服务，Endpoint应该是一个名词而不是动词，此外每次请求都应该包含资源ID,所有操作均通过资源ID来进行。上述的场景中，&lt;font color=&quot;red&quot;&gt;应该把什么看成是一种资源呢？医生？不是吧，应该是把医生的档期视作为一种资源&lt;/font&gt;。具体过程，可以观察一下请求和响应的URI</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求医生档期</span></span><br><span class="line">POST /doctors/mjones HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">&#123;date: <span class="string">"2020-03-04"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应信息</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;id: <span class="number">1234</span>, start:<span class="string">"14:00"</span>, end: <span class="string">"14:50"</span>, doctor: <span class="string">"mjones"</span>&#125;,</span><br><span class="line">    &#123;id: <span class="number">5678</span>, start:<span class="string">"16:00"</span>, end: <span class="string">"16:50"</span>, doctor: <span class="string">"mjones"</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//预约信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST /schedules/<span class="number">1234</span> HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">&#123;name: xx, age: <span class="number">30</span>, ……&#125;</span><br></pre></td></tr></table></figure><p>这些个交互看起来解决了一些问题，而且抽象程度也第0级高了不少。但是还有一些问题需要解决</p><ol><li>只处理了查询和预约，没有提供调整或者取消预约的接口</li><li>处理结果响应时，只能靠结果中的code、message信息做判断，不通用</li><li>没有考虑到认证授权等安全方面的内容</li></ol><h5 id="第2级成熟度，HTTP-Verbs"><a href="#第2级成熟度，HTTP-Verbs" class="headerlink" title="第2级成熟度，HTTP Verbs"></a>第2级成熟度，HTTP Verbs</h5><pre><code>通过统一接口来解决第1成熟度的三个问题，统一接口是什么呢？就是HTTP协议的标准方法。这些方法都是经过精心设计的，几乎可以涵盖资源可能会遇到的所有操作场景。具体要如何理解呢？1.针对预约变更的问题，把不同的业务需求抽象为对资源的增加、修改、删除等操作来解决2.针对响应码的问题，可以直接使用HTTP协议的Status Code,这就可以涵盖大多数据资源操作可能会出现的异常问题3.安全性问题嘛，可以依靠着Http Header中携带的额外认证、授权信息来解决</code></pre><p>反应到代码请求中是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//请求</span><br><span class="line">GET /doctors/mjones/schedule?date=2020-03-04&amp;status=open HTTP/1.1</span><br><span class="line">//响应</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;id: 1234, start:&quot;14:00&quot;, end: &quot;14:50&quot;, doctor: &quot;mjones&quot;&#125;,</span><br><span class="line">    &#123;id: 5678, start:&quot;16:00&quot;, end: &quot;16:50&quot;, doctor: &quot;mjones&quot;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//预约</span><br><span class="line"></span><br><span class="line">POST /schedules/1234 HTTP/1.1</span><br><span class="line"></span><br><span class="line">&#123;name: xx, age: 30, ……&#125;</span><br><span class="line"></span><br><span class="line">//预约成功</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line"></span><br><span class="line">Successful confirmation of appointment</span><br></pre></td></tr></table></figure></p><h5 id="第3级成熟度：Hypermedia-Controls"><a href="#第3级成熟度：Hypermedia-Controls" class="headerlink" title="第3级成熟度：Hypermedia Controls"></a>第3级成熟度：Hypermedia Controls</h5><pre><code>大多数系统都能够达到第2级成熟度，但是这种还是有点问题，就是前后不连贯，也就是我知道医生的空闲时间以后，怎么知道预约的地址呢？当然这是浏览器的角度，咱们大多都是依靠在程序硬编码来实现的。这是我们习以为常的操作，但REST的目的并不是这样的，它想的是：&lt;strong&gt;除了第一请求是由你在浏览器地址栏中输入驱动的以外，其它所有后续请求都能够自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。&lt;/strong&gt;唉多美好的愿望呀它的表现形式是这样的：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//请求</span><br><span class="line"></span><br><span class="line">GET /doctors/mjones/schedule?date=2020-03-04&amp;statu s=open HTTP/1.1</span><br><span class="line"></span><br><span class="line">//响应</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    schedules：[</span><br><span class="line">        &#123;</span><br><span class="line">            id: 1234, start:&quot;14:00&quot;, end: &quot;14:50&quot;, doctor: &quot;mjones&quot;,</span><br><span class="line">            links: [</span><br><span class="line">                &#123;rel: &quot;comfirm schedule&quot;, href: &quot;/schedules/1234&quot;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            id: 5678, start:&quot;16:00&quot;, end: &quot;16:50&quot;, doctor: &quot;mjones&quot;,</span><br><span class="line">            links: [</span><br><span class="line">                &#123;rel: &quot;comfirm schedule&quot;, href: &quot;/schedules/5678&quot;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">   ],</span><br><span class="line">   links: [</span><br><span class="line">       &#123;rel: &quot;doctor info&quot;, href: &quot;/doctors/mjones/info&quot;&#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，服务端的API和客户端的请求就能够做到完全解耦了，这个时候你再想调整什么东西是不是就很easy了</p><h4 id="REST的不足之处与争议"><a href="#REST的不足之处与争议" class="headerlink" title="REST的不足之处与争议"></a>REST的不足之处与争议</h4><h5 id="1-面向资源的编程思想只适合做CRUD-只有面向过程、面向对象编程才能处理真正复杂的业务逻辑"><a href="#1-面向资源的编程思想只适合做CRUD-只有面向过程、面向对象编程才能处理真正复杂的业务逻辑" class="headerlink" title="1.面向资源的编程思想只适合做CRUD,只有面向过程、面向对象编程才能处理真正复杂的业务逻辑"></a>1.面向资源的编程思想只适合做CRUD,只有面向过程、面向对象编程才能处理真正复杂的业务逻辑</h5><p>其实，面向资源的编程思想与面向过程、面向对象编程思想，只是抽象问题时所处的立场不同，只有选择问题，没有高下之分：</p><ul><li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？当然是为符合计算机中主流的交互方式。</li><li>面向对象编程时，为什么要将数据和行为统一一起来、封闭成对象？当然是为符合现实民办的主流交互方式。</li><li>面向资源编程时，为什么要将数据作为抽象的主体，把行为看作是统一的接口，当然为是符合网络世界的主流交互方式。</li></ul><h5 id="2-REST与HTTP完全绑定，不适用于要求高性能传输的场景中"><a href="#2-REST与HTTP完全绑定，不适用于要求高性能传输的场景中" class="headerlink" title="2.REST与HTTP完全绑定，不适用于要求高性能传输的场景中"></a>2.REST与HTTP完全绑定，不适用于要求高性能传输的场景中</h5><p>REST的确依赖着HTTP协议的标准方法，状态码和协议头等，但我们要明确一个前提，HTTP协议是应用层协议，而不是传输层协议，如果在应用层协议追求传输效率，有点买椟还珠的意思。</p><h5 id="3-REST不利于事务支持"><a href="#3-REST不利于事务支持" class="headerlink" title="3.REST不利于事务支持"></a>3.REST不利于事务支持</h5><p>对事务的理解不一一致的话，在这块歧义也会比较大。<br>刚性ACID事务，<br>分布式事务。<br>最终一致性事务</p><h5 id="4-REST没有传输可靠性支持"><a href="#4-REST没有传输可靠性支持" class="headerlink" title="4.REST没有传输可靠性支持"></a>4.REST没有传输可靠性支持</h5><p>REST的可靠性需要很多其他策略的配合，比如重试机制、幂等机制</p><h5 id="5-REST缺乏对资源进行“部分”和“批量”的处理能力"><a href="#5-REST缺乏对资源进行“部分”和“批量”的处理能力" class="headerlink" title="5.REST缺乏对资源进行“部分”和“批量”的处理能力"></a>5.REST缺乏对资源进行“部分”和“批量”的处理能力</h5><p>这点还是挺有道理的，这可能也是未来面向资源思想和API设计风格发展的方向。<br>暂时的处理办法是：</p><ul><li>针对部分的应对手段是，通过位于中间节点或客户端缓存来缓解</li><li>针对整体，只能是再抽象出一些资源来应对。GraphQL就是一种解决批量操作类问题的解决方案，它是一种有协议地、更彻底地面向资源的服务方式。 </li></ul>]]></content>
    
    <summary type="html">
    
      来了解一下RESTful服务的相关知识
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="RESTful服务" scheme="https://by1way.github.io/tags/RESTful%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>09.RESTful服务</title>
    <link href="https://by1way.github.io/2021/04/24/09-RESTful%E6%9C%8D%E5%8A%A1/"/>
    <id>https://by1way.github.io/2021/04/24/09-RESTful服务/</id>
    <published>2021-04-24T04:44:51.000Z</published>
    <updated>2021-04-25T12:10:43.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="09-RESTful服务：从面向过程编程到面向资源编程"><a href="#09-RESTful服务：从面向过程编程到面向资源编程" class="headerlink" title="09.RESTful服务：从面向过程编程到面向资源编程"></a>09.RESTful服务：从面向过程编程到面向资源编程</h3><p>行文思路：</p><ol><li>RESTful与RPC不是同一类型的东西</li><li>RESTful该怎么理解</li><li>RESTful有什么特征</li><li>有什么优势</li></ol><p>另一种主流的远程服务访问风格：RESTful服务</p><h4 id="RESTful与RPC区别的本质"><a href="#RESTful与RPC区别的本质" class="headerlink" title="RESTful与RPC区别的本质"></a>RESTful与RPC区别的本质</h4><p>其实两者另不是同一类型的东西，充其量只能算是有一些相似。在应用中会有一些重合的地方，两者差异的核心是抽象的目标不一样，也就是面向资源与面向过程的编程思想的区别。</p><p>RESTful并不是一种远程调用协议。说到协议啊，一般是都有一定规范性和强制性的。但RESTful却什么都没有，所以只能说RESTful只是一种风格。而这种风格一般还挺难达到的</p><p>在使用范围上RPC和RESTful是两种主流的远程调用方式，在使用上确实有重合。</p><p>RESTful讨论的是架构风格与网络的软件架构设计，RPC只是一种远程服务调用的方式。这逼格明显不一样好不啦。</p><h4 id="对于RESTful的理解"><a href="#对于RESTful的理解" class="headerlink" title="对于RESTful的理解"></a>对于RESTful的理解</h4><p>Representational State Transfer ，表征状态转移。</p><p>ps:哇塞，太抽象了。什么表征，什么的状态，从哪转移到哪儿。这算是什么狗屁定义呀</p><p>等会再来管个定义吧。先来看看几个概念</p><ul><li>资源，什么是资源？我理解的经常在网上看到的一些信息呀，内容呀，都可以称为资源。如果你喜欢用浏览器看小说的话，就可以把显示小说内容看作是一个资源。</li><li>表征，哪什么表征就是什么呢？显示小说的网页就是一种表征形式啦。所谓的表征就是一种资源的表现形式而矣</li><li>状态，什么的状态？在特定语境下产生的上下文信息就是状态，比如你在读小说的时候一章读完了，点下一章的按钮。但服务器那知道你现在读的是哪一章呀，所以现在读的这一章就可以称为是一个状态</li><li>转移，了解了上面的资源、表征、状态的例子，那转移就好理解了，由服务端通过某种方式，把这一章转变成下一章，这就是表征状态转移了。</li></ul><p>这几个概念还是挺好理解的，别放松，接着再来三个概念</p><ul><li>统一接口，  URI的含义是统一资源标识符，是一个名词，如何让他表示出动词的含义呢？其实这些HTTP协议都给提供好了一套标准的接口，你肯定很熟悉：GET\POST\HEAD\PUT\DELETE\TRACE\OPTIONS，也就是说通过HTTP协议定义好的这些动作就可以让服务器乖乖的听话了，要什么给什么</li><li>超文本驱动，这个有点意思，我们都是通过浏览器来操作从而向服务端发送请求的，但是作为通用客户端的浏览器，它是不用管这些的，只是给我们提供一个地址栏而矣，那在打开一个网页之后，其它所有在网页的操作，都是由网页本身来控制的。那网页有什么链接，有什么按钮，也都是它自己说了算。而这些也都是属于超文本的内容，在这里我们都需要有这样一个思路的细化，不能觉得浏览器是万能的，它也只是一个通用的工具，做好自己通用的事儿就行了。</li><li>自描述，由于表征是多种多样的，要想让浏览器（客户端）了解服务器到底响应了点啥内容，这还得在响应的信息里标识出来。我们常见的Content-Type,就是干这事儿的。</li></ul><h4 id="RESTful风格的特征"><a href="#RESTful风格的特征" class="headerlink" title="RESTful风格的特征"></a>RESTful风格的特征</h4><h5 id="服务端与客户端分离"><a href="#服务端与客户端分离" class="headerlink" title="服务端与客户端分离"></a>服务端与客户端分离</h5><p>这一个特征可以参考，前后端分离架构来理解</p><h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>REST不希望服务端维护状态，每次请求包含必要的上下文信息，会话由客户端保存，服务端根据客户状传递的状态信息进行处理，并驱动整个应用状态变迁</p><h5 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h5><p>由于无状态，所以每次请求都得带上大量的冗余信息，为了解决这个问题，提出的这么一个特征，也是一个用于提升响应性能的手段</p><h5 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h5><p>客户端一般不需要知道是否直接连接到了最终的服务器，或者是连接到路径上的中间服务器</p><h5 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h5><p>REST希望开发者可以面向资源来编程，希望软件系统的设计重点放在对抽象系统该有哪些资源上，而不是哪些行为上。一般来说面向资源的抽象程度通常比较高。<br>ps:我觉得这块一可以结合，软件的复杂度，以及领域驱动设计来理解。这样大家就不再纠结为什么抽象资源比面向过程更有优势这一点了。架构设计的本质，是降低软件复杂度再来的影响，那咋降低呢？把变化控制来一个小的范围内，这是一个思路。<br>那怎么才能在架构设计中合理恰当地利用统一接口呢？RESTful的提出者，Fielding 给出了三个建议</p><ul><li>第一，系统要能做到每次请求中都包含资源的 ID，所有操作均通过资源 ID 来进行；</li><li>第二，每个资源都应该是自描述的消息；</li><li>第三，通过超文本来驱动应用状态的转移。<h5 id="按需编码"><a href="#按需编码" class="headerlink" title="按需编码"></a>按需编码</h5>任何按照客户端（如浏览器）的请求，将可执行的软件程序从服务器发送到客户端的技术</li></ul><h4 id="面向资源设计有什么好处呢？"><a href="#面向资源设计有什么好处呢？" class="headerlink" title="面向资源设计有什么好处呢？"></a>面向资源设计有什么好处呢？</h4><ol><li>降低服务接口的学习成本</li><li>资源天然具有集合与层次结构：以方法为中心抽象的接口，由于方法是动词，逻辑上决定了每个接口都是互相独立的；但以资源为中心抽象的接口，由于资源是名词，天然就可以产生集合与层次结构。</li><li>REST绑定于HTTP协议</li></ol>]]></content>
    
    <summary type="html">
    
      来了解一下RESTful服务的相关知识
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="RESTful服务" scheme="https://by1way.github.io/tags/RESTful%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://by1way.github.io/2021/03/31/32-point/"/>
    <id>https://by1way.github.io/2021/03/31/32-point/</id>
    <published>2021-03-31T08:21:12.448Z</published>
    <updated>2021-03-31T10:06:51.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统与计算机网络"><a href="#操作系统与计算机网络" class="headerlink" title="操作系统与计算机网络"></a>操作系统与计算机网络</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><img src="/2021/03/31/32-point/32-point_files/1.jpg" alt="操作系统"></p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ol><li>进程与线程的区别和联系<ul><li>进程是系统资源分配的最小单位，线程是程序执行的最小单位</li><li>进程使用独立的数据空间，而线程共享进程的数据空间</li></ul></li><li>线程调度，线程的几种调度算法<ul><li>时间片轮转算法</li><li>先来先服务调度</li><li>优先级调度</li><li>多级反馈队列调度</li><li>高响应比优先调度</li></ul></li><li>线程切换步骤，线程上下文切换，线程切换的代价</li><li>进程间通信，IPC,6种进程通信方式的原理与适用场景。<ul><li>进程间数据共享的场景可以使用共享内存</li><li>进程间数据交换的场景可以使用Unix Socket或消息队列</li></ul></li><li>协程，协程更加轻量化，是在用户态调度，切换的代价比线程上下文切换要低很多，Java的第三方协程框架，Kilim、Quasar</li></ol><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><ul><li>AWK：处理文本文件的语言，是一个很强大的文件分析工具</li><li>Top</li><li>netstat</li><li>grep</li></ul><h4 id="扩展知识点（待补充）"><a href="#扩展知识点（待补充）" class="headerlink" title="扩展知识点（待补充）"></a>扩展知识点（待补充）</h4><ul><li>内存分页管理</li><li>Swap机制</li><li>任务队列</li><li><p>CPU Load</p></li><li><p>内存屏障</p></li><li>指令乱序</li><li>分支预测</li><li>NUMA</li><li>CPU亲和性</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><img src="/2021/03/31/32-point/32-point_files/2.jpg" alt="计算机网络"></p><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p>网络的4/7层模型</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><ol><li>HTTP协议规范，Method、Header、Cookies,常见的状态码含义，404 502 503</li><li>HTTPS的交互流程</li><li>HTTP2多路复用、Stream流式交互，流量控制 、服务端推送、头部压缩等新特性</li></ol><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ol><li>三次握手建立连接</li><li>四次挥手断开连接</li><li>TCP的报文状态标志和链接状态</li><li>Nagel算法和ACK延迟，产生的背景，要解决小包问题，提高数据载荷比，对延迟比较敏感且发送数据频率低的场景可以关闭Nagel算法</li><li>TCP的KeepAlive,是一种长时间没有数据发送的场景下，TCP保持链接可用的机制，TCP KeepAlive开启和设置的方式</li><li>TCP是如何通过滑动窗口机制来实现流量控制的</li></ol><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>非链接、非可靠传输、效率非常高</p><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>QUIC已被标准化为HTTP3协议，QUIC基于UDP协议，但QUIC提供了类似TCP的可靠性保证和流量控制，有效的避免了HTTP2协议的前序包阻塞的问题<br>能实现零RTT建连，提供FEC前向纠错能力。这是什么鬼一点都看不懂呀</p><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h3><p>TCP是传输层协议，对应OSI网络模型的第四层传输层，特点如下：</p><ul><li>TCP协议是基于链接的，也就是传输数据前需要先建立 好链接，然后再进行传输</li><li>TCP链接一旦建立 ，就可以在链接上进行双向的通信</li><li>TCP的传输是基于字节流而不是报文，将数据按字节大小进行编号 ，接收端通过ACK来确认收到的数据编号 ，通过这种机制，TCP协议能够保证接收数据 的有序性和完整性，因此TCP能够提供可靠性的传输</li><li>TCP还能提供流量控制能力，通过滑动窗口来控制 数据的发送速率，滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力在TCP的Header中动态调整窗口的大小，通过ACK应答包通知给发送端，发送端根据窗口大小调整发送的速度</li><li>仅仅有流量控制 能力还不够，TCP协议还考虑到网络问题可能会导致大量重传，进而导致网络情况进一步恶化，因此TCP协议还提供了拥塞控制 ，TCP处理拥塞控制 主要用到慢启动，拥塞避免、拥塞发生、快速恢复四个算法</li></ul><p>特定场景下，Nagel和ACK延迟机制配合使用可能会出现delay40ms超时后才回复ACK包的问题</p><h4 id="三次握手建连"><a href="#三次握手建连" class="headerlink" title="三次握手建连"></a>三次握手建连</h4><p>TCP是基于链接的，所以在传输数据前需要先建立链接，TCP在传输上双工传输，不区分Client端与Server端，我们把主动发起建连请求的一端称作Client端，把被动态建立链接的一端称作Server端<br><img src="/2021/03/31/32-point/32-point_files/3.jpg" alt="三次握手"></p><ol><li>首先建立 链接前需要Server端先监听端口，因此Server端建立 链接前的初始状态就是LISTEN状态，这时Client端准备建立链接，先发送一个SYN同步包，发送完同步包后，Client端的链接状态就变成了SYN_SENT状态.Server端收到SYN后，同意建立链接，会向Client端回复一个ACK。</li><li>由于TCP是双工传输，Server端也会同时向Client端发送一个SYN,申请 Server向Client方向建立链接，发送完ACK和SYN后，Server端链接状态就变成了SYN_RCVD.</li><li>Client收到Server的ACK后，Client端的链接状态就变成ESTABLISHED状态，同时Client向Server端发送ACK,回复Server端的SYN请求。</li><li>Server端收到Client端的ACK后，Server端的链接状态也就变成了ESTABLISHED状态，此时建连完成，双方随时可以进行数据传输。</li></ol><p>SYN洪水攻击发生的原因，就是Server端收到Client端的SYN请求后，发送了ACK和SYN,但是Client端不进行回复，导致Server端大量的链接处在SYN_RCVD状态，进而影响其他正常请求的建连。可以通过设计tcp_synack_retries=0 加快半链接的回收速度，或者调大tcp_max_syn_backlog来应对少量的SYN洪水攻击 。</p><h4 id="四次挥手断连"><a href="#四次挥手断连" class="headerlink" title="四次挥手断连"></a>四次挥手断连</h4><p><img src="/2021/03/31/32-point/32-point_files/4.jpg" alt="四次挥手断连"></p><p>TCP 链接的关闭通信双方都可以先发起，我们暂且把先发起的一方看作 Client。</p><ol><li>通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态，然后 Client 先主动发起了关闭链接请求，Client 向 Server 发送了一个 FIN 包，表示 Client 端已经没有数据要发送了，然后 Client 进入了 FIN_WAIT_1 状态。</li><li>Server 端收到 FIN 后，返回 ACK，然后进入 CLOSE_WAIT 状态。此时 Server 属于半关闭状态，因为此时 Client 向 Server 方向已经不会发送数据了，可是 Server 向 Client 端可能还有数据要发送。</li><li>当 Server 端数据发送完毕后，Server 端会向 Client 端发送 FIN，表示 Server 端也没有数据要发送了，此时 Server 进入 LAST_ACK 状态，就等待 Client 的应答就可以关闭链接了。</li><li>Client 端收到 Server 端的 FIN 后，回复 ACK，然后进入 TIME_WAIT 状态。TIME_WAIT 状态下需要等待 2 倍的最大报文段生存时间，来保证链接的可靠关闭，之后才会进入 CLOSED 关闭状态。而 Server 端收到 ACK 后直接就进入 CLOSED 状态。</li></ol><p>Q:为什么需要等待2倍最大报文段生存时间之后再关闭链接？</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据段从网络中消息，防止端口被重用时可能产生的数据混淆</li></ul><p>从这个交互流程可以看出，无论是建连还是断链，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK。这就是建连三次握手而断链需要四次的原因。 </p><p>实际应用中有可能遇到大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态的问题。一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作系统与计算机网络&quot;&gt;&lt;a href=&quot;#操作系统与计算机网络&quot; class=&quot;headerlink&quot; title=&quot;操作系统与计算机网络&quot;&gt;&lt;/a&gt;操作系统与计算机网络&lt;/h2&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>08.远程服务调用</title>
    <link href="https://by1way.github.io/2021/03/07/08-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <id>https://by1way.github.io/2021/03/07/08-远程服务调用/</id>
    <published>2021-03-07T03:44:51.000Z</published>
    <updated>2021-03-17T11:37:54.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周志明架构课-架构师视角"><a href="#周志明架构课-架构师视角" class="headerlink" title="周志明架构课-架构师视角"></a>周志明架构课-架构师视角</h2><h3 id="08-远程服务调用：如何选择适合自己的RPC框架"><a href="#08-远程服务调用：如何选择适合自己的RPC框架" class="headerlink" title="08.远程服务调用：如何选择适合自己的RPC框架"></a>08.远程服务调用：如何选择适合自己的RPC框架</h3><p>这一篇先来个图图：</p><p><img src="/2021/03/07/08-远程服务调用/08/08.png" alt="如何选择适合自己的RPC框架？"></p><p>今天就看图说话啦。</p><p>大家先想一下，世面上有很多的RPC框架，各种讲解RPC框架的教程，大家也都是有一个学一个。今天学学dubbo，明天学学gRPC的，那这些RPC都有什么共性吗？为什么会有这么多RPC呢？为什么没有一个通用的RPC框架呢？这些问题是不是大家也都想过，不过存在即有理，接下来我们就从RPC最核心的内容来看看，这些问题有没有一个答案。</p><h4 id="RPC要解决什么问题？"><a href="#RPC要解决什么问题？" class="headerlink" title="RPC要解决什么问题？"></a>RPC要解决什么问题？</h4><p>看到这问题是不是有点懵圏了。RPC要解决什么问题？不就是解决远程服务通讯的问题吗？不是的这个问题的意思就是要想从0开发一个RPC，都需要解决什么问题。</p><h5 id="1-数据如何表示"><a href="#1-数据如何表示" class="headerlink" title="1. 数据如何表示"></a>1. 数据如何表示</h5><p>​    首先就是解决数据表示的问题，什么意思呢？各个语言各种操作系统都有不小的差异那怎么才能保证数据在源和在目标表示 的意义是一样的呢。这说的也就是数据如何表示 的意思了。再具体一点就是参数、返回值之类的这些玩艺儿。</p><p>​    在明确了问题之后，是不是得想办法解决了，有什么好的解决思路呢？单纯依靠某一方肯定是不行的，至少不公平也会产生不少的纠纷。那好吧，映射到现实社会中，自然而然就是找一个大家都看好的第三方喽。不是玩笑，真的是这么个思路。</p><p>​    因为RPC发展现在已经有很多成熟的方案的了。像gRPC的ProtocolBuffer ，web service的XML Serialization,以及很多轻量级RPC的Json Serialization都可以拿得出手的</p><h5 id="2-数据如何传输"><a href="#2-数据如何传输" class="headerlink" title="2. 数据如何传输"></a>2. 数据如何传输</h5><p>​    既然数据怎么表示这事儿咱们想明白了，那数据的传输过程又该是怎么样的呢？肯定不会是只搞一个序列化的数据流扔给底层传输协议就完事儿了，这里面需要考虑的东西太多了，像超时了怎么办，发生了异常怎么处理，安全认证怎么搞等等方面都是需要考虑的因素，不过既然能把数据如何表示这件事交给第三方，那第三方肯定也是提供了大量的解决办法的，提一个大家都比较熟悉的SOAP,它就能把这件事处理的明明白白的。</p><h5 id="3-方法如何表示"><a href="#3-方法如何表示" class="headerlink" title="3. 方法如何表示"></a>3. 方法如何表示</h5><p>​    这这这，又得解释一下了。先来对比一下本地方法的调用，本地调用某个方法，编译器会直接帮助我们把要调用的方法转换成内存中方法的入口地址，发生调用的时候你直接按顺序执行就ok了。那一换成远程调用，这点优势突然间就没了。那该怎么破呢？要不给每个方法编个号？也是一种办法哈。但更加靠谱的方法还是得搞一套与程序语言无关的接口描述语言（IDL），像WSDL,JSON-WSP都是基于这个参考这个方法来处理的。</p><h4 id="统一的RPC搞法"><a href="#统一的RPC搞法" class="headerlink" title="统一的RPC搞法"></a>统一的RPC搞法</h4><pre><code>怎么样，怎么样有没有发现一个问题，我好喜欢webservice那套产品呀，有了它岂不是也能一统江湖？用它来搞序列化、数据传输、接口描述，简直不能太美了。但是回过头来再瞅瞅WebService现在那副尿样子，真的是想完美想疯了，啥都很标准，啥都很规范。一点都不接地气，真正用过的人，想一想，它简单吗？它通用吗？它的性能好吗？其实通用方面我觉得做的还可以，如果大家都使用的话。可是它压根儿就没有把性能这事儿重视过哪怕一次。那你说说对得起现在这4G的网络，对得起互联网大厂飞速发展吗？更别提5G了。</code></pre><p>​    搞不成啊，搞不成。</p><p>​    不过说实话，要说把简单、通用、性能都完美的结合在一起真的不是那么容易的。</p><h4 id="RPC又要分裂了"><a href="#RPC又要分裂了" class="headerlink" title="RPC又要分裂了"></a>RPC又要分裂了</h4><p>​    既然Web service没戏了，大家就都取多长吧。这个时候各种RPC框架就开始hi了。什么RMI、Thrift、Dubbo、gRPC等等，发展的猛的很。发展归发展，虽然很多都是在重复造轮子，但大部分都还是很有方向的，有注重性能的、有注重简单的，还有注重通用的，但是大家都不会把追求完美做为首要目标了。</p><p>​    典型的发展方向，有这么几个：</p><ul><li>朝着面向对象发展的，比如RMI、.net Remoting，不用说这一派也是朝着通用发展</li><li>朝着性能方向发展的，比如gRPC、Thrift,就是使劲儿的优化。</li><li>朝着简化方向发展的，比如JSON-RPC，没别的就是简单。</li><li>还有更不要脸的，朝着整合方向发展，我自己有各种组件，诶，但我也允许 你用其他RPC的组件。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    总结一下吧，RPC要解决的三个问题是所有RPC框架都需要面临的问题，简单、通用、性能三个方面，不同的要求也有各自成熟的产品，你可以结合自己的需求选择最合适的那个，总有一款适合你。</p>]]></content>
    
    <summary type="html">
    
      远程服务调用
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="远程服务调用" scheme="https://by1way.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>07.远程服务调用</title>
    <link href="https://by1way.github.io/2021/02/07/07-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <id>https://by1way.github.io/2021/02/07/07-远程服务调用/</id>
    <published>2021-02-07T03:44:51.000Z</published>
    <updated>2021-03-16T10:29:04.487Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，可能是因为我的理解能力有点小问题，这篇文章读了好几遍才大概明白了点其中的道道。为了防止大家跟我一样学习的时候会晕菜。所以我决定先把作者的行文思路给大家画出来。</p><p><img src="/2021/02/07/07-远程服务调用/architect_files/0701.png" alt="file00"></p><ol start="0"><li>介绍了下架构师的职责</li><li>RPC在众眼里是什么样的呢？为什么一直这么火呢</li><li>借用本地调用过程的例子来引入，同时做出假设调用者和被调用者不在同一个进程之内</li><li>解决上面步骤2问题的方法，有六种。尤其是最后一种本地套接字接口，它的设计理念简直直RPC最初的目的不谋而合</li><li>但在那个时候对于透明的分布式系统而言，别说存在着大量的问题需要解决的，就连认识上都存在大量误解。</li><li>最终，施乐公司的Palo Alto研究中心，发布了第一个基于RPC的应用，并正式提出了RPC的概念。</li></ol><p>​    在这篇文章中有几个提法比较有意思：比如RPC作为分布式前置的基础条件，再比如RPC应该是一种高层次的，或者说语言层次的特征，而不是像IPC那样，是低层次的，或者说系统层次的特征；还有RPC以模拟进程间方法调用为起点，许多思想和概念都借鉴的是IPC，都能给人耳目一新的感觉。</p><p>好了下面咱们开始正式的内容：</p><h4 id="0-架构师的职责"><a href="#0-架构师的职责" class="headerlink" title="0. 架构师的职责"></a>0. 架构师的职责</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">什么架构师呢？</span><br><span class="line">有做企业战略设计的架构师，有做业务流程分析的架构师……</span><br><span class="line">在这里呢？特指软件系统中技术模型的设计者。</span><br><span class="line"></span><br><span class="line">架构师工作的三个问题？</span><br><span class="line">* 做架构设计的时候，架构师都应该思考哪些问题呢？</span><br><span class="line">* 都可以选择哪些主流的解决方案和行业标准做法呢？</span><br><span class="line">* 以及这些方案都有什么优缺点，都会给架构设计带来什么影响呢？</span><br></pre></td></tr></table></figure><h4 id="1-大众眼中的RPC（远程服务调用）？"><a href="#1-大众眼中的RPC（远程服务调用）？" class="headerlink" title="1.大众眼中的RPC（远程服务调用）？"></a>1.大众眼中的RPC（远程服务调用）？</h4><p>关于RPC三个小问题：</p><pre><code>1. RPC本身可以解决什么问题呢 2. 这些问题又是怎么被解决的呢？ 3. 为什么要这样解决呀</code></pre><p>RPC为什么这么火热的原因：</p><ul><li>可能是微服务风潮带来的热度</li><li>作为开发者，我们很多人对RPC本身可以解决什么问题、如何解决这些问题、为什么要这样解决，都或多或少存在些认知模糊的情况</li></ul><h4 id="2-本地方法调用"><a href="#2-本地方法调用" class="headerlink" title="2. 本地方法调用"></a>2. 本地方法调用</h4><p>​    本地方法调用几个概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者（Caller）      ： main()</span></span><br><span class="line"><span class="comment">// 被调用者（Callee）      ： println()</span></span><br><span class="line"><span class="comment">// 调用点（Call Site）   ： 发生方法调用的指令流位置</span></span><br><span class="line"><span class="comment">// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即“hello world”</span></span><br><span class="line"><span class="comment">// 返回值（Retval）      ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做一个假设：如果在调用println()的时候，发现它并不在当前内存地址空间中，又会出现什么问题呢？</p><ol><li>前面的传递参数、传回结果都依赖于栈内存的帮助，如果Caller与Callee分属不同的进程，就不会拥有相同的栈内存，那么在Caller进程的内存中将参数压栈，对于Callee进程的执行毫无意义。</li><li>println()方法版本选择依赖于语言规则的定义，而如果Caller与Callee不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。</li></ol><p><strong>如何解决两个进程间通讯的问题问题：</strong></p><pre><code>1. 管道（Pipe）或具名管道（Named Pipe）: 管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。2. 信号（Signal）: 信号是用来通知目标进程有某种事件发生的。除了用于进程间通信外，信号还可以被进程发送给进程自身。信号的典型应用是kill命令，比如“kill -9 pid”，意思就是由Shell进程向指定PID的进程发送SIGKILL信号。 3. 信号量（Semaphore）:信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行wait()和notify()操作。 4. 消息队列（Message Queue）:进程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点 ，但实时性相对受限。 5. 共享内存（Shared Memory）: 允许多个进程可以访问同一块内存空间，这是效率最高的进程间通讯形式。进程的内存地址空间是独立隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的接口。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。 6. &lt;font color=&quot;red&quot;&gt;本地套接字接口（IPC Socket）: 消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。&lt;/font&gt;</code></pre><h4 id="3-竟然不谋而合"><a href="#3-竟然不谋而合" class="headerlink" title="3.竟然不谋而合"></a>3.竟然不谋而合</h4><p>​    RPC可以作为IPC的一种特例来看待。</p><p>​    IPC Socket是操作系统提供的标准接口，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到远程调用与本地方法调用几乎完全<strong>一致</strong>。</p><p>​    <strong>还记得远程服务调用最初的目的吗？</strong>与调用本地方法<strong>一致</strong>。</p><h4 id="4-透明RPC调用存在的问题"><a href="#4-透明RPC调用存在的问题" class="headerlink" title="4.透明RPC调用存在的问题"></a>4.透明RPC调用存在的问题</h4><ul><li>两个进程通讯，谁作为服务端，谁作为客户端？</li><li>怎样进行异常处理？异常该如何让调用者获知？</li><li>服务端出现多线程竞争之后怎么办？</li><li>如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？是否支持多播？</li><li>参数、返回值如何表示？应该有怎样的字节序？</li><li>如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？</li><li>服务端发送请求后，收不到回复该怎么办？</li></ul><p>​    <strong>分布式运算的八宗罪：</strong></p><ol><li>网络是可靠的（The network is reliable）</li><li>延迟是不存在的（Latency is zero ）</li><li>带宽是无限的（Bandwidth is infinite）</li><li>网络是安全的（The network is secure）</li><li>拓扑结构是一成不变的（Topology doesn’t change）</li><li>总会有一个管理员（There is one administrator）</li><li>不考虑传输成本（Transport cost is zero）</li><li>网络是同质化的（The network is homogeneous）</li></ol><h4 id="5-RPC的概念"><a href="#5-RPC的概念" class="headerlink" title="5.RPC的概念"></a>5.RPC的概念</h4><p>​    传奇的施乐Palo Alto研究中心，发布了基于Cedar语言的RPC框架Lupine，并实现了世界上第一个基于RPC的商业应用Courier。并提出了RPC的概念，也就我们今天看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机）</span><br></pre></td></tr></table></figure><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“远程方法不应该无视通讯成本”这个观点，从性能的角度来看是有益的，但从简单的角度看则是有害的。在现代的软件系统开发中，你用过什么RPC框架吗？它们有没有把“像本地方法一样调用远程方法”作为卖点？</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      远程服务调用
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="远程服务调用" scheme="https://by1way.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>06.无服务时代：不分布式云端系统的起点</title>
    <link href="https://by1way.github.io/2021/02/07/06-%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/06-无服务时代的探索/</id>
    <published>2021-02-07T03:34:51.000Z</published>
    <updated>2021-03-16T09:54:03.329Z</updated>
    
    <content type="html"><![CDATA[<p>分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。分布式架构也会引入一些新问题（比如服务的安全、容错，分布式事务的一致性），因此对软件开发这件事儿来说，不去做分布式无疑是最简单的。</p><p>云计算的成功其实已经实现了相对意义上无限性能。</p><p>对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，AWS、阿里云等云服务提供商都能在算力上满足系统对性能的需求，只要你能为这种无限的性能支付得起对应的代价。这样”无服务“概念也就产生了。</p><h4 id="无服务架构特点"><a href="#无服务架构特点" class="headerlink" title="无服务架构特点"></a>无服务架构特点</h4><ul><li>后端设施，指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“<strong>后端即服务</strong>”</li><li>函数，指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划，也就是无服务中的“<strong>函数即服务</strong>”</li></ul><h4 id="无服务的愿景"><a href="#无服务的愿景" class="headerlink" title="无服务的愿景"></a>无服务的愿景</h4><ol><li>不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼</li><li>不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成</li><li>不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的</li><li>也不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任</li></ol><p>虽然无服务架构的远期前景也许很美好，但无服务中短期内的发展，并没有那么乐观。为什么这么说呢？ 与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式。所以除非是有重大变革，否则它也很难具备普适性。</p><h4 id="无服务架构的局限性"><a href="#无服务架构的局限性" class="headerlink" title="无服务架构的局限性"></a>无服务架构的局限性</h4><p>​    无服务天生“无限算力”的假设，就决定了它必须要按使用量（函数运算的时间和内存）来计费，以控制消耗算力的规模，所以函数不会一直以活动状态常驻服务器，只有请求到了才会开始运行。这导致了函数不便于依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能会太好。</p><p>前面第一节讲到，在首次对分布式的探索失败之后，大型软件的发展出现了两个方向，一个是以分布式为基础的探索，另一个以不分布式为目的的探索。如果说服务网格是在分布式道路上的探索的最新方向，那无服务架构就是在不分布式这条道路上的努力 。但这两条路线的边界也是越来越模糊，最终将会在云端的数据中心处交汇。</p><p><strong>需要注意的是：无服务和微服务、云原生并没有继承替代的关系，因此也不能有无服务比微服务更加先进的想法</strong></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>是否了解、接触过无服务架构？无服务目前在中国处于起步的发展阶段，阿里云、腾讯云的无服务计算框架，都给了普通用户相当大的免费额度，你愿意去试一下吗？</p>]]></content>
    
    <summary type="html">
    
      无服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="无服务时代" scheme="https://by1way.github.io/tags/%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>05.后微服务时代：跨越软件与硬件之间的界限</title>
    <link href="https://by1way.github.io/2021/02/07/05-%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/05-后微服务时代的探索/</id>
    <published>2021-02-07T02:44:51.000Z</published>
    <updated>2021-03-16T09:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>抛开微服务架构，先看看下面几个问题的解决思路：</p><ul><li>如果某个系统需要伸缩扩容，我们通常会购买新的服务器，多部署几套副本实例来分担压力；</li><li>如果某个系统需要解决负载均衡的问题，我们通常会布置负载均衡服务器，并选择恰当的均衡算法来分流；</li><li>如果需要解决安全传输的问题，我们通常会布置TLS传输链路，配置好CA证书，以保证通讯不被窃听篡改；</li><li>如果需要解决服务发现的问题，我们通常会设置DNS服务器，让服务访问依赖稳定的记录名而不是易改变的IP地址等等</li></ul><p>从上面的几个问题，我们就可以发现这些问题已经大多都有了专职的基础设施来帮助解决了，那为什么微服务还必须在应用层面上去解决这问题呢？</p><p>原因就在于：<font color="red">因为硬件构成的基础设施，跟不上软件构成应用服务的灵活性。</font></p><p>既然软件可以通过命令就可以拆分出不同的服务，那么硬件不可以吗？这就到云原生的时代，<strong>微服务时代所取得的成就，本身就离不开以Docker为代表的早期容器化技术的巨大贡献</strong>。</p><p>近些年蓬勃发展的Kubernetes，可以说是开启了下一个软件架构发展的新纪元。对比下Spring Cloud中提供的应用层面的解决方案，Kubernetes也从基础设施层面给出它的解决方案，而且还是一条全新的、前途更加广阔的解题思路。虽然这一切看起来都很美好，但是从功能灵活性的特点上来，Kubernetes还不如Spring Cloud方案。因为从基础设施层面上很精细化解决一些边缘化的问题（比如做服务熔断）。因为基础设施针对的是整个容器做整体的管理，它的粒度相对来说比较粗犷。</p><p>所以微服务的基础设施再次进化，就引出了叫做服务网格的”边车代理模式“。</p><h4 id="边车代理模式"><a href="#边车代理模式" class="headerlink" title="边车代理模式"></a>边车代理模式</h4><p>微服务基础设施会由系统自动地在服务的资源容器（指Kubernetes的Pod）中注入一个通讯代理服务器（相当于那个挎斗），用类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄悄接管掉应用的所有对外通讯。 这个代理除了会实现正常的服务调用以外（称为数据平面通讯），同时还接受来自控制器的指令（称为控制平面通讯），根据控制平面中的配置，分析数据平面通讯的内容，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。 这样，就实现了既不需要在应用层面附带额外的代码，也提供了几乎不亚于应用代码的精细管理能力的目的。</p><p>代表性技术：Istio、Envoy</p><p>新技术发展时间比较短，还没有完全成熟起来。但未来可期</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>分布式架构发展到服务网格后，真的是到达“最好的时代”了吗？软件架构的发展不太可能真的就此止步，你认为今天的云原生还有哪些主要矛盾，下一次软件架构的进化将会主要解决什么问题？</p>]]></content>
    
    <summary type="html">
    
      后微服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="后微服务时代" scheme="https://by1way.github.io/tags/%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>04.微服务时代：SOA的革命者</title>
    <link href="https://by1way.github.io/2021/02/07/04-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/04-微服务时代的探索/</id>
    <published>2021-02-07T02:34:51.000Z</published>
    <updated>2021-03-16T09:54:11.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="red">微服务最早被提出是作为SOA的一种轻量化的补救方案而被提出来的</font></strong></p><h4 id="微服务的概念"><a href="#微服务的概念" class="headerlink" title="微服务的概念"></a>微服务的概念</h4><p>微服务是一种通过多个小型服务的组合，来构建的单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的存储技术、运行在不同的进程之中。服务会采用轻量级的通讯机制和自动化的部署机制来实现通讯与运维。</p><h4 id="九个核心业务与技术特征"><a href="#九个核心业务与技术特征" class="headerlink" title="九个核心业务与技术特征"></a>九个核心业务与技术特征</h4><h5 id="1-围绕业务能力构建"><a href="#1-围绕业务能力构建" class="headerlink" title="1. 围绕业务能力构建"></a>1. 围绕业务能力构建</h5><p>​    有怎样的结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。</p><h5 id="2-分散治理"><a href="#2-分散治理" class="headerlink" title="2.分散治理"></a>2.分散治理</h5><p>​    微服务开发团队有着直接对服务运行质量负责的责任，也应该有不受外界干预，掌控服务各方面能力的权力，能选择与其他服务异构的技术来实现自己的服务。</p><h5 id="3-通过服务来实现独立自治的组件"><a href="#3-通过服务来实现独立自治的组件" class="headerlink" title="3.通过服务来实现独立自治的组件"></a>3.通过服务来实现独立自治的组件</h5><p>​    通过远程服务而非类库来提供功能，从而得到组件的隔离与自治能力。</p><h5 id="4-产品化思维"><a href="#4-产品化思维" class="headerlink" title="4.产品化思维"></a>4.产品化思维</h5><p>​    避免把软件开发看作是要去完成某种功能，而是要把它当作是一种持续改进、提升的过程</p><h5 id="5-数据去中心化"><a href="#5-数据去中心化" class="headerlink" title="5.数据去中心化"></a>5.数据去中心化</h5><p>​    数据应该按领域来分散管理、更新、维护和存储。有时候一致性问题也可能是必须要付出的代价</p><h5 id="6-轻量级通讯机制"><a href="#6-轻量级通讯机制" class="headerlink" title="6.轻量级通讯机制"></a>6.轻量级通讯机制</h5><p>​    如果服务需要上面的某一种功能或能力，那就应该在服务自己的Endpoint上解决，而不是在通讯管道上一揽子处理。RESTful风格的通讯方式，在微服务中就是比较适合的。</p><h5 id="7-容错性设计"><a href="#7-容错性设计" class="headerlink" title="7.容错性设计"></a>7.容错性设计</h5><p>​    承认服务会出错，接收服务总会出错的现实。有了这个认识的前提，在设计微服务的时候就要求有自动的机制能对其依赖的服务进行快速的故障检测，持续出错的时候可以进行自动的隔离，在服务恢复好之后重新联通。</p><p>​    <strong><font color="red">可靠的系统由不会出错的服务来组成，这就是微服务最大的价值所在</font></strong></p><h5 id="8-演进式设计"><a href="#8-演进式设计" class="headerlink" title="8.演进式设计"></a>8.演进式设计</h5><p>​    承认服务会被淘汰。一个良好的设计，应该是能够报废的，而不是指望着它长久。</p><h5 id="9-基础设施自动化"><a href="#9-基础设施自动化" class="headerlink" title="9.基础设施自动化"></a>9.基础设施自动化</h5><p>​    服务一多，靠人工来运维这根本就是不可能的事情。所以会要依赖大量的基础设施来自动化完成</p><p>注意：以上9个是一个合理的微服务系统展示出来的内、外在表现，它能够指导你该如何应用微服务架构，而不能作为一种强加于系统中的束缚来看待。</p><p>这么自由的微服务理念咋不上天呢？以前提到的那个分布式问题就不存在了吗？还是得一个个的解决。于是各种技术框架纷纷出现。比如像Eureka、Consul、Nacos、Zookeeper、Etcd用来解决服务发现的技术、像Dubbo、Thrift、gRPC用来解决服务通讯的技术，真的是层出不穷。更甚至还有springcloud之类的全家桶，真的是给开发人员带来巨大的便利。</p><p>便对架构的要求也越来越高了。架构者如何在各种决策之间权衡能力也变得至关重要起来！</p><p><strong>那有没有一种即可以得到微服务自由的权力、还能专注于自己的业务，同时又不用费力去解决分布式带来的问题的解决方案呢？</strong></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>你所负责的产品是不是基于微服务的？如果是，它符合微服务的9个特征吗？如果不是，你的产品适合微服务架构吗？你所在的企业、团队适合引入微服务吗？</p>]]></content>
    
    <summary type="html">
    
      微服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="微服务时代" scheme="https://by1way.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>03.SOA时代：成功理论与失败实践</title>
    <link href="https://by1way.github.io/2021/02/07/03-SOA%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/03-SOA时代的探索/</id>
    <published>2021-02-07T02:20:51.000Z</published>
    <updated>2021-03-16T09:54:33.421Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em><font color="red">SOA架构是第一次被广泛使用过、通过分布式服务来构建信息系统的工程实践。它有完善的理论和工具，可以说，它解决了分布式系统中，几乎所有主要的技术问题</font></em></strong></p><p>所以本节就系统的讨论一下SOA的设计思想与原则，找找他为什么没有成功的原因？</p><h4 id="三种服务拆分架构模式"><a href="#三种服务拆分架构模式" class="headerlink" title="三种服务拆分架构模式"></a>三种服务拆分架构模式</h4><h5 id="1-烟囱式架构"><a href="#1-烟囱式架构" class="headerlink" title="1.烟囱式架构"></a>1.烟囱式架构</h5><p>​    前提：假设完全不会跟其他相关的信息系统之间进行协作</p><p>​    互不交互的系统，各自使用独立的数据库、服务器，即可以完成拆分。</p><p>​    问题就在于：不交互的系统（组织）真的存在吗？</p><h5 id="2-微内核架构"><a href="#2-微内核架构" class="headerlink" title="2.微内核架构"></a>2.微内核架构</h5><p>​    把一些公共的主数据：人员、组织 、权限等公用的服务、数据、资源，都集中到一块儿，成为被所有业务系统共同依赖的核心系统。</p><p>​    这种模式很适合桌面应用程序的开发，如果想实现一个能够支持二次开发的软件系统，微内核架构也是一种良好的架构模式。</p><p>​    问题在于：各业务系统不直接交互，（比如：支付系统和用户系统是独立的，但彼此会有业务的调用），这时需要找到一个办法，即能拆分出独立的系统，也能让拆分后的子系统之间可以顺畅的互相调用</p><h5 id="3-事件驱动架构"><a href="#3-事件驱动架构" class="headerlink" title="3.事件驱动架构"></a>3.事件驱动架构</h5><p><strong>为了能让子系统之间相互通讯，事件驱动架构就产生了</strong></p><p>它是这样的一张种模式：在子系统之间建立一套事件队列管道，来自系统外部的消息将以事件的形式发送管道中，各子系统可以从管道中获取自己感兴趣、可以处理的事件消息，也可以为事件新增或修改其中的附加信息，甚至还可以自己发布一些新的事件到管道队列中去。</p><p>同时SOAP协议的诞生，<strong><font color="red">事件驱动架构+SOAP协议==催生出=&gt;面向服务架构</font></strong></p><h4 id="SOA架构时代的探索"><a href="#SOA架构时代的探索" class="headerlink" title="SOA架构时代的探索"></a>SOA架构时代的探索</h4><h5 id="探索1：更具体"><a href="#探索1：更具体" class="headerlink" title="探索1：更具体"></a>探索1：更具体</h5><p>SOA本身还是属于一种抽象概念，而不是特指某一种具体的技术，但它比单体架构和烟囱式架构、微内核架构、事件驱动架构，都要更具可操作性，细节也充实了很多。所以，我们已经不能简单地把SOA看作是一种架构风格了，而是可以称之为一套软件架构的基础平台。</p><h5 id="探索2：更系统"><a href="#探索2：更系统" class="headerlink" title="探索2：更系统"></a>探索2：更系统</h5><p>SOA最根本的目标，就是希望能够总结出一套自上而下的软件研发方法论，让企业只需要跟着它的思路，就能够一揽子解决掉软件开发过程中的全套问题。比如，如何挖掘需求、如何将需求分解为业务能力、如何编排已有服务、如何开发测试部署新的功能，等等</p><p><strong>过于严格的规范定义，给架构带来了过度的复杂性</strong>，这也是Web Service衰落最本质的原因。</p><h4 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h4><p>你是否使用过SOA的方法论来开发软件系统呢？无论有还是没有，作为一个软件开发者，你是否愿意软件开发向着工业化方向发展，让软件类似工业产品制造那样，可以在规范、理论、工具、技术的支持下，以流水线的方式生产出来？</p><p>思考：还真的是使用过某国产的ESB开发一个项目，但是受限于项目的规模只是做了课题性质的研究。虽然配套设施都很齐全，但是用起却不并不那么的流畅，再加上当时思路受制于服务编排的困扰。好不容易把思路给理顺了，同时又被微服务给冲击了。如果软件开发朝着工业化的方向发展，听起来像是很美妙的事情，那样的话，软件的质量应该会有很大的提高。但是自己会不会被淘汰，软件的定制化（灵活性）怎么体现，软件开发的工作会不会朝着工具化的思路去发展，到处去写补丁。还有一个问题，工业化产出的东西都是一样的，就算再扩展一点可以满足可以提供各种参数来配置。那这个基础工具该有多复杂呀。</p>]]></content>
    
    <summary type="html">
    
      SOA时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="SOA时代" scheme="https://by1way.github.io/tags/SOA%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>02.单体系统时代</title>
    <link href="https://by1way.github.io/2021/02/07/02-%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/02-单体系统时代的探索/</id>
    <published>2021-02-07T02:14:51.000Z</published>
    <updated>2021-03-16T10:30:23.359Z</updated>
    
    <content type="html"><![CDATA[<p>应用最广泛的架构风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误的认知：</span><br><span class="line">架构无好坏，只能是根据场景来选择。</span><br><span class="line">典型的思维误区：</span><br><span class="line">单体架构是落后的系统架构风格，最终会被微服务所替代。</span><br><span class="line">观念的转变：</span><br><span class="line">不追求尽量不出错，而是应当正视出错是必然的，其实，这才是导致微服务开始逐步代替单体架构根本的驱动力。</span><br></pre></td></tr></table></figure><h4 id="1-大型单体系统"><a href="#1-大型单体系统" class="headerlink" title="1.大型单体系统"></a>1.大型单体系统</h4><p>也被称为巨石系统，把单体看作成是一种架构，确切的说是在微服务流行之后，才被追加的。</p><p>对于一个小型的系统来说，使用单体架构，易于开发，易于测试，易于部署，而且是进程内方法调用。</p><p><strong><em> 所以要想讨论单体系统的缺陷，必须要有一个前提：软件的性能需求超过了单机 所能处理的最大能力 </em></strong></p><p>题外话:当前市面上所有主流的IDE，也都是对单体架构支持最友好。</p><h4 id="2-可拆分的单体系统"><a href="#2-可拆分的单体系统" class="headerlink" title="2.可拆分的单体系统"></a>2.可拆分的单体系统</h4><ul><li>分层架构（纵向角度）</li><li>水平扩展（横向角度）多副本机制</li></ul><h4 id="3-非独立的单体"><a href="#3-非独立的单体" class="headerlink" title="3.非独立的单体"></a>3.非独立的单体</h4><p>​    在拆分 方面，单体系统真正的缺陷，实际上并不在于如何 拆分 ，而是在于拆分 之后它会存在隔离与自治能力上的欠缺。</p><p>以微服务去代替单体系统的原因：</p><pre><code>* 无法做故障隔离* 无法做到动态可维护* 无法做到技术异构* 不兼容phoenix特性（不死--&gt;能自治--&gt;可靠）</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/02/07/02-单体系统时代的探索/architect_files/image-20210216165550240.png" alt="image-20210216165550240"></p>]]></content>
    
    <summary type="html">
    
      单体系统时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="单体系统" scheme="https://by1way.github.io/tags/%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>01.原始分布式时代</title>
    <link href="https://by1way.github.io/2021/02/07/01/"/>
    <id>https://by1way.github.io/2021/02/07/01/</id>
    <published>2021-02-07T02:04:51.000Z</published>
    <updated>2021-03-16T10:30:43.834Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNIX设计哲学：</span><br><span class="line">保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性都来得更加重要。</span><br></pre></td></tr></table></figure><p>在这个阶段提出的分布式架构的目标：<font color="#FF0000">使用多个独立的分布式服务来共同构建出一个更大型的系统。</font>而这个目标，从历史的局限性就决定了他不可能 是一蹴而就的解决分布式系统中的难题。其中面临的最大问题就是：<font color="red">由于调用本地方法与调用远程方法的差别，如何像调用本地方法一样去调用远程方法</font></p><p>那“远程”二字代表了什么呢？</p><ol><li>首先不可能 用内联等传统编译原理中的优化算法，来提升运行速度</li><li>远程所带来的网络环境问题，包括：<ul><li>远程服务在哪里–&gt;<font color="red">服务发现</font></li><li>有多少个–&gt;<font color="red">负载均衡</font></li><li>网络出现分区，超时出错怎么办–&gt;<font color="red">熔断，隔离降级</font></li><li>方法参与返回结果如何表示 –&gt;<font color="red">序列化协议</font></li><li>如何传输–&gt;<font color="red">传输协议</font></li><li>服务权限怎么管理–&gt;<font color="red">认证授权</font></li><li>如何 保证通信安全–&gt;<font color="red">网络安全层</font></li><li>如何 令调用不同机器服务返回相同的结果–&gt;<font color="red">分布式数据一致性</font></li></ul></li></ol><p>针对大部分问题，DCE从0开始从无到有回答了其中大部分的问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在这个阶段采用分布式架构，为了解决上述各种问题，所付出的代价远远超过了所取得的收益。那接下来该如何发展呢？</p><ol><li>尽快提升单机处理能力，以避免分布式的种种问题</li><li>寻找更完美的解决方案，来应对上述在构筑分布式系统的问题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作只会自食其果</span><br></pre></td></tr></table></figure><p>行文思路：</p><p><img src="/2021/02/07/01/architect_files/image-20210216102359012.png" alt="image-20210216102359012"></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天以微服务为代表的分布式系统，是如何看待简单的？</span><br></pre></td></tr></table></figure><p>思考：</p><p>微服务所谓的简单，不管是从开发工具、开发形式亦或是运维上来看，都是在趋于看上去的简单。把复杂 留给 自己，简单留给别人。易开发、易部署、易扩展、易运维等等的说法。都在宣誓着把简单作为主要的原则 ，但背后所面临着诸如本节课所有的讨论的问题，都是需要一一关注，一一解决的。所以我觉得这里的简单并不是真正的简单。</p>]]></content>
    
    <summary type="html">
    
      原始分布式时代：Unix设计哲学下服务探索
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="原始分布式时代" scheme="https://by1way.github.io/tags/%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>00.慢慢的我来了</title>
    <link href="https://by1way.github.io/2021/02/07/00/"/>
    <id>https://by1way.github.io/2021/02/07/00/</id>
    <published>2021-02-07T02:00:51.000Z</published>
    <updated>2021-03-16T10:06:03.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于认识"><a href="#关于认识" class="headerlink" title="关于认识"></a>关于认识</h3><p>渐渐地认识到了自身很多不的足，做什么事情都没有长性。去年做了一件关于坚持的事情，参加了百日跑的活动。连续两届200天，每天跑步5公里。成绩什么的就都不重要，体重减少了多少也不重要。重要的是懂得了一些道理，养成了一些习惯。以前的自己想要的东西太多了，以至于什么事情都没有做太好。所以这次以自身的品性出发，慢慢地来。一点点来个，一个个来。坚持在缓慢中见识到真正的自己，我希望以后能够多多来看看自己内心深处的东西。</p><p>真正想要得到的是什么，多思考，多总结，多输出。</p>]]></content>
    
    <summary type="html">
    
      重启
    
    </summary>
    
      <category term="重启" scheme="https://by1way.github.io/categories/%E9%87%8D%E5%90%AF/"/>
    
    
      <category term="重启" scheme="https://by1way.github.io/tags/%E9%87%8D%E5%90%AF/"/>
    
  </entry>
  
  <entry>
    <title>事务处理一</title>
    <link href="https://by1way.github.io/2020/12/07/transaction1/"/>
    <id>https://by1way.github.io/2020/12/07/transaction1/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2021-01-06T05:59:47.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的意义"><a href="#事务的意义" class="headerlink" title="事务的意义"></a>事务的意义</h3><p>保证数据的正确性，不同的数据之间不会产生矛盾。也就是保证数据状态的一致性。</p><h3 id="讨论的范围"><a href="#讨论的范围" class="headerlink" title="讨论的范围"></a>讨论的范围</h3><p>数据库事务状态的一致性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 实现数据库事务状态一致性目标的前提</span><br><span class="line"></span><br><span class="line">* 原子性：在同一项业务处理中，事务保证对多个数据的修改要么都成功，要么都被撤销</span><br><span class="line">* 隔离性：在不同的业务处理过程中，事务保证各自读、写的数据互相独立，不会彼此影响</span><br><span class="line">* 持久性：事务应当保证所有被成功提交的数据修改，都能正确的持久化到数据库当中去，不会丢失数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```原子性、隔离性、持久性是手段，一致性是目标</span><br></pre></td></tr></table></figure></p><h3 id="关于事务处理的不场景"><a href="#关于事务处理的不场景" class="headerlink" title="关于事务处理的不场景"></a>关于事务处理的不场景</h3><ul><li>单个服务使用单个数据源</li><li>单个服务使用多个数据源</li><li>多个服务使用单个数据源</li><li>多个服务使用多个数据源</li></ul><h2 id="单个服务使用单个数据源"><a href="#单个服务使用单个数据源" class="headerlink" title="单个服务使用单个数据源"></a>单个服务使用单个数据源</h2><p>单个服务使用单个数据源，也就是本地事务场景，也可以叫作局部事务</p><h3 id="本地事务说明"><a href="#本地事务说明" class="headerlink" title="本地事务说明"></a>本地事务说明</h3><p>指仅操作特定单一事务资源的、不需要“全局事务管理器”参与协调的事务。</p><p>本地事务，依赖于数据源本身的事务能力来工作，我们常见的在程序代码中的事务也最多就是对事务接口进行的一层标准化包装。事务的开启、终止、提交、回滚、嵌套、设置隔离级别乃至与应用代码贴近的传播方式都需要依赖底层数据库的支持。</p><h3 id="ARIES理论"><a href="#ARIES理论" class="headerlink" title="ARIES理论"></a>ARIES理论</h3><p>Algorithms for Recovery and Isolation Exploiting  Semantics ，基于语义的恢复与隔离算法</p><p>当前主流关系性数据在事务实现上都受到该理论的影响。</p><h4 id="如何实现原子性和持久性"><a href="#如何实现原子性和持久性" class="headerlink" title="如何实现原子性和持久性"></a>如何实现原子性和持久性</h4><p>实现原子性和持久性最大的困难是什么？</p><p>写入磁盘这个操作不会是原子性，不仅存在写入、未写入，还存在“正在写”的中间状态。</p><p>这可咋办呀，怎么记录这个中间状态呢?日志？</p><h5 id="Commit-Logging"><a href="#Commit-Logging" class="headerlink" title="Commit Logging"></a>Commit Logging</h5><p>把日志顺序追加写入文件方式，记录到磁盘中。见到代表事务提交成功的Commit Record之后 ，数据库才根据日志上的信息对真实数据进行修改，修改完之后，在日志中再加入一条End Record,表示数据库已完成持久化。这种事务实现方法就是Commit Logging</p><p>Commit Logging，有几个切入的判断点：</p><ol><li>日志成功写了Commit Record表示事务成功了</li><li>如果发生了崩溃，看到Commit Record不完整，那就需要将已经提交Commit Record的记录回滚掉。</li></ol><p>Commit Logging的缺陷：<br><figure class="highlight plain"><figcaption><span>Record提交之后进行的。才不管你的磁盘I/O是否有空闲。别管有什么理由不能在事务提交之前就开始修改磁盘上的数据。```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">为了解决Commit Logging的缺陷，基于ARIES理论的&quot;Write Ahead Logging&quot;的日志改进方案就出现了</span><br><span class="line"></span><br><span class="line">##### Write Ahead Logging</span><br><span class="line"></span><br><span class="line">就是允许事务在提交之前，提前写入变动数据的意思。</span><br><span class="line"></span><br><span class="line">* FORCE:当事务提交后，要求变动数据必须同时完成写入则称为FORCE，如果不强制变动数据必须同时完成写入则称为NO-FORCE。现实中绝大多数数据库采用的都是NO-FORCE策略，只要有了日志，变动数据随时可以持久化，从优化磁盘I/O性能考虑，没有必要强制数据写入立即进行。</span><br><span class="line">* STEAL:在事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO-STEAL。从优化磁盘I/O性能考虑，允许数据提前写入，有利于利用空闲I/O资源，也有利于节省数据库缓存区的内存。</span><br><span class="line"></span><br><span class="line">Commit Logging允许NO-FORCE，但不允许STEAL。</span><br><span class="line">Write-Ahead Logging允许NO-FORCE，也允许STEAL。（性能最高，复杂性最高）</span><br><span class="line"></span><br><span class="line">实现方式：增加UnDo log日志，在变动数据写入磁盘之前，必须先记录UnDo log。这个log中明确记录修改了哪个位置的数据，从什么值改成了什么值。在需要回滚的时候，再根据这个日志来进行处理。</span><br><span class="line"></span><br><span class="line">#####  使用UnDo log，Write Ahead Logging在崩溃恢复时的三个步骤</span><br><span class="line">* 分析阶段：把没有End Record的事务组成一个待恢复集合</span><br><span class="line">* 重做阶段：从上述的集合中找到包含Commit Record的日志，把它们持久化到磁盘当中</span><br><span class="line">* 回滚阶段：经过上述两个步骤之后，把这个待恢复的集中的剩余事务全部圆润</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 如何实现隔离性</span><br><span class="line"></span><br><span class="line">隔离性保证了每个事务在各自读、写的数据都互相独立，彼此不受影响</span><br><span class="line"></span><br><span class="line">##### 数据库提供的三种锁</span><br><span class="line"></span><br><span class="line">* 写锁（排他锁）</span><br><span class="line">只有持有写锁的事务才能对数据进行写入操作，数据被加上写锁时，其他事务不能写入数据，也不能加读锁。</span><br><span class="line">写锁禁止其他事务施加读锁，而不是禁止事务读取数据</span><br><span class="line">* 读锁（共享锁）</span><br><span class="line">多个事务可以对一行数据添加多个读锁，数据被加上读锁之后就不能再加写锁了，所有数据都不能对该数据进行写入，但仍然可以读取。</span><br><span class="line">* 范围锁</span><br><span class="line">对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入</span><br><span class="line">```sql</span><br><span class="line">select * from books where price&lt;100 for update;##范围锁</span><br></pre></td></tr></table></figure></p><h4 id="四种隔离级别-从高到低"><a href="#四种隔离级别-从高到低" class="headerlink" title="四种隔离级别(从高到低)"></a>四种隔离级别(从高到低)</h4><h5 id="可串行化：强度最高的隔离性"><a href="#可串行化：强度最高的隔离性" class="headerlink" title="可串行化：强度最高的隔离性"></a>可串行化：强度最高的隔离性</h5><p>对事务所有读、写的数据全部加上读锁、写锁和范围锁</p><h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>对事务所涉及到的数据加读锁、写锁，但不加范围锁</p><p>可重复读比可串行化弱化的地方在于幻读问题，它是指在事务执行的过程中，两个完全相同的范围查询得到了不同的结果集</p><p><code>特例：MySQL/InnoDB默认隔离级别是可重复读，但是在只读事务中避免了幻读问题。但是在读写事务中幻读问题依然存在</code></p><h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h5><p>对事务所涉及到的数据加的写锁，会一直持续到事务结束。而加的读锁在查询完成之后就会马上释放。<br>读已提交比可重复读弱化的地方在于不可重复读问题，它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。</p><p>在这个隔离级别下，两次重复执行的查询结果不一样的原因：读是在查询完成就直接释放了。并没有贯穿整个事务的生命周期，也没有办法禁止读取过的数据发生修改。</p><h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>对事务涉及到数据只加写锁，一直持续到事务结束，但完全不加读锁。</p><p>读未提交比读已提交弱化的地方在于脏读问题，它是指在事务执行的过程中，一个事务读取到了另一个事务未提交的数据。</p><h4 id="MVCC基础原理"><a href="#MVCC基础原理" class="headerlink" title="MVCC基础原理"></a>MVCC基础原理</h4><p>针对一个事务读、另一个事务写的场景而提出的无锁优化方案，是一种读取优化策略。注意只是针对读+写的事务场景（写+写，就令当别论了）</p><p>基本思路：对数据的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本同时存在。借用这种手段来达到读取时不加锁的目的。</p><p>从全局的角度来看，可以理解为给每一行数据都增加两个默认为空的字段：CREATE_VERSION和DELETE_VERSION。当有数据发生变化时，通过控制这两个字段来进行处理：</p><ul><li>数据被插入时：CREATE_VERSION记录插入数据的事务ID，DELETE_VERSION为空。</li><li>数据被删除时：DELETE_VERSION记录删除数据的事务ID，CREATE_VERSION为空。</li><li>数据被修改时：将修改视为“删除旧数据，插入新数据”，即先将原有数据复制一份，原有数据的DELETE_VERSION记录修改数据的事务ID，CREATE_VERSION为空。复制出来的新数据的CREATE_VERSION记录修改数据的事务ID，DELETE_VERSION为空。</li></ul><p>数据是记录好了，怎么用呢？</p><p>会根据隔离级别来决定到底应该读取哪个版本的数据：</p><ul><li>隔离级别是可重复读：总是读取CREATE_VERSION小于或等于当前事务ID的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务ID最大）的。</li><li>隔离级别是读已提交：总是取最新的版本即可，即最近被Commit的那个版本的数据记录。</li></ul>]]></content>
    
    <summary type="html">
    
      事务架构探索
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>事务处理三</title>
    <link href="https://by1way.github.io/2020/12/07/transaction3/"/>
    <id>https://by1way.github.io/2020/12/07/transaction3/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2020-12-14T09:32:27.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="讨论范围"><a href="#讨论范围" class="headerlink" title="讨论范围"></a>讨论范围</h3><p>分布式事务:多个服务同时访问多个数据源的事务处理机制</p><h4 id="CAP（以下特性只能2选1）"><a href="#CAP（以下特性只能2选1）" class="headerlink" title="CAP（以下特性只能2选1）"></a>CAP（以下特性只能2选1）</h4><ul><li>一致性</li><li>可用性</li><li>分区容错性</li></ul><h4 id="CA，放弃P"><a href="#CA，放弃P" class="headerlink" title="CA，放弃P"></a>CA，放弃P</h4><p>主流RDBMS集群通常是采用放弃分区容错性的工作模式，例如RAC集群采用共享磁盘的方式来避免网络分区的出现。每个节点都有SGA,UNDO LOG 和REDO LOG，但各节点共享同一份数据文件和控制文件</p><h4 id="CP，放弃A"><a href="#CP，放弃A" class="headerlink" title="CP，放弃A"></a>CP，放弃A</h4><p>先假设一旦出现网络分区，节点之间信息的同步可以无限的延长。从而采用2PC/3PC手段来，同时获取分区容错性和一致性。</p><h4 id="AP，放弃C"><a href="#AP，放弃C" class="headerlink" title="AP，放弃C"></a>AP，放弃C</h4><p>目前大多数分布式系统设计的主流选择，大多数的NoSQL库和支持分布式的缓存都是AP系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACID CAP中讨论的一致性为强一致性，或线性一致性</span><br><span class="line"></span><br><span class="line">牺牲了C的AP,又想尽可能获取正确结果的行为，称为弱一致性，它的特例：最终一致性。</span><br></pre></td></tr></table></figure><h3 id="分布式事务实现方式"><a href="#分布式事务实现方式" class="headerlink" title="分布式事务实现方式"></a>分布式事务实现方式</h3><p>最终一致性的实现方式：可靠消息队列、TCC、SAGA</p><h4 id="可靠消息队列"><a href="#可靠消息队列" class="headerlink" title="可靠消息队列"></a>可靠消息队列</h4><p>通过持续重试的机制，来保证可靠性。最大努力交付<br>具体实现如下：<br>系统把最有可能出错的业务，以本地事务的方式完成后，通过不断重试的方式，来促使同个事务的其他关联业务来完成。</p><p>缺点：没有任务隔离性，在电商场景中可能导致的问题就是超售</p><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC天生适合用于需要强隔离性的分布式事务中。他需要先把资源给冻住，然后执行后续的操作。</p><ol><li>Try，尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好事务需要用到的所有业务资源（保障隔离性）</li><li>Confirm，确认执行阶段，确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理</li><li>Cancel，取消执行阶段，释放Try阶段预留的业务资源</li></ol><p>一般通过事务中间件（阿里seata)来完成</p><p>缺点：</p><ul><li>业务侵入性较强</li></ul><p>如果出现不合作（不可控）的第三方，往往在第一步Try就无法施行了。</p><h4 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h4><p>引入事务补偿的机制来代替回滚的操作。</p><p>实现原理：将大事务拆解为N个小事务，并且为每个事务设计一个对应的补偿机制</p>]]></content>
    
    <summary type="html">
    
      事务架构探索，分布式事务
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>事务处理二</title>
    <link href="https://by1way.github.io/2020/12/07/transaction2/"/>
    <id>https://by1way.github.io/2020/12/07/transaction2/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2020-12-17T02:08:00.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局事务和共享事务"><a href="#全局事务和共享事务" class="headerlink" title="全局事务和共享事务"></a>全局事务和共享事务</h3><p>全局事务和共享事务，是分布式事务的一种中间形式，起到的是承上启下的作用</p><h4 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">回忆</span><br><span class="line"></span><br><span class="line">应用场景：单服务多数据源</span><br><span class="line">实现方式：2PC 3PC</span><br><span class="line"></span><br><span class="line">弱一致性、最终一致性，解决不了一致性问题</span><br><span class="line"></span><br><span class="line">共享事务：通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作</span><br><span class="line"></span><br><span class="line">问题既然已经出现，又该如何应对。各种解决方案又有什么样的处理方式呢？</span><br></pre></td></tr></table></figure><p>全局事务是一种适用于单个服务使用多个数据源场景的事务解决方案。</p><h5 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h5><p>XA协议：定义了全局事务管理器和局部的资源管理器之间的通讯接口。常见的现象有：XADataSource/XAResource</p><p>Java对于XA的实现：JTA，定义了事务管理器接口、满足XA规范的资源定义接口。</p><p>两段式提交、三段式提交也是基于XA协议的实现</p><h5 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h5><ul><li>准备阶段：<br>  由协调者询问，事务的所有参与者是否准备好，如果准备好就回复Prepared,否则回复Non-Prepared<br>  准备，把所有要提交的操作都写到重做日志记录中。只是不写Commit Record</li><li>提交阶段:<br>  在收到所有参与者回复的Perpared消息后，将本地持久化事务状态改为Commit,然后向所有参与者发送Commit指令，所有参与者立即执行提交操作。<br>  如果任意一个参与者回复了Non-Prepared消息，或任意一个参与者超时未回复，协调者都会将自己的事务状态持久化为“Abort”之后，    向所有参与者发送Abort指令，参与者立即执行回滚操作    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两阶段提交保证成功的前提:</span><br><span class="line">1. 必须假设网络在提交阶段这个短时间内是可靠的，即提交阶段不会丢失消息。</span><br><span class="line">2. 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。</span><br><span class="line"></span><br><span class="line">出现问题的场景：</span><br><span class="line">当协调者将本地的状态持久为commit后，并提交了本地的事务，这个时候出现的网络中断，再也无法通过网络向参与者发送commit指令，就会导致协调者提交事务，参与者既没法提交也法回滚的情况。从而导致数据不一致。</span><br></pre></td></tr></table></figure><p>两段式提交存在的问题</p><ol><li>单点问题:协调者宕机</li><li>性能问题:整个过程要持续到所有参与者中最慢的那个处理完成之后</li><li>一致性风险：当网络稳定性和宕机恢复能力的假设不成立时，会出现严重的一致性问题。</li></ol><h5 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h5><p>解决两段式提供存在的三个问题中的前两个，也就是单点问题和性能问题，但并没有解决一致性风险。</p><p>如何解决的呢</p><ul><li>单点问题：<br>  CanCommit：准备阶段，询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。也意味着因某个参与者        提交时发生崩溃而导致全部回滚的风险相对变小了。如果有一个参与者无法完成，这个时候也没有涉及资源被锁住的风险。从这种角度上来看也提升了一些性能。但是也仅仅是在需要回滚的场景中，但是正常提交的情况，性能却多了一个限制 。<br>  PreCommit：准备阶段，<br>  DoCommit：提交阶段</li></ul><h4 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h4><p>多个服务共同一个数据源，共享数据库连接，通过数据库中间件的形式，通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作</p>]]></content>
    
    <summary type="html">
    
      事务架构探索，全局事务、共享事务
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
