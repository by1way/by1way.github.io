<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>By1way</title>
  
  <subtitle>用心记录每一份成长、每一滴收获、每一个新奇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://by1way.github.io/"/>
  <updated>2021-03-16T09:54:42.892Z</updated>
  <id>https://by1way.github.io/</id>
  
  <author>
    <name>carol</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07.远程服务调用</title>
    <link href="https://by1way.github.io/2021/02/07/07-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <id>https://by1way.github.io/2021/02/07/07-远程服务调用/</id>
    <published>2021-02-07T03:44:51.000Z</published>
    <updated>2021-03-16T09:54:42.892Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，可能是因为我的理解能力有点小问题，这篇文章读了好几遍才大概明白了点其中的道道。为了防止大家跟我一样学习的时候会晕菜。所以我决定先把作者的行文思路给大家画出来。</p><p><img src="/2021/02/07/07-远程服务调用/C:/Users\lihaiming\AppData\Roaming\Typora\typora-user-images\image-20210220110908193.png" alt="image-20210220110908193"></p><ol start="0"><li>介绍了下架构师的职责</li><li>RPC在众眼里是什么样的呢？为什么一直这么火呢</li><li>借用本地调用过程的例子来引入，同时做出假设调用者和被调用者不在同一个进程之内</li><li>解决上面步骤2问题的方法，有六种。尤其是最后一种本地套接字接口，它的设计理念简直直RPC最初的目的不谋而合</li><li>但在那个时候对于透明的分布式系统而言，别说存在着大量的问题需要解决的，就连认识上都存在大量误解。</li><li>最终，施乐公司的Palo Alto研究中心，发布了第一个基于RPC的应用，并正式提出了RPC的概念。</li></ol><p>​    在这篇文章中有几个提法比较有意思：比如RPC作为分布式前置的基础条件，再比如RPC应该是一种高层次的，或者说语言层次的特征，而不是像IPC那样，是低层次的，或者说系统层次的特征；还有RPC以模拟进程间方法调用为起点，许多思想和概念都借鉴的是IPC，都能给人耳目一新的感觉。</p><p>好了下面咱们开始正式的内容：</p><h4 id="0-架构师的职责"><a href="#0-架构师的职责" class="headerlink" title="0. 架构师的职责"></a>0. 架构师的职责</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">什么架构师呢？</span><br><span class="line">有做企业战略设计的架构师，有做业务流程分析的架构师……</span><br><span class="line">在这里呢？特指软件系统中技术模型的设计者。</span><br><span class="line"></span><br><span class="line">架构师工作的三个问题？</span><br><span class="line">* 做架构设计的时候，架构师都应该思考哪些问题呢？</span><br><span class="line">* 都可以选择哪些主流的解决方案和行业标准做法呢？</span><br><span class="line">* 以及这些方案都有什么优缺点，都会给架构设计带来什么影响呢？</span><br></pre></td></tr></table></figure><h4 id="1-大众眼中的RPC（远程服务调用）？"><a href="#1-大众眼中的RPC（远程服务调用）？" class="headerlink" title="1.大众眼中的RPC（远程服务调用）？"></a>1.大众眼中的RPC（远程服务调用）？</h4><p>关于RPC三个小问题：</p><pre><code>1. RPC本身可以解决什么问题呢 2. 这些问题又是怎么被解决的呢？ 3. 为什么要这样解决呀</code></pre><p>RPC为什么这么火热的原因：</p><ul><li>可能是微服务风潮带来的热度</li><li>作为开发者，我们很多人对RPC本身可以解决什么问题、如何解决这些问题、为什么要这样解决，都或多或少存在些认知模糊的情况</li></ul><h4 id="2-本地方法调用"><a href="#2-本地方法调用" class="headerlink" title="2. 本地方法调用"></a>2. 本地方法调用</h4><p>​    本地方法调用几个概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者（Caller）      ： main()</span></span><br><span class="line"><span class="comment">// 被调用者（Callee）      ： println()</span></span><br><span class="line"><span class="comment">// 调用点（Call Site）   ： 发生方法调用的指令流位置</span></span><br><span class="line"><span class="comment">// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即“hello world”</span></span><br><span class="line"><span class="comment">// 返回值（Retval）      ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做一个假设：如果在调用println()的时候，发现它并不在当前内存地址空间中，又会出现什么问题呢？</p><ol><li>前面的传递参数、传回结果都依赖于栈内存的帮助，如果Caller与Callee分属不同的进程，就不会拥有相同的栈内存，那么在Caller进程的内存中将参数压栈，对于Callee进程的执行毫无意义。</li><li>println()方法版本选择依赖于语言规则的定义，而如果Caller与Callee不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为。</li></ol><p><strong>如何解决两个进程间通讯的问题问题：</strong></p><pre><code>1. 管道（Pipe）或具名管道（Named Pipe）: 管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。2. 信号（Signal）: 信号是用来通知目标进程有某种事件发生的。除了用于进程间通信外，信号还可以被进程发送给进程自身。信号的典型应用是kill命令，比如“kill -9 pid”，意思就是由Shell进程向指定PID的进程发送SIGKILL信号。 3. 信号量（Semaphore）:信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行wait()和notify()操作。 4. 消息队列（Message Queue）:进程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点 ，但实时性相对受限。 5. 共享内存（Shared Memory）: 允许多个进程可以访问同一块内存空间，这是效率最高的进程间通讯形式。进程的内存地址空间是独立隔离的，但操作系统提供了让进程主动创建、映射、分离、控制某一块内存的接口。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。 6. &lt;font color=&quot;red&quot;&gt;本地套接字接口（IPC Socket）: 消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。&lt;/font&gt;</code></pre><h4 id="3-竟然不谋而合"><a href="#3-竟然不谋而合" class="headerlink" title="3.竟然不谋而合"></a>3.竟然不谋而合</h4><p>​    RPC可以作为IPC的一种特例来看待。</p><p>​    IPC Socket是操作系统提供的标准接口，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到远程调用与本地方法调用几乎完全<strong>一致</strong>。</p><p>​    <strong>还记得远程服务调用最初的目的吗？</strong>与调用本地方法<strong>一致</strong>。</p><h4 id="4-透明RPC调用存在的问题"><a href="#4-透明RPC调用存在的问题" class="headerlink" title="4.透明RPC调用存在的问题"></a>4.透明RPC调用存在的问题</h4><ul><li>两个进程通讯，谁作为服务端，谁作为客户端？</li><li>怎样进行异常处理？异常该如何让调用者获知？</li><li>服务端出现多线程竞争之后怎么办？</li><li>如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？是否支持多播？</li><li>参数、返回值如何表示？应该有怎样的字节序？</li><li>如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？</li><li>服务端发送请求后，收不到回复该怎么办？</li></ul><p>​    <strong>分布式运算的八宗罪：</strong></p><ol><li>网络是可靠的（The network is reliable）</li><li>延迟是不存在的（Latency is zero ）</li><li>带宽是无限的（Bandwidth is infinite）</li><li>网络是安全的（The network is secure）</li><li>拓扑结构是一成不变的（Topology doesn’t change）</li><li>总会有一个管理员（There is one administrator）</li><li>不考虑传输成本（Transport cost is zero）</li><li>网络是同质化的（The network is homogeneous）</li></ol><h4 id="5-RPC的概念"><a href="#5-RPC的概念" class="headerlink" title="5.RPC的概念"></a>5.RPC的概念</h4><p>​    传奇的施乐Palo Alto研究中心，发布了基于Cedar语言的RPC框架Lupine，并实现了世界上第一个基于RPC的商业应用Courier。并提出了RPC的概念，也就我们今天看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机）</span><br></pre></td></tr></table></figure><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“远程方法不应该无视通讯成本”这个观点，从性能的角度来看是有益的，但从简单的角度看则是有害的。在现代的软件系统开发中，你用过什么RPC框架吗？它们有没有把“像本地方法一样调用远程方法”作为卖点？</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      远程服务调用
    
    </summary>
    
      <category term="架构师视角" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="远程服务调用" scheme="https://by1way.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>06.无服务时代：不分布式云端系统的起点</title>
    <link href="https://by1way.github.io/2021/02/07/06-%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/06-无服务时代的探索/</id>
    <published>2021-02-07T03:34:51.000Z</published>
    <updated>2021-03-16T09:54:03.329Z</updated>
    
    <content type="html"><![CDATA[<p>分布式架构出现的最初目的，是要解决单台机器的性能成为整个软件系统的瓶颈的问题。分布式架构也会引入一些新问题（比如服务的安全、容错，分布式事务的一致性），因此对软件开发这件事儿来说，不去做分布式无疑是最简单的。</p><p>云计算的成功其实已经实现了相对意义上无限性能。</p><p>对基于云计算的软件系统来说，无论用户有多少、逻辑如何复杂，AWS、阿里云等云服务提供商都能在算力上满足系统对性能的需求，只要你能为这种无限的性能支付得起对应的代价。这样”无服务“概念也就产生了。</p><h4 id="无服务架构特点"><a href="#无服务架构特点" class="headerlink" title="无服务架构特点"></a>无服务架构特点</h4><ul><li>后端设施，指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“<strong>后端即服务</strong>”</li><li>函数，指的就是业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划，也就是无服务中的“<strong>函数即服务</strong>”</li></ul><h4 id="无服务的愿景"><a href="#无服务的愿景" class="headerlink" title="无服务的愿景"></a>无服务的愿景</h4><ol><li>不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼</li><li>不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成</li><li>不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的</li><li>也不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任</li></ol><p>虽然无服务架构的远期前景也许很美好，但无服务中短期内的发展，并没有那么乐观。为什么这么说呢？ 与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式。所以除非是有重大变革，否则它也很难具备普适性。</p><h4 id="无服务架构的局限性"><a href="#无服务架构的局限性" class="headerlink" title="无服务架构的局限性"></a>无服务架构的局限性</h4><p>​    无服务天生“无限算力”的假设，就决定了它必须要按使用量（函数运算的时间和内存）来计费，以控制消耗算力的规模，所以函数不会一直以活动状态常驻服务器，只有请求到了才会开始运行。这导致了函数不便于依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能会太好。</p><p>前面第一节讲到，在首次对分布式的探索失败之后，大型软件的发展出现了两个方向，一个是以分布式为基础的探索，另一个以不分布式为目的的探索。如果说服务网格是在分布式道路上的探索的最新方向，那无服务架构就是在不分布式这条道路上的努力 。但这两条路线的边界也是越来越模糊，最终将会在云端的数据中心处交汇。</p><p><strong>需要注意的是：无服务和微服务、云原生并没有继承替代的关系，因此也不能有无服务比微服务更加先进的想法</strong></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>是否了解、接触过无服务架构？无服务目前在中国处于起步的发展阶段，阿里云、腾讯云的无服务计算框架，都给了普通用户相当大的免费额度，你愿意去试一下吗？</p>]]></content>
    
    <summary type="html">
    
      无服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="无服务时代" scheme="https://by1way.github.io/tags/%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>05.后微服务时代：跨越软件与硬件之间的界限</title>
    <link href="https://by1way.github.io/2021/02/07/05-%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/05-后微服务时代的探索/</id>
    <published>2021-02-07T02:44:51.000Z</published>
    <updated>2021-03-16T09:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>抛开微服务架构，先看看下面几个问题的解决思路：</p><ul><li>如果某个系统需要伸缩扩容，我们通常会购买新的服务器，多部署几套副本实例来分担压力；</li><li>如果某个系统需要解决负载均衡的问题，我们通常会布置负载均衡服务器，并选择恰当的均衡算法来分流；</li><li>如果需要解决安全传输的问题，我们通常会布置TLS传输链路，配置好CA证书，以保证通讯不被窃听篡改；</li><li>如果需要解决服务发现的问题，我们通常会设置DNS服务器，让服务访问依赖稳定的记录名而不是易改变的IP地址等等</li></ul><p>从上面的几个问题，我们就可以发现这些问题已经大多都有了专职的基础设施来帮助解决了，那为什么微服务还必须在应用层面上去解决这问题呢？</p><p>原因就在于：<font color="red">因为硬件构成的基础设施，跟不上软件构成应用服务的灵活性。</font></p><p>既然软件可以通过命令就可以拆分出不同的服务，那么硬件不可以吗？这就到云原生的时代，<strong>微服务时代所取得的成就，本身就离不开以Docker为代表的早期容器化技术的巨大贡献</strong>。</p><p>近些年蓬勃发展的Kubernetes，可以说是开启了下一个软件架构发展的新纪元。对比下Spring Cloud中提供的应用层面的解决方案，Kubernetes也从基础设施层面给出它的解决方案，而且还是一条全新的、前途更加广阔的解题思路。虽然这一切看起来都很美好，但是从功能灵活性的特点上来，Kubernetes还不如Spring Cloud方案。因为从基础设施层面上很精细化解决一些边缘化的问题（比如做服务熔断）。因为基础设施针对的是整个容器做整体的管理，它的粒度相对来说比较粗犷。</p><p>所以微服务的基础设施再次进化，就引出了叫做服务网格的”边车代理模式“。</p><h4 id="边车代理模式"><a href="#边车代理模式" class="headerlink" title="边车代理模式"></a>边车代理模式</h4><p>微服务基础设施会由系统自动地在服务的资源容器（指Kubernetes的Pod）中注入一个通讯代理服务器（相当于那个挎斗），用类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄悄接管掉应用的所有对外通讯。 这个代理除了会实现正常的服务调用以外（称为数据平面通讯），同时还接受来自控制器的指令（称为控制平面通讯），根据控制平面中的配置，分析数据平面通讯的内容，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。 这样，就实现了既不需要在应用层面附带额外的代码，也提供了几乎不亚于应用代码的精细管理能力的目的。</p><p>代表性技术：Istio、Envoy</p><p>新技术发展时间比较短，还没有完全成熟起来。但未来可期</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>分布式架构发展到服务网格后，真的是到达“最好的时代”了吗？软件架构的发展不太可能真的就此止步，你认为今天的云原生还有哪些主要矛盾，下一次软件架构的进化将会主要解决什么问题？</p>]]></content>
    
    <summary type="html">
    
      后微服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="后微服务时代" scheme="https://by1way.github.io/tags/%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>04.微服务时代：SOA的革命者</title>
    <link href="https://by1way.github.io/2021/02/07/04-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/04-微服务时代的探索/</id>
    <published>2021-02-07T02:34:51.000Z</published>
    <updated>2021-03-16T09:54:11.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="red">微服务最早被提出是作为SOA的一种轻量化的补救方案而被提出来的</font></strong></p><h4 id="微服务的概念"><a href="#微服务的概念" class="headerlink" title="微服务的概念"></a>微服务的概念</h4><p>微服务是一种通过多个小型服务的组合，来构建的单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的存储技术、运行在不同的进程之中。服务会采用轻量级的通讯机制和自动化的部署机制来实现通讯与运维。</p><h4 id="九个核心业务与技术特征"><a href="#九个核心业务与技术特征" class="headerlink" title="九个核心业务与技术特征"></a>九个核心业务与技术特征</h4><h5 id="1-围绕业务能力构建"><a href="#1-围绕业务能力构建" class="headerlink" title="1. 围绕业务能力构建"></a>1. 围绕业务能力构建</h5><p>​    有怎样的结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。</p><h5 id="2-分散治理"><a href="#2-分散治理" class="headerlink" title="2.分散治理"></a>2.分散治理</h5><p>​    微服务开发团队有着直接对服务运行质量负责的责任，也应该有不受外界干预，掌控服务各方面能力的权力，能选择与其他服务异构的技术来实现自己的服务。</p><h5 id="3-通过服务来实现独立自治的组件"><a href="#3-通过服务来实现独立自治的组件" class="headerlink" title="3.通过服务来实现独立自治的组件"></a>3.通过服务来实现独立自治的组件</h5><p>​    通过远程服务而非类库来提供功能，从而得到组件的隔离与自治能力。</p><h5 id="4-产品化思维"><a href="#4-产品化思维" class="headerlink" title="4.产品化思维"></a>4.产品化思维</h5><p>​    避免把软件开发看作是要去完成某种功能，而是要把它当作是一种持续改进、提升的过程</p><h5 id="5-数据去中心化"><a href="#5-数据去中心化" class="headerlink" title="5.数据去中心化"></a>5.数据去中心化</h5><p>​    数据应该按领域来分散管理、更新、维护和存储。有时候一致性问题也可能是必须要付出的代价</p><h5 id="6-轻量级通讯机制"><a href="#6-轻量级通讯机制" class="headerlink" title="6.轻量级通讯机制"></a>6.轻量级通讯机制</h5><p>​    如果服务需要上面的某一种功能或能力，那就应该在服务自己的Endpoint上解决，而不是在通讯管道上一揽子处理。RESTful风格的通讯方式，在微服务中就是比较适合的。</p><h5 id="7-容错性设计"><a href="#7-容错性设计" class="headerlink" title="7.容错性设计"></a>7.容错性设计</h5><p>​    承认服务会出错，接收服务总会出错的现实。有了这个认识的前提，在设计微服务的时候就要求有自动的机制能对其依赖的服务进行快速的故障检测，持续出错的时候可以进行自动的隔离，在服务恢复好之后重新联通。</p><p>​    <strong><font color="red">可靠的系统由不会出错的服务来组成，这就是微服务最大的价值所在</font></strong></p><h5 id="8-演进式设计"><a href="#8-演进式设计" class="headerlink" title="8.演进式设计"></a>8.演进式设计</h5><p>​    承认服务会被淘汰。一个良好的设计，应该是能够报废的，而不是指望着它长久。</p><h5 id="9-基础设施自动化"><a href="#9-基础设施自动化" class="headerlink" title="9.基础设施自动化"></a>9.基础设施自动化</h5><p>​    服务一多，靠人工来运维这根本就是不可能的事情。所以会要依赖大量的基础设施来自动化完成</p><p>注意：以上9个是一个合理的微服务系统展示出来的内、外在表现，它能够指导你该如何应用微服务架构，而不能作为一种强加于系统中的束缚来看待。</p><p>这么自由的微服务理念咋不上天呢？以前提到的那个分布式问题就不存在了吗？还是得一个个的解决。于是各种技术框架纷纷出现。比如像Eureka、Consul、Nacos、Zookeeper、Etcd用来解决服务发现的技术、像Dubbo、Thrift、gRPC用来解决服务通讯的技术，真的是层出不穷。更甚至还有springcloud之类的全家桶，真的是给开发人员带来巨大的便利。</p><p>便对架构的要求也越来越高了。架构者如何在各种决策之间权衡能力也变得至关重要起来！</p><p><strong>那有没有一种即可以得到微服务自由的权力、还能专注于自己的业务，同时又不用费力去解决分布式带来的问题的解决方案呢？</strong></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>你所负责的产品是不是基于微服务的？如果是，它符合微服务的9个特征吗？如果不是，你的产品适合微服务架构吗？你所在的企业、团队适合引入微服务吗？</p>]]></content>
    
    <summary type="html">
    
      微服务时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="微服务时代" scheme="https://by1way.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>03.SOA时代：成功理论与失败实践</title>
    <link href="https://by1way.github.io/2021/02/07/03-SOA%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/03-SOA时代的探索/</id>
    <published>2021-02-07T02:20:51.000Z</published>
    <updated>2021-03-16T09:54:33.421Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em><font color="red">SOA架构是第一次被广泛使用过、通过分布式服务来构建信息系统的工程实践。它有完善的理论和工具，可以说，它解决了分布式系统中，几乎所有主要的技术问题</font></em></strong></p><p>所以本节就系统的讨论一下SOA的设计思想与原则，找找他为什么没有成功的原因？</p><h4 id="三种服务拆分架构模式"><a href="#三种服务拆分架构模式" class="headerlink" title="三种服务拆分架构模式"></a>三种服务拆分架构模式</h4><h5 id="1-烟囱式架构"><a href="#1-烟囱式架构" class="headerlink" title="1.烟囱式架构"></a>1.烟囱式架构</h5><p>​    前提：假设完全不会跟其他相关的信息系统之间进行协作</p><p>​    互不交互的系统，各自使用独立的数据库、服务器，即可以完成拆分。</p><p>​    问题就在于：不交互的系统（组织）真的存在吗？</p><h5 id="2-微内核架构"><a href="#2-微内核架构" class="headerlink" title="2.微内核架构"></a>2.微内核架构</h5><p>​    把一些公共的主数据：人员、组织 、权限等公用的服务、数据、资源，都集中到一块儿，成为被所有业务系统共同依赖的核心系统。</p><p>​    这种模式很适合桌面应用程序的开发，如果想实现一个能够支持二次开发的软件系统，微内核架构也是一种良好的架构模式。</p><p>​    问题在于：各业务系统不直接交互，（比如：支付系统和用户系统是独立的，但彼此会有业务的调用），这时需要找到一个办法，即能拆分出独立的系统，也能让拆分后的子系统之间可以顺畅的互相调用</p><h5 id="3-事件驱动架构"><a href="#3-事件驱动架构" class="headerlink" title="3.事件驱动架构"></a>3.事件驱动架构</h5><p><strong>为了能让子系统之间相互通讯，事件驱动架构就产生了</strong></p><p>它是这样的一张种模式：在子系统之间建立一套事件队列管道，来自系统外部的消息将以事件的形式发送管道中，各子系统可以从管道中获取自己感兴趣、可以处理的事件消息，也可以为事件新增或修改其中的附加信息，甚至还可以自己发布一些新的事件到管道队列中去。</p><p>同时SOAP协议的诞生，<strong><font color="red">事件驱动架构+SOAP协议==催生出=&gt;面向服务架构</font></strong></p><h4 id="SOA架构时代的探索"><a href="#SOA架构时代的探索" class="headerlink" title="SOA架构时代的探索"></a>SOA架构时代的探索</h4><h5 id="探索1：更具体"><a href="#探索1：更具体" class="headerlink" title="探索1：更具体"></a>探索1：更具体</h5><p>SOA本身还是属于一种抽象概念，而不是特指某一种具体的技术，但它比单体架构和烟囱式架构、微内核架构、事件驱动架构，都要更具可操作性，细节也充实了很多。所以，我们已经不能简单地把SOA看作是一种架构风格了，而是可以称之为一套软件架构的基础平台。</p><h5 id="探索2：更系统"><a href="#探索2：更系统" class="headerlink" title="探索2：更系统"></a>探索2：更系统</h5><p>SOA最根本的目标，就是希望能够总结出一套自上而下的软件研发方法论，让企业只需要跟着它的思路，就能够一揽子解决掉软件开发过程中的全套问题。比如，如何挖掘需求、如何将需求分解为业务能力、如何编排已有服务、如何开发测试部署新的功能，等等</p><p><strong>过于严格的规范定义，给架构带来了过度的复杂性</strong>，这也是Web Service衰落最本质的原因。</p><h4 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h4><p>你是否使用过SOA的方法论来开发软件系统呢？无论有还是没有，作为一个软件开发者，你是否愿意软件开发向着工业化方向发展，让软件类似工业产品制造那样，可以在规范、理论、工具、技术的支持下，以流水线的方式生产出来？</p><p>思考：还真的是使用过某国产的ESB开发一个项目，但是受限于项目的规模只是做了课题性质的研究。虽然配套设施都很齐全，但是用起却不并不那么的流畅，再加上当时思路受制于服务编排的困扰。好不容易把思路给理顺了，同时又被微服务给冲击了。如果软件开发朝着工业化的方向发展，听起来像是很美妙的事情，那样的话，软件的质量应该会有很大的提高。但是自己会不会被淘汰，软件的定制化（灵活性）怎么体现，软件开发的工作会不会朝着工具化的思路去发展，到处去写补丁。还有一个问题，工业化产出的东西都是一样的，就算再扩展一点可以满足可以提供各种参数来配置。那这个基础工具该有多复杂呀。</p>]]></content>
    
    <summary type="html">
    
      SOA时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="SOA时代" scheme="https://by1way.github.io/tags/SOA%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>02.单体系统时代</title>
    <link href="https://by1way.github.io/2021/02/07/02-%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/02-单体系统时代的探索/</id>
    <published>2021-02-07T02:14:51.000Z</published>
    <updated>2021-03-16T09:51:31.694Z</updated>
    
    <content type="html"><![CDATA[<p>应用最广泛的架构风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误的认知：</span><br><span class="line">架构无好坏，只能是根据场景来选择。</span><br><span class="line">典型的思维误区：</span><br><span class="line">单体架构是落后的系统架构风格，最终会被微服务所替代。</span><br><span class="line">观念的转变：</span><br><span class="line">不追求尽量不出错，而是应当正视出错是必然的，其实，这才是导致微服务开始逐步代替单体架构根本的驱动力。</span><br></pre></td></tr></table></figure><h4 id="1-大型单体系统"><a href="#1-大型单体系统" class="headerlink" title="1.大型单体系统"></a>1.大型单体系统</h4><p>也被称为巨石系统，把单体看作成是一种架构，确切的说是在微服务流行之后，才被追加的。</p><p>对于一个小型的系统来说，使用单体架构，易于开发，易于测试，易于部署，而且是进程内方法调用。</p><p><strong><em> 所以要想讨论单体系统的缺陷，必须要有一个前提：软件的性能需求超过了单机 所能处理的最大能力 </em></strong></p><p>题外话:当前市面上所有主流的IDE，也都是对单体架构支持最友好。</p><h4 id="2-可拆分的单体系统"><a href="#2-可拆分的单体系统" class="headerlink" title="2.可拆分的单体系统"></a>2.可拆分的单体系统</h4><ul><li>分层架构（纵向角度）</li><li>水平扩展（横向角度）多副本机制</li></ul><h4 id="3-非独立的单体"><a href="#3-非独立的单体" class="headerlink" title="3.非独立的单体"></a>3.非独立的单体</h4><p>​    在拆分 方面，单体系统真正的缺陷，实际上并不在于如何 拆分 ，而是在于拆分 之后它会存在隔离与自治能力上的欠缺。</p><p>以微服务去代替单体系统的原因：</p><pre><code>* 无法做故障隔离* 无法做到动态可维护* 无法做到技术异构* 不兼容phoenix特性（不死--&gt;能自治--&gt;可靠）</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2021/02/07/02-单体系统时代的探索/C:/Users\lihaiming\AppData\Roaming\Typora\typora-user-images\image-20210216165550240.png" alt="image-20210216165550240"></p>]]></content>
    
    <summary type="html">
    
      单体系统时代
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="单体系统" scheme="https://by1way.github.io/tags/%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>01.原始分布式时代</title>
    <link href="https://by1way.github.io/2021/02/07/01-%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://by1way.github.io/2021/02/07/01-原始分布式时代的探索/</id>
    <published>2021-02-07T02:04:51.000Z</published>
    <updated>2021-03-16T09:54:18.487Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNIX设计哲学：</span><br><span class="line">保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性都来得更加重要。</span><br></pre></td></tr></table></figure><p>在这个阶段提出的分布式架构的目标：<font color="#FF0000">使用多个独立的分布式服务来共同构建出一个更大型的系统。</font>而这个目标，从历史的局限性就决定了他不可能 是一蹴而就的解决分布式系统中的难题。其中面临的最大问题就是：<font color="red">由于调用本地方法与调用远程方法的差别，如何像调用本地方法一样去调用远程方法</font></p><p>那“远程”二字代表了什么呢？</p><ol><li>首先不可能 用内联等传统编译原理中的优化算法，来提升运行速度</li><li>远程所带来的网络环境问题，包括：<ul><li>远程服务在哪里–&gt;<font color="red">服务发现</font></li><li>有多少个–&gt;<font color="red">负载均衡</font></li><li>网络出现分区，超时出错怎么办–&gt;<font color="red">熔断，隔离降级</font></li><li>方法参与返回结果如何表示 –&gt;<font color="red">序列化协议</font></li><li>如何传输–&gt;<font color="red">传输协议</font></li><li>服务权限怎么管理–&gt;<font color="red">认证授权</font></li><li>如何 保证通信安全–&gt;<font color="red">网络安全层</font></li><li>如何 令调用不同机器服务返回相同的结果–&gt;<font color="red">分布式数据一致性</font></li></ul></li></ol><p>针对大部分问题，DCE从0开始从无到有回答了其中大部分的问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在这个阶段采用分布式架构，为了解决上述各种问题，所付出的代价远远超过了所取得的收益。那接下来该如何发展呢？</p><ol><li>尽快提升单机处理能力，以避免分布式的种种问题</li><li>寻找更完美的解决方案，来应对上述在构筑分布式系统的问题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作只会自食其果</span><br></pre></td></tr></table></figure><p>行文思路：</p><p><img src="/2021/02/07/01-原始分布式时代的探索/C:/Users\lihaiming\AppData\Roaming\Typora\typora-user-images\image-20210216102359012.png" alt="image-20210216102359012"></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天以微服务为代表的分布式系统，是如何看待简单的？</span><br></pre></td></tr></table></figure><p>思考：</p><p>微服务所谓的简单，不管是从开发工具、开发形式亦或是运维上来看，都是在趋于看上去的简单。把复杂 留给 自己，简单留给别人。易开发、易部署、易扩展、易运维等等的说法。都在宣誓着把简单作为主要的原则 ，但背后所面临着诸如本节课所有的讨论的问题，都是需要一一关注，一一解决的。所以我觉得这里的简单并不是真正的简单。</p>]]></content>
    
    <summary type="html">
    
      原始分布式时代：Unix设计哲学下服务探索
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="原始分布式时代" scheme="https://by1way.github.io/tags/%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>00.慢慢的我来了</title>
    <link href="https://by1way.github.io/2021/02/07/00-%E6%97%A5%E8%B5%B0%E4%B8%80%E5%8D%92%EF%BC%8C%E9%87%8D%E5%90%AF%E8%88%AA/"/>
    <id>https://by1way.github.io/2021/02/07/00-日走一卒，重启航/</id>
    <published>2021-02-07T02:00:51.000Z</published>
    <updated>2021-03-16T10:06:03.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于认识"><a href="#关于认识" class="headerlink" title="关于认识"></a>关于认识</h3><p>渐渐地认识到了自身很多不的足，做什么事情都没有长性。去年做了一件关于坚持的事情，参加了百日跑的活动。连续两届200天，每天跑步5公里。成绩什么的就都不重要，体重减少了多少也不重要。重要的是懂得了一些道理，养成了一些习惯。以前的自己想要的东西太多了，以至于什么事情都没有做太好。所以这次以自身的品性出发，慢慢地来。一点点来个，一个个来。坚持在缓慢中见识到真正的自己，我希望以后能够多多来看看自己内心深处的东西。</p><p>真正想要得到的是什么，多思考，多总结，多输出。</p>]]></content>
    
    <summary type="html">
    
      重启
    
    </summary>
    
      <category term="重启" scheme="https://by1way.github.io/categories/%E9%87%8D%E5%90%AF/"/>
    
    
      <category term="重启" scheme="https://by1way.github.io/tags/%E9%87%8D%E5%90%AF/"/>
    
  </entry>
  
  <entry>
    <title>事务处理一</title>
    <link href="https://by1way.github.io/2020/12/07/transaction1/"/>
    <id>https://by1way.github.io/2020/12/07/transaction1/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2021-01-06T05:59:47.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的意义"><a href="#事务的意义" class="headerlink" title="事务的意义"></a>事务的意义</h3><p>保证数据的正确性，不同的数据之间不会产生矛盾。也就是保证数据状态的一致性。</p><h3 id="讨论的范围"><a href="#讨论的范围" class="headerlink" title="讨论的范围"></a>讨论的范围</h3><p>数据库事务状态的一致性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 实现数据库事务状态一致性目标的前提</span><br><span class="line"></span><br><span class="line">* 原子性：在同一项业务处理中，事务保证对多个数据的修改要么都成功，要么都被撤销</span><br><span class="line">* 隔离性：在不同的业务处理过程中，事务保证各自读、写的数据互相独立，不会彼此影响</span><br><span class="line">* 持久性：事务应当保证所有被成功提交的数据修改，都能正确的持久化到数据库当中去，不会丢失数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```原子性、隔离性、持久性是手段，一致性是目标</span><br></pre></td></tr></table></figure></p><h3 id="关于事务处理的不场景"><a href="#关于事务处理的不场景" class="headerlink" title="关于事务处理的不场景"></a>关于事务处理的不场景</h3><ul><li>单个服务使用单个数据源</li><li>单个服务使用多个数据源</li><li>多个服务使用单个数据源</li><li>多个服务使用多个数据源</li></ul><h2 id="单个服务使用单个数据源"><a href="#单个服务使用单个数据源" class="headerlink" title="单个服务使用单个数据源"></a>单个服务使用单个数据源</h2><p>单个服务使用单个数据源，也就是本地事务场景，也可以叫作局部事务</p><h3 id="本地事务说明"><a href="#本地事务说明" class="headerlink" title="本地事务说明"></a>本地事务说明</h3><p>指仅操作特定单一事务资源的、不需要“全局事务管理器”参与协调的事务。</p><p>本地事务，依赖于数据源本身的事务能力来工作，我们常见的在程序代码中的事务也最多就是对事务接口进行的一层标准化包装。事务的开启、终止、提交、回滚、嵌套、设置隔离级别乃至与应用代码贴近的传播方式都需要依赖底层数据库的支持。</p><h3 id="ARIES理论"><a href="#ARIES理论" class="headerlink" title="ARIES理论"></a>ARIES理论</h3><p>Algorithms for Recovery and Isolation Exploiting  Semantics ，基于语义的恢复与隔离算法</p><p>当前主流关系性数据在事务实现上都受到该理论的影响。</p><h4 id="如何实现原子性和持久性"><a href="#如何实现原子性和持久性" class="headerlink" title="如何实现原子性和持久性"></a>如何实现原子性和持久性</h4><p>实现原子性和持久性最大的困难是什么？</p><p>写入磁盘这个操作不会是原子性，不仅存在写入、未写入，还存在“正在写”的中间状态。</p><p>这可咋办呀，怎么记录这个中间状态呢?日志？</p><h5 id="Commit-Logging"><a href="#Commit-Logging" class="headerlink" title="Commit Logging"></a>Commit Logging</h5><p>把日志顺序追加写入文件方式，记录到磁盘中。见到代表事务提交成功的Commit Record之后 ，数据库才根据日志上的信息对真实数据进行修改，修改完之后，在日志中再加入一条End Record,表示数据库已完成持久化。这种事务实现方法就是Commit Logging</p><p>Commit Logging，有几个切入的判断点：</p><ol><li>日志成功写了Commit Record表示事务成功了</li><li>如果发生了崩溃，看到Commit Record不完整，那就需要将已经提交Commit Record的记录回滚掉。</li></ol><p>Commit Logging的缺陷：<br><figure class="highlight plain"><figcaption><span>Record提交之后进行的。才不管你的磁盘I/O是否有空闲。别管有什么理由不能在事务提交之前就开始修改磁盘上的数据。```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">为了解决Commit Logging的缺陷，基于ARIES理论的&quot;Write Ahead Logging&quot;的日志改进方案就出现了</span><br><span class="line"></span><br><span class="line">##### Write Ahead Logging</span><br><span class="line"></span><br><span class="line">就是允许事务在提交之前，提前写入变动数据的意思。</span><br><span class="line"></span><br><span class="line">* FORCE:当事务提交后，要求变动数据必须同时完成写入则称为FORCE，如果不强制变动数据必须同时完成写入则称为NO-FORCE。现实中绝大多数数据库采用的都是NO-FORCE策略，只要有了日志，变动数据随时可以持久化，从优化磁盘I/O性能考虑，没有必要强制数据写入立即进行。</span><br><span class="line">* STEAL:在事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO-STEAL。从优化磁盘I/O性能考虑，允许数据提前写入，有利于利用空闲I/O资源，也有利于节省数据库缓存区的内存。</span><br><span class="line"></span><br><span class="line">Commit Logging允许NO-FORCE，但不允许STEAL。</span><br><span class="line">Write-Ahead Logging允许NO-FORCE，也允许STEAL。（性能最高，复杂性最高）</span><br><span class="line"></span><br><span class="line">实现方式：增加UnDo log日志，在变动数据写入磁盘之前，必须先记录UnDo log。这个log中明确记录修改了哪个位置的数据，从什么值改成了什么值。在需要回滚的时候，再根据这个日志来进行处理。</span><br><span class="line"></span><br><span class="line">#####  使用UnDo log，Write Ahead Logging在崩溃恢复时的三个步骤</span><br><span class="line">* 分析阶段：把没有End Record的事务组成一个待恢复集合</span><br><span class="line">* 重做阶段：从上述的集合中找到包含Commit Record的日志，把它们持久化到磁盘当中</span><br><span class="line">* 回滚阶段：经过上述两个步骤之后，把这个待恢复的集中的剩余事务全部圆润</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 如何实现隔离性</span><br><span class="line"></span><br><span class="line">隔离性保证了每个事务在各自读、写的数据都互相独立，彼此不受影响</span><br><span class="line"></span><br><span class="line">##### 数据库提供的三种锁</span><br><span class="line"></span><br><span class="line">* 写锁（排他锁）</span><br><span class="line">只有持有写锁的事务才能对数据进行写入操作，数据被加上写锁时，其他事务不能写入数据，也不能加读锁。</span><br><span class="line">写锁禁止其他事务施加读锁，而不是禁止事务读取数据</span><br><span class="line">* 读锁（共享锁）</span><br><span class="line">多个事务可以对一行数据添加多个读锁，数据被加上读锁之后就不能再加写锁了，所有数据都不能对该数据进行写入，但仍然可以读取。</span><br><span class="line">* 范围锁</span><br><span class="line">对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入</span><br><span class="line">```sql</span><br><span class="line">select * from books where price&lt;100 for update;##范围锁</span><br></pre></td></tr></table></figure></p><h4 id="四种隔离级别-从高到低"><a href="#四种隔离级别-从高到低" class="headerlink" title="四种隔离级别(从高到低)"></a>四种隔离级别(从高到低)</h4><h5 id="可串行化：强度最高的隔离性"><a href="#可串行化：强度最高的隔离性" class="headerlink" title="可串行化：强度最高的隔离性"></a>可串行化：强度最高的隔离性</h5><p>对事务所有读、写的数据全部加上读锁、写锁和范围锁</p><h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>对事务所涉及到的数据加读锁、写锁，但不加范围锁</p><p>可重复读比可串行化弱化的地方在于幻读问题，它是指在事务执行的过程中，两个完全相同的范围查询得到了不同的结果集</p><p><code>特例：MySQL/InnoDB默认隔离级别是可重复读，但是在只读事务中避免了幻读问题。但是在读写事务中幻读问题依然存在</code></p><h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h5><p>对事务所涉及到的数据加的写锁，会一直持续到事务结束。而加的读锁在查询完成之后就会马上释放。<br>读已提交比可重复读弱化的地方在于不可重复读问题，它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。</p><p>在这个隔离级别下，两次重复执行的查询结果不一样的原因：读是在查询完成就直接释放了。并没有贯穿整个事务的生命周期，也没有办法禁止读取过的数据发生修改。</p><h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><p>对事务涉及到数据只加写锁，一直持续到事务结束，但完全不加读锁。</p><p>读未提交比读已提交弱化的地方在于脏读问题，它是指在事务执行的过程中，一个事务读取到了另一个事务未提交的数据。</p><h4 id="MVCC基础原理"><a href="#MVCC基础原理" class="headerlink" title="MVCC基础原理"></a>MVCC基础原理</h4><p>针对一个事务读、另一个事务写的场景而提出的无锁优化方案，是一种读取优化策略。注意只是针对读+写的事务场景（写+写，就令当别论了）</p><p>基本思路：对数据的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本同时存在。借用这种手段来达到读取时不加锁的目的。</p><p>从全局的角度来看，可以理解为给每一行数据都增加两个默认为空的字段：CREATE_VERSION和DELETE_VERSION。当有数据发生变化时，通过控制这两个字段来进行处理：</p><ul><li>数据被插入时：CREATE_VERSION记录插入数据的事务ID，DELETE_VERSION为空。</li><li>数据被删除时：DELETE_VERSION记录删除数据的事务ID，CREATE_VERSION为空。</li><li>数据被修改时：将修改视为“删除旧数据，插入新数据”，即先将原有数据复制一份，原有数据的DELETE_VERSION记录修改数据的事务ID，CREATE_VERSION为空。复制出来的新数据的CREATE_VERSION记录修改数据的事务ID，DELETE_VERSION为空。</li></ul><p>数据是记录好了，怎么用呢？</p><p>会根据隔离级别来决定到底应该读取哪个版本的数据：</p><ul><li>隔离级别是可重复读：总是读取CREATE_VERSION小于或等于当前事务ID的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务ID最大）的。</li><li>隔离级别是读已提交：总是取最新的版本即可，即最近被Commit的那个版本的数据记录。</li></ul>]]></content>
    
    <summary type="html">
    
      事务架构探索
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>事务处理三</title>
    <link href="https://by1way.github.io/2020/12/07/transaction3/"/>
    <id>https://by1way.github.io/2020/12/07/transaction3/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2020-12-14T09:32:27.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="讨论范围"><a href="#讨论范围" class="headerlink" title="讨论范围"></a>讨论范围</h3><p>分布式事务:多个服务同时访问多个数据源的事务处理机制</p><h4 id="CAP（以下特性只能2选1）"><a href="#CAP（以下特性只能2选1）" class="headerlink" title="CAP（以下特性只能2选1）"></a>CAP（以下特性只能2选1）</h4><ul><li>一致性</li><li>可用性</li><li>分区容错性</li></ul><h4 id="CA，放弃P"><a href="#CA，放弃P" class="headerlink" title="CA，放弃P"></a>CA，放弃P</h4><p>主流RDBMS集群通常是采用放弃分区容错性的工作模式，例如RAC集群采用共享磁盘的方式来避免网络分区的出现。每个节点都有SGA,UNDO LOG 和REDO LOG，但各节点共享同一份数据文件和控制文件</p><h4 id="CP，放弃A"><a href="#CP，放弃A" class="headerlink" title="CP，放弃A"></a>CP，放弃A</h4><p>先假设一旦出现网络分区，节点之间信息的同步可以无限的延长。从而采用2PC/3PC手段来，同时获取分区容错性和一致性。</p><h4 id="AP，放弃C"><a href="#AP，放弃C" class="headerlink" title="AP，放弃C"></a>AP，放弃C</h4><p>目前大多数分布式系统设计的主流选择，大多数的NoSQL库和支持分布式的缓存都是AP系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ACID CAP中讨论的一致性为强一致性，或线性一致性</span><br><span class="line"></span><br><span class="line">牺牲了C的AP,又想尽可能获取正确结果的行为，称为弱一致性，它的特例：最终一致性。</span><br></pre></td></tr></table></figure><h3 id="分布式事务实现方式"><a href="#分布式事务实现方式" class="headerlink" title="分布式事务实现方式"></a>分布式事务实现方式</h3><p>最终一致性的实现方式：可靠消息队列、TCC、SAGA</p><h4 id="可靠消息队列"><a href="#可靠消息队列" class="headerlink" title="可靠消息队列"></a>可靠消息队列</h4><p>通过持续重试的机制，来保证可靠性。最大努力交付<br>具体实现如下：<br>系统把最有可能出错的业务，以本地事务的方式完成后，通过不断重试的方式，来促使同个事务的其他关联业务来完成。</p><p>缺点：没有任务隔离性，在电商场景中可能导致的问题就是超售</p><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC天生适合用于需要强隔离性的分布式事务中。他需要先把资源给冻住，然后执行后续的操作。</p><ol><li>Try，尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好事务需要用到的所有业务资源（保障隔离性）</li><li>Confirm，确认执行阶段，确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理</li><li>Cancel，取消执行阶段，释放Try阶段预留的业务资源</li></ol><p>一般通过事务中间件（阿里seata)来完成</p><p>缺点：</p><ul><li>业务侵入性较强</li></ul><p>如果出现不合作（不可控）的第三方，往往在第一步Try就无法施行了。</p><h4 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h4><p>引入事务补偿的机制来代替回滚的操作。</p><p>实现原理：将大事务拆解为N个小事务，并且为每个事务设计一个对应的补偿机制</p>]]></content>
    
    <summary type="html">
    
      事务架构探索，分布式事务
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>事务处理二</title>
    <link href="https://by1way.github.io/2020/12/07/transaction2/"/>
    <id>https://by1way.github.io/2020/12/07/transaction2/</id>
    <published>2020-12-07T02:05:51.000Z</published>
    <updated>2020-12-17T02:08:00.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局事务和共享事务"><a href="#全局事务和共享事务" class="headerlink" title="全局事务和共享事务"></a>全局事务和共享事务</h3><p>全局事务和共享事务，是分布式事务的一种中间形式，起到的是承上启下的作用</p><h4 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">回忆</span><br><span class="line"></span><br><span class="line">应用场景：单服务多数据源</span><br><span class="line">实现方式：2PC 3PC</span><br><span class="line"></span><br><span class="line">弱一致性、最终一致性，解决不了一致性问题</span><br><span class="line"></span><br><span class="line">共享事务：通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作</span><br><span class="line"></span><br><span class="line">问题既然已经出现，又该如何应对。各种解决方案又有什么样的处理方式呢？</span><br></pre></td></tr></table></figure><p>全局事务是一种适用于单个服务使用多个数据源场景的事务解决方案。</p><h5 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h5><p>XA协议：定义了全局事务管理器和局部的资源管理器之间的通讯接口。常见的现象有：XADataSource/XAResource</p><p>Java对于XA的实现：JTA，定义了事务管理器接口、满足XA规范的资源定义接口。</p><p>两段式提交、三段式提交也是基于XA协议的实现</p><h5 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h5><ul><li>准备阶段：<br>  由协调者询问，事务的所有参与者是否准备好，如果准备好就回复Prepared,否则回复Non-Prepared<br>  准备，把所有要提交的操作都写到重做日志记录中。只是不写Commit Record</li><li>提交阶段:<br>  在收到所有参与者回复的Perpared消息后，将本地持久化事务状态改为Commit,然后向所有参与者发送Commit指令，所有参与者立即执行提交操作。<br>  如果任意一个参与者回复了Non-Prepared消息，或任意一个参与者超时未回复，协调者都会将自己的事务状态持久化为“Abort”之后，    向所有参与者发送Abort指令，参与者立即执行回滚操作    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两阶段提交保证成功的前提:</span><br><span class="line">1. 必须假设网络在提交阶段这个短时间内是可靠的，即提交阶段不会丢失消息。</span><br><span class="line">2. 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。</span><br><span class="line"></span><br><span class="line">出现问题的场景：</span><br><span class="line">当协调者将本地的状态持久为commit后，并提交了本地的事务，这个时候出现的网络中断，再也无法通过网络向参与者发送commit指令，就会导致协调者提交事务，参与者既没法提交也法回滚的情况。从而导致数据不一致。</span><br></pre></td></tr></table></figure><p>两段式提交存在的问题</p><ol><li>单点问题:协调者宕机</li><li>性能问题:整个过程要持续到所有参与者中最慢的那个处理完成之后</li><li>一致性风险：当网络稳定性和宕机恢复能力的假设不成立时，会出现严重的一致性问题。</li></ol><h5 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h5><p>解决两段式提供存在的三个问题中的前两个，也就是单点问题和性能问题，但并没有解决一致性风险。</p><p>如何解决的呢</p><ul><li>单点问题：<br>  CanCommit：准备阶段，询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。也意味着因某个参与者        提交时发生崩溃而导致全部回滚的风险相对变小了。如果有一个参与者无法完成，这个时候也没有涉及资源被锁住的风险。从这种角度上来看也提升了一些性能。但是也仅仅是在需要回滚的场景中，但是正常提交的情况，性能却多了一个限制 。<br>  PreCommit：准备阶段，<br>  DoCommit：提交阶段</li></ul><h4 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h4><p>多个服务共同一个数据源，共享数据库连接，通过数据库中间件的形式，通过消息将所有对数据库的改动传送到消息队列服务器，然后通过消息的消费者来统一处理，实现由本地事务保障的持久化操作</p>]]></content>
    
    <summary type="html">
    
      事务架构探索，全局事务、共享事务
    
    </summary>
    
      <category term="架构探索" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="事务处理" scheme="https://by1way.github.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习之旅</title>
    <link href="https://by1way.github.io/2020/12/01/mongodb/index0/"/>
    <id>https://by1way.github.io/2020/12/01/mongodb/index0/</id>
    <published>2020-12-01T07:04:51.000Z</published>
    <updated>2020-12-25T06:25:40.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ol><li>什么MongoDb<br>一个以JSON为数据模型的文档数据库</li><li>为什么叫文档数据库<br>文档来自于“JSON Document”,并非我们理解 的pdf word文档</li><li>主要用途<br>应用数据库，类似于Oracle/MYSQL,海量数据处理，数据平台</li><li>主要特点<br>建模为可选，JSON数据模型比较适合开发者，横向扩展可以支撑很大数据量和并发</li></ol><p>ACID事务支持在4.0已经支持</p><ol start="5"><li>MongoDB VS. 关系型数据库<br><img src="/2020/12/01/mongodb/index0/index0_files/1.jpg" alt="对比"></li></ol><h3 id="MongoDB的特色及优势"><a href="#MongoDB的特色及优势" class="headerlink" title="MongoDB的特色及优势"></a>MongoDB的特色及优势</h3><p>优势1：面向开发者的易用+高效数据库</p><p>无模式设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">多形性：同一个集合中可以包含不同字段的文档对象</span><br><span class="line">动态性：线上修改数据模式，修改是应用与数据库均无须下线</span><br><span class="line">数据治理 ：支持使用JSON Schema来规范数据模式，在保证模式灵活动态的前提下，提供数据治理 能力</span><br><span class="line"></span><br><span class="line">JSON模型之快速特性：```技术优势</span><br></pre></td></tr></table></figure><ul><li>数据库引擎只需要在一个存储区读写</li><li>反范式、无关联的组织 极大优化查询速度</li><li>程序 API自然，开发快速</li></ul><p>优势2：原生的高可用和横向扩展能力<br>（分布式方面的优势）</p><p>默认3个节点的复制部署（最少2最多50个）<br>奇数</p><p>Application –&gt;Driver–&gt;Primary/Secondary/Secondary(Replication)</p><p>横向能力：需要的时候无缝扩展/应用全透明/多种数据分布策略/轻松支持TB/PB数量级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> dbs</span><br><span class="line"><span class="keyword">show</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> xx</span><br><span class="line"></span><br><span class="line">db.xx.findOne()</span><br><span class="line"></span><br><span class="line">db.fruit.insertOne(&#123;<span class="keyword">name</span>:<span class="string">"orangle"</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.fruit.insertMany([&#123;<span class="keyword">name</span>:<span class="string">"orangle"</span>&#125;,&#123;<span class="keyword">name</span>:<span class="string">"pear"</span>&#125;,&#123;<span class="keyword">name</span>:<span class="string">"banana"</span>&#125;])</span><br><span class="line"></span><br><span class="line">db.fruit.find()</span><br><span class="line"></span><br><span class="line">db.fruit.find(&#123;<span class="string">"name"</span>:<span class="string">"apple"</span>&#125;)</span><br><span class="line"></span><br><span class="line">db.fruit.find(&#123;$<span class="keyword">and</span>:[&#123;<span class="keyword">name</span>:<span class="string">"apple"</span>&#125;,&#123;<span class="keyword">name</span>:<span class="string">"pear"</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">db.fruit.find(&#123;$<span class="keyword">or</span>:[&#123;<span class="keyword">name</span>:<span class="string">"apple"</span>&#125;,&#123;<span class="keyword">name</span>:<span class="string">"pear"</span>&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">db.fruit.find(&#123;<span class="keyword">name</span>:/^p/&#125;)//以字母p开头的</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;a:1&#125;===&gt;a=1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$ne:1&#125;&#125;===&gt; a&lt;&gt;1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$gt:1&#125;&#125;===&gt; a&gt;1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$gte:1&#125;&#125;===&gt; a&gt;=1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$lt:1&#125;&#125;===&gt; a&lt;1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$lte:1&#125;&#125;===&gt; a&lt;=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">更复杂的条件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;a:1,b:1&#125;或者&#123;$and:[&#123;a,1&#125;,&#123;b,1&#125;]&#125;===&gt; a=1 and b=1</span></span><br><span class="line"><span class="comment">&#123;$or:[&#123;a,1&#125;,&#123;b,1&#125;]&#125;===&gt; a=1 or b=1</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$exists:false&#125;&#125;===&gt; a is NULL</span></span><br><span class="line"><span class="comment">&#123;a:&#123;$in:[1,2,3]&#125;&#125;===&gt; a IN(1,2,3)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">$lt</span></span><br><span class="line"><span class="comment">$lte</span></span><br><span class="line"><span class="comment">$gt</span></span><br><span class="line"><span class="comment">$gte</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="MongoDB分片集群架构"><a href="#MongoDB分片集群架构" class="headerlink" title="MongoDB分片集群架构"></a>MongoDB分片集群架构</h3><p>三种常见部署架构</p><p>单机版（20%）：开发测试，不推荐线上环境使用<br>复制集（70%）：高可用，一个二从或更多从节点<br>分片集群（10%）：横向扩展，最小分片集群9~10个实例，适用大型应用场景</p>]]></content>
    
    <summary type="html">
    
      MongoDB数据库学习。
    
    </summary>
    
      <category term="NoSQL数据" scheme="https://by1way.github.io/categories/NoSQL%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="MongoDB" scheme="https://by1way.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>存储系统实战-2</title>
    <link href="https://by1way.github.io/2020/10/27/memory-system-02/"/>
    <id>https://by1way.github.io/2020/10/27/memory-system-02/</id>
    <published>2020-10-27T01:38:22.000Z</published>
    <updated>2020-10-27T09:00:51.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于ES的商品搜索系统"><a href="#基于ES的商品搜索系统" class="headerlink" title="基于ES的商品搜索系统"></a>基于ES的商品搜索系统</h3><h4 id="倒排索引机制"><a href="#倒排索引机制" class="headerlink" title="倒排索引机制"></a>倒排索引机制</h4>]]></content>
    
    <summary type="html">
    
      后端存储实战-专栏学习内容分享
    
    </summary>
    
      <category term="专栏学习" scheme="https://by1way.github.io/categories/%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="课堂笔记" scheme="https://by1way.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
      <category term="存储系统" scheme="https://by1way.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>存储系统实战-1</title>
    <link href="https://by1way.github.io/2020/10/23/memory-system-01/"/>
    <id>https://by1way.github.io/2020/10/23/memory-system-01/</id>
    <published>2020-10-23T01:38:22.000Z</published>
    <updated>2020-10-27T08:32:26.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="购物车如何设计"><a href="#购物车如何设计" class="headerlink" title="购物车如何设计"></a>购物车如何设计</h3><h4 id="购物车存储时需要考虑清楚的问题"><a href="#购物车存储时需要考虑清楚的问题" class="headerlink" title="购物车存储时需要考虑清楚的问题"></a>购物车存储时需要考虑清楚的问题</h4><ul><li>1.用户没登录，在浏览器中加购，关闭浏览器再打开，刚才回购的商品还在吗？(存在)</li><li>2.用户没登录，在浏览器中回购，然后登录，刚才回购的商品还在不在？(存在)</li><li>3.关闭浏览器再打开，上一步回购的商品还在不在？(不存在)</li><li>4.再打开手机，用相同的用户登录 ，第二步回购的商品还在不在？(存在)</li></ul><p><strong>暂存购物车</strong>、<strong>用户购物车</strong></p><h4 id="购物车设计原则"><a href="#购物车设计原则" class="headerlink" title="购物车设计原则"></a>购物车设计原则</h4><ul><li>如果未登录，需要临时暂存购物车的商品；</li><li>用户登录时，把暂存购物车的商品合并到用户购物车中，并且清除暂存购物车；</li><li>用户登陆后，购物车中的商品，需要在浏览器、手机 APP 和微信等等这些终端中都保持同步。</li></ul><h4 id="暂存购物车设计"><a href="#暂存购物车设计" class="headerlink" title="暂存购物车设计"></a>暂存购物车设计</h4><p>一般的设计都会将这批数据存储在客户端，采用Session、Cookie、LocalStorge,APP的本地存储原理也是类似</p><ul><li>Session的缺陷：保留时间短</li><li>Cookie：每次交互都需要把数据给带上，存储上限4K</li><li>LocalStorage:只能由客户端来访问,</li></ul><h4 id="用户购物车设计"><a href="#用户购物车设计" class="headerlink" title="用户购物车设计"></a>用户购物车设计</h4><p>使用关系型数据库来存储购物车数据，如果追求性能或者高开发，也可以选择Redis</p><h3 id="账户系统的设计"><a href="#账户系统的设计" class="headerlink" title="账户系统的设计"></a>账户系统的设计</h3><p><strong>对不上账，最本质的原因就是，冗余数据的一致性问题</strong></p><p>账户流水：每一笔交易记录，只能新增</p><h4 id="如何保证账户系统中流水和余额的一致"><a href="#如何保证账户系统中流水和余额的一致" class="headerlink" title="如何保证账户系统中流水和余额的一致"></a>如何保证账户系统中流水和余额的一致</h4><ol><li><p>使用数据库事务来保证数据一致性</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li><li><p>事务隔离级别<br> <img src="/2020/10/23/memory-system-01/memory-system-01_files/1.jpg" alt></p><ul><li>脏读：每个进行中事务的中间状态，对其他事务都是可见的</li><li>不可重复读：在同一个事务内两次读取同一条数据，读到的结果可能会不一样</li></ul></li></ol><h3 id="如何解决跨系统、跨数据库的数据一致性问题？"><a href="#如何解决跨系统、跨数据库的数据一致性问题？" class="headerlink" title="如何解决跨系统、跨数据库的数据一致性问题？"></a>如何解决跨系统、跨数据库的数据一致性问题？</h3><p>我们在使用分布式事务时，更多的情况都是使用分布式事务的理论来指导设计和开发。</p><h4 id="分布式事务的实现原理"><a href="#分布式事务的实现原理" class="headerlink" title="分布式事务的实现原理"></a>分布式事务的实现原理</h4><ol><li><p>2PC<br> 2PC引入了一个事务协调者的角色，来协调多个系统，协调者对客户端提供一个完整的服务，在这个服务内部，协调者再分别调用不同系统间的相应服务<br> 二阶段指的是准备阶段和提交阶段。<br> 在准备阶段，协调者对各系统发送【准备】指令，各系统在接收准备命令之后，开始执行准备操作。准备操作包括，除提交数据库事务之外的所有工作。等各个系统都准备完成后，就进入到了提交阶段。<br> 在提交阶段，协调者再给各系统发送【提交】指令，系统在接收到指令后，都提交自己的数据库事务，然后返回给协调者提交成功的响应。<br> 协调在接收到所提交成功的响应后，再给客户端返回成功的响应，这样整个分布式事务就完成了。</p><p> 以上都不是重点！！！！<br> 异常了怎么处理才是重点：</p><ul><li>在准备阶段：如果任何一步出现错误或者超时，协调者会马上给各系统发送回滚的请求</li><li><p>提交阶段：分布式事务只能成功不能失败！如果是超时那就一直重试，直到提交成功为止。</p><p>2PC适用于对数据一致性要求比较高的场景。要求强一致、并发量不大的情况下</p><p>缺点：整个事务的执行过程需要阻塞服务端的线程和数据库的会话，所以，2PC 在并发场景下的性能不会很高。并且，协调者是一个单点，一旦过程中协调者宕机，就会导致订单库或者促销库的事务会话一直卡在等待提交阶段，直到事务超时自动回滚。</p></li></ul></li></ol><ol start="2"><li><p>本地消息表<br> 本地消息表适合解决分布式最终一致性的问题</p><ul><li><p>实现思路：某一个系统在接收到请求后，正常的使用本地的数据库事务去更新数据库，同时在执行这个事务的过程中，在本地记录一条消息。然后再用一个异步的服务去读取刚刚记录的本地消息，调用自己的服务，这样的话如果是失败了也可以通过重试来解决。最终保证各系统的数据都是一致的。</p><p>本地消息表实现手段：消息队列、数据库、本地磁盘文件</p><p>本地消息表缺点：必须要有一个前提条件，那就是异步执行的那部分操作，不能有依赖的资源。</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      后端存储实战-专栏学习内容分享
    
    </summary>
    
      <category term="专栏学习" scheme="https://by1way.github.io/categories/%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="课堂笔记" scheme="https://by1way.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
      <category term="存储系统" scheme="https://by1way.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>存储系统实战-0</title>
    <link href="https://by1way.github.io/2020/10/22/memory-system-00/"/>
    <id>https://by1way.github.io/2020/10/22/memory-system-00/</id>
    <published>2020-10-22T01:38:22.000Z</published>
    <updated>2020-10-22T10:03:59.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础的认识"><a href="#基础的认识" class="headerlink" title="基础的认识"></a>基础的认识</h3><p><strong>凡是那些特别难解决的、让你付出巨大代价的，或者损失惨重的技术问题，几乎都可以归结为存储系统的问题</strong></p><p><strong>存储是系统中最核心、最重要、最关键的组成部分，没有之一</strong></p><p><strong>MySQL、Redis、ElasticSearch、HBase、Hive、MongoDB、RocksDB、CockroachDB 等等，这些存储还真就是谁都替代不了谁，每一种都有它擅长的地方，有它适用的场景，当然也有很突出的短板。如何根据业务系统的特点，选择合适的存储来构建我们的系统，这也是需要学习和掌握的</strong></p><h3 id="如何保证数据准确无误"><a href="#如何保证数据准确无误" class="headerlink" title="如何保证数据准确无误"></a>如何保证数据准确无误</h3><p><strong>合格的订单系统，最基本的要求是数据不能出错</strong></p><h4 id="如何避免重复下单"><a href="#如何避免重复下单" class="headerlink" title="如何避免重复下单"></a>如何避免重复下单</h4><ul><li>让订单服务具备幂等性<ul><li>任意多次执行所产生的影响均与一次执行的影响相同</li><li>利用数据库主键的唯一性约束来解决创建订单服务的幂等性问题（自定义一个订单号生成的服务）</li></ul></li></ul><h4 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a>如何解决ABA问题</h4><p><strong>对数据的更新也要注意ABA问题</strong></p><ul><li>什么是ABA问题<ul><li>一个简单的例子，假如有两次请求，第一次要求把数据修改为666，当数据库修改成功，在返回响应的时候失败了，而此时第二个请求到了，要把数据修改为888，并且响应成功了。由于第一次申请没有收到正确的响应，所以进行了重试，这时数据又修改成了666。</li></ul></li></ul><ul><li>怎么解决呢？<ul><li>给数据库表增加一列version,也就是版本号的意思，每次查询version都随着数据返回，再更新的时候把version作为更新请求的参数，发送给更新服务</li><li>更新服务在接收到请求后，对比当前数据的version，是否与请求中的一致，如果不一致就拒绝更新。如果一致，就更新数据的同时把version+1。<strong>当前这个更新的过程必须在同一事务里面</strong></li></ul></li></ul><h3 id="商品详情页如何设计"><a href="#商品详情页如何设计" class="headerlink" title="商品详情页如何设计"></a>商品详情页如何设计</h3><h4 id="商品都包括哪些信息"><a href="#商品都包括哪些信息" class="headerlink" title="商品都包括哪些信息"></a>商品都包括哪些信息</h4><ul><li>基本信息</li><li>商品参数</li><li>商品介绍</li><li><h1 id="图片视频"><a href="#图片视频" class="headerlink" title="图片视频"></a>图片视频</h1></li><li>促销信息</li><li>推荐商品</li><li>评价信息</li><li>评论信息</li><li>配送信息</li><li>店铺信息</li></ul><h4 id="商品基本信息如何存储"><a href="#商品基本信息如何存储" class="headerlink" title="商品基本信息如何存储"></a>商品基本信息如何存储</h4><ol><li>商品基本信息的主副标题、价格、颜色等基本、主要属性，都是固定的。数据量不大，建议在数据库中建一张表来保存商品基本信息。然后在数据库前面加一道缓存，基于内存的KV存储。</li><li>前置缓存缓存商品数据，读取请求流程：<br> 2.1. 先去缓存查找，如果找到就直接返回数据<br> 2.2. 如果没有找到就去数据库查询，把返回结果返回，并缓存一份到缓存</li><li>更新时，在更新数据库的同时也要把缓存给删除，来保证数据一致性(Cache Aside缓存更新策略)</li></ol><p><strong>设计商品信息表时，一定要记得保留商品数据的每一个历史版本</strong></p><h5 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h5><ul><li>Cache Aside</li><li>Read/Write Through</li><li>Write Behind</li></ul><h4 id="商品参数如何存储"><a href="#商品参数如何存储" class="headerlink" title="商品参数如何存储"></a>商品参数如何存储</h4><p>使用MongoDB保存商品参数，和商品的基本属性一样，都是结构化数据，不同类型的商品，它的参数也完全不一样。</p><h5 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h5><p>MongoDB是一个面向文档存储的NoSQL数据库，在MongoDB中，表、行、列对应概念：Collection、document、field。<br>表结构是不需要事先定义，MongoDB没有表结构。支持把任意数据放在同一张表中。</p><p>MongoDB中的每一行数据，在存储层就是简单地转化成BSON格式。<strong>这是一种更紧凑的JSON</strong>，MongoDB 不支持 SQL，多表联查和复杂事务比较孱弱，不太适合存储一般的数据。对于商品参数信息，数据量大、数据结构不统一，这些 MongoDB 都可以很好的满足。我们也不需要事务和多表联查，MongoDB 简直就是为了保存商品参数量身定制的一样。</p><h4 id="图片和视频如何存储"><a href="#图片和视频如何存储" class="headerlink" title="图片和视频如何存储"></a>图片和视频如何存储</h4><p><strong>保存在对象存储中</strong></p><h5 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h5><p>对象存储可以简单理解为一个无限容量的大文件 KV 存储，它的存储单位是对象，其实就是文件，可以是一张图片，一个视频，也可以是其他任何文件。每个对象都有一个唯一的 key，利用这个 key 就可以随时访问对应的对象。基本的功能就是写入、访问和删除对象。</p><h4 id="商品介绍如何存储"><a href="#商品介绍如何存储" class="headerlink" title="商品介绍如何存储"></a>商品介绍如何存储</h4><p><strong>商品介绍的文本，一般都是随着商详页一起静态化，保存在 HTML 文件中</strong></p><p><strong>Tomcat 能能抗的并发量和 Nginx 完全不是一个数量级的</strong></p><p>商详页静态化之后，不仅仅是可以节省服务器资源，还可以利用 CDN 加速，把商详页放到离用户最近的 <strong>CDN 服务器</strong>上，让商详页访问更快。</p><p><code>商品系统的存储需要提供商品的基本信息、商品参数、图片和视频以及商品介绍等等这些数据。商品的基本信息和商品参数分别保存在 MySQL 和 MongoDB 中，用 Redis 作为前置缓存，图片和视频存放在对象存储中，商品介绍随着商详页一起静态化到商详静态页中。</code></p>]]></content>
    
    <summary type="html">
    
      后端存储实战-专栏学习内容分享
    
    </summary>
    
      <category term="专栏学习" scheme="https://by1way.github.io/categories/%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="课堂笔记" scheme="https://by1way.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
      <category term="存储系统" scheme="https://by1way.github.io/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>架构师训练营课堂笔记01周</title>
    <link href="https://by1way.github.io/2020/09/28/SATR-01/"/>
    <id>https://by1way.github.io/2020/09/28/SATR-01/</id>
    <published>2020-09-28T01:38:22.000Z</published>
    <updated>2020-09-28T10:15:33.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>训练营已经结束一周了，虽然也做了课程总结以及整个课程的思维导图，脑子里也有了一些东西，但感觉还不是很清晰，所以我想再学习梳理一下。既然有这样的决心，那也一定要相应的计划。说到计划，又开始有点犯愁了，我怕我完不成呀，真的是有点犹豫。因为我还有别的课程要去学。好吧，在这儿经过一番挣扎之后，我还觉得好好计划一下这15周课的总结了。</p><ul><li>9.28-29，第一周</li><li>9.30-10.1，第二周</li><li>10.2-10.3，第三周</li><li>10.4-10.5，第四周</li><li>10.6-10.7，第五周</li><li>10.8-10.9，第六周</li><li>10.10-10.11，第七周</li><li>10.12-10.13，第八周</li><li>10.14-10.15，第九周</li><li>10.16-10.17，第十周</li><li>10.18-10.19，第十一周</li><li>10.20-10.21，第十二周</li><li>10.22-10.23，第十三周</li><li>10.24-10.25，第十四周</li><li>10.26-10.27，第十五周</li></ul><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>本节重点</p><ol><li>课程学什么</li><li>课程是怎么设计的</li><li>如何学习这门课程</li><li>通过课程可以收获到什么</li></ol><p>希望训练营能带来一些收获：关于架构的思维方式，解决问题的一些方式，知识体系能够串起来能够领悟它，所以悟性很重要，明白为什么要这样。问题是什么，比如何做对架构而言都更重要一点</p><p>训练营不讲技术的应用，技术的应用不应该是架构所关注的点，用什么样的思维方式去面对问题，能够领悟到问题的本质是什么。</p><p>训练营想训练的是面对问题，思考问题的一种方式，解决问题的思路以及思路背后的关系，然后把这些再统统的整合在一起</p><p>悟性，悟性、悟性。</p><p>ppt是知识的架子。悟到是一层窗户纸</p><h3 id="架构方法（架构师如何做架构）"><a href="#架构方法（架构师如何做架构）" class="headerlink" title="架构方法（架构师如何做架构）"></a>架构方法（架构师如何做架构）</h3><p>架构师输出的是什么？ppt?</p><h4 id="如何成为架构师"><a href="#如何成为架构师" class="headerlink" title="如何成为架构师"></a>如何成为架构师</h4><pre><code>做架构是需要，架构方案、架构设计大家按这个设计进行分工开发做架构的途径：1、要有任命（跳槽、内部晋升）架构师面试大厂offer该如何获取</code></pre>]]></content>
    
    <summary type="html">
    
      极客大学架构师训练营，主讲李智慧老师，随堂学习笔记
    
    </summary>
    
      <category term="架构师训练营" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
      <category term="课堂笔记" scheme="https://by1way.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
      <category term="分享" scheme="https://by1way.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://by1way.github.io/2020/09/28/plan/"/>
    <id>https://by1way.github.io/2020/09/28/plan/</id>
    <published>2020-09-28T01:38:22.000Z</published>
    <updated>2020-10-23T06:54:25.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="到底应该先学哪一个呢？幸福来的太突然"><a href="#到底应该先学哪一个呢？幸福来的太突然" class="headerlink" title="到底应该先学哪一个呢？幸福来的太突然"></a>到底应该先学哪一个呢？幸福来的太突然</h3><p>每天三篇的话，最多也就一个月能完成一个专栏。是不是也挺实际的呀。哈哈</p><ul><li>左耳听风</li><li>DDD实战课（一定要把这个给啃下来）</li><li>许式伟架构课</li><li>消息队列高手课</li><li>Java性能调优实战</li><li>架构实战案例解析</li><li>Java业务开发觉错误100例：这个特配合代码来，没有那么多实践经验的话，也学不太深入，最多也只是走马观花，有个大概的印象，目前不太适合速读</li><li>JVM实战高手</li><li>MySQL实战优化高手</li><li>趣谈网络协议</li><li>重学前端</li><li>设计模式之美</li><li>Spring Cloud 微服务核心技术与实战</li></ul>]]></content>
    
    <summary type="html">
    
      专栏学习内容分享
    
    </summary>
    
      <category term="专栏学习" scheme="https://by1way.github.io/categories/%E4%B8%93%E6%A0%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="课堂笔记" scheme="https://by1way.github.io/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
      <category term="分享" scheme="https://by1way.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://by1way.github.io/2020/09/15/readingmethod/"/>
    <id>https://by1way.github.io/2020/09/15/readingmethod/</id>
    <published>2020-09-15T06:47:57.035Z</published>
    <updated>2020-09-15T06:48:03.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7S阅读法"><a href="#7S阅读法" class="headerlink" title="7S阅读法"></a>7S阅读法</h2><h3 id="S1-提问，阅读一篇文章或一本书之前自问四个问题"><a href="#S1-提问，阅读一篇文章或一本书之前自问四个问题" class="headerlink" title="S1 提问，阅读一篇文章或一本书之前自问四个问题"></a>S1 提问，阅读一篇文章或一本书之前自问四个问题</h3><ol><li>我为什么想要读它</li><li>它对我来说有多重要</li><li>我要获得哪些信息</li><li>我打算把阅读获得的知识有在哪些方面</li></ol><h3 id="S2-速览"><a href="#S2-速览" class="headerlink" title="S2 速览"></a>S2 速览</h3><p>​    通过快速扫视全文，发现关键词和关键句子，在大脑中进行整合，简单理解作者传达的信息。</p><p><code>S1和S2就是快速阅读法，适用于休闲读书或深度阅读之前的准备</code></p><h3 id="S3-融合，用摘录法记录关键词和标记不易理解的段落"><a href="#S3-融合，用摘录法记录关键词和标记不易理解的段落" class="headerlink" title="S3 融合，用摘录法记录关键词和标记不易理解的段落"></a>S3 融合，用摘录法记录关键词和标记不易理解的段落</h3><h3 id="S4-重构，用自己的语言，重述内容"><a href="#S4-重构，用自己的语言，重述内容" class="headerlink" title="S4 重构，用自己的语言，重述内容"></a>S4 重构，用自己的语言，重述内容</h3><h3 id="S5-回忆，通过提问回忆习得的知识"><a href="#S5-回忆，通过提问回忆习得的知识" class="headerlink" title="S5 回忆，通过提问回忆习得的知识"></a>S5 回忆，通过提问回忆习得的知识</h3><pre><code>1. 作者是在文中讲了什么2. 作者是如何讲述认证的3. 内容和我有什么关系4. 读完后对我来说有什么用</code></pre><p><code>S3、S4、S5是深度阅读阶段，回忆与重构正是我所用的阅读笔记的做法</code></p><h3 id="S6-延伸，寻找相关材料，扩展知识的深度和广度"><a href="#S6-延伸，寻找相关材料，扩展知识的深度和广度" class="headerlink" title="S6 延伸，寻找相关材料，扩展知识的深度和广度"></a>S6 延伸，寻找相关材料，扩展知识的深度和广度</h3><h3 id="S7-交流，包括书面、口头、行动等沟通形式"><a href="#S7-交流，包括书面、口头、行动等沟通形式" class="headerlink" title="S7 交流，包括书面、口头、行动等沟通形式"></a>S7 交流，包括书面、口头、行动等沟通形式</h3><pre><code>1. 提出疑问，解决作者未能回答的问题2. 结合自身情况，把知识变成行动指南3. 分享观点，在与他人的碰撞中得到新思路</code></pre><h2 id="读书若是缺少思考和行动，还真不如闭目养神"><a href="#读书若是缺少思考和行动，还真不如闭目养神" class="headerlink" title="读书若是缺少思考和行动，还真不如闭目养神"></a>读书若是缺少思考和行动，还真不如闭目养神</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7S阅读法&quot;&gt;&lt;a href=&quot;#7S阅读法&quot; class=&quot;headerlink&quot; title=&quot;7S阅读法&quot;&gt;&lt;/a&gt;7S阅读法&lt;/h2&gt;&lt;h3 id=&quot;S1-提问，阅读一篇文章或一本书之前自问四个问题&quot;&gt;&lt;a href=&quot;#S1-提问，阅读一篇文章或一本书之
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第二周作业</title>
    <link href="https://by1way.github.io/2020/06/16/architect02/"/>
    <id>https://by1way.github.io/2020/06/16/architect02/</id>
    <published>2020-06-16T07:43:51.000Z</published>
    <updated>2020-06-16T14:28:29.455Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h4><ul><li>请描述什么是依赖倒置原则，为什么有时候依赖倒置原则又被称为好莱坞原则？</li></ul><p>在理解什么依赖倒置原则之前，先思考一个问题，诸如Tomcat/Jetty等容器，是如何做到不依赖其代码却能复用它的功能呢？<br>依赖倒置原则规定如下：</p><ul><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li><li>抽象不应该依赖具体实现，具体实现应该依赖于抽象 </li></ul><p>来细细的品读一下这两条规则：</p><ol><li><p>如果要是高层模块依赖了低层模块会出现什么情况呢？维护起来困难，低层只要发生变化高层势必跟着变；复用困难，这里的复用主要是指对高层模块的应用，也就是业务层面的应用。怎么解决这个问题呢？最直观的一种就是再提出一抽象层出来，双方都依赖于抽象的接口，大家只需实现接口和使用接口即可。还是先前的那个问题，Tomcat这些容器是如何做到它的功能被利用的呢，也就是说web应用在部署到tomcat之后怎么能保证，同样的程序部署到jetty中也同样能运行呢？道理其实很简单，这些web容器都实现了J2EE的规范，web应用都实现了j2EE的Servlet接口。类似的还有JDBC,程序访问数据库都不依赖于数据库驱动包，而是直接调用JDBC提供好的接口，这些接口呢被各种驱动所实现。MVC，ORM框架从这个角度上来看也都是一样的套路。</p></li><li><p>在咱们的日常开发中也常常需要依赖抽象接口，而不是具体的实现。比如Web 开发中，Service 层依赖 DAO 层，并不是直接依赖 DAO 的具体实现，而是依赖 DAO 提供的抽象接口。那么这种依赖是否是依赖倒置呢？其实并不是，依赖倒置原则中，除了具体实现要依赖抽象，最重要的是，抽象是属于谁的抽象。</p></li></ol><p>要理解依赖倒置原则的关键是要理清接口所有权的问题，即这些接口是被谁定义的，又被谁实现的？<br>接口被高层定义，高层模块拥有接口，低层模块实现接口。而不是高层模块依赖底层模块的接口，而是低层模块依赖高层的模块的接口，从而实现依赖关系的倒置。至于倒置，只是一个叫法。</p><p>好莱坞原则：Don’t call me，I will call you。对应到软件里面就是，应用程序不需要调用 Tomcat 或者 Spring 这样的框架，而是框架调用应用程序。而实现这一特性的前提就是应用程序必须实现框架的接口规范，比如实现 Servlet 接口。</p><h4 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h4><ul><li>请描述一个你熟悉的框架，是如何实现依赖倒置原则的。</li></ul><p>分析shiro安全框架如何实现依赖倒置原则：我觉得最契合依赖倒置原则的应该是Realm这一块。首先来发解一下Realm。Realm,就是域,shiro可以从Realm获取安全数据（如用户、角色、权限）,就是说SecurityManager要验证用户身份,那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。所以可以把Realm看成是一个安全数据源。<br>简单了解了一下Realm,都知道在我们的应用是可以定义多个Realm的，在运行期securityManager会按照Realm的顺序，进行身份认证。<br>对于依赖倒置的实现，我的理解是类似于Tomcat，shiro实现了Realm的规范，在应用中自定义的Realm只需实现Realm的接口，在运行期架构会自行调用自定义的Realm。这也就印证了，如何不依赖代码却可以复用它的功能。</p><h4 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h4><ul><li>请用接口隔离原则优化 Cache 类的设计，画出优化后的类图。</li></ul><p><img src="/2020/06/16/architect02/architect_files/1.jpg" alt="类图"></p><p>cache 实现类中有四个方法，其中 put get delete 方法是需要暴露给应用程序的，rebuild 方法是需要暴露给系统进行远程调用的。如果将 rebuild 暴露给应用程序，应用程序可能会错误调用 rebuild 方法，导致 cache 服务失效。按照接口隔离原则：不应该强迫客户程序依赖它们不需要的方法。也就是说，应该使 cache 类实现两个接口，一个接口包含 get put delete 暴露给应用程序，一个接口包含 rebuild 暴露给系统远程调用。从而实现接口隔离，使应用程序看不到 rebuild 方法。</p>]]></content>
    
    <summary type="html">
    
      参加了一个架构师培训班，用他来记录一下作业吧。
    
    </summary>
    
      <category term="架构师训练营" scheme="https://by1way.github.io/categories/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
      <category term="资源" scheme="https://by1way.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>程序员的未来在哪儿</title>
    <link href="https://by1way.github.io/2019/12/17/ARTS-week21/"/>
    <id>https://by1way.github.io/2019/12/17/ARTS-week21/</id>
    <published>2019-12-17T01:38:22.000Z</published>
    <updated>2019-12-17T06:36:49.136Z</updated>
    
    <content type="html"><![CDATA[<p>今天是普通的一天，我早早的起来为亲爱的老婆大人买了份早餐（两根油条，一碗豆腐脑），本来还想给她买份小笼包的，但是一想到小笼包已经八块钱一笼了还是放弃吧，哦咸菜不要钱，那就多夹两筷子吧，反正也不要钱。六点五十的时候看到老板在公司运营群里面发图片，这个点他已经在公司旁边的包子店吃三块钱一个的包子了，老板又来公司这边了，那就不能去公司太晚吧。所以就跟老婆大人请了假说，不能去送闺女大人上班了，只能辛苦她去送了（其实一直都她自己送的，只是最近我会跟着一块儿去）。看到她同意了，我就赶紧背上昨天刚收到的拼多多上拼到的30多块钱的双肩包，来上班了。</p><h4 id="97年天材架构师"><a href="#97年天材架构师" class="headerlink" title="97年天材架构师"></a>97年天材架构师</h4><p>可能是早上醒的有点早，所以地铁上一篇文章都没有看完就开始眼睛涩了，想睡觉。好吧，既然不想学习了，那就刷一会儿网页吧。</p>]]></content>
    
    <summary type="html">
    
      别傻了，程序员哪儿有什么未来？你有吗？反正我是没找到
    
    </summary>
    
      <category term="读书" scheme="https://by1way.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="分享" scheme="https://by1way.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="阅读" scheme="https://by1way.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
